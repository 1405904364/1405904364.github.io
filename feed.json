{
    "version": "https://jsonfeed.org/version/1",
    "title": "Live My Life",
    "description": "个人学习使用",
    "home_page_url": "http://1405904364.github.io",
    "items": [
        {
            "id": "http://1405904364.github.io/2023/08/18/maven/%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0%E6%A0%87%E7%AD%BE/",
            "url": "http://1405904364.github.io/2023/08/18/maven/%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0%E6%A0%87%E7%AD%BE/",
            "title": "常用元素标签",
            "date_published": "2023-08-18T06:16:27.212Z",
            "content_html": "<h1 id=\"pomxml常用元素介绍\"><a class=\"markdownIt-Anchor\" href=\"#pomxml常用元素介绍\">#</a> pom.xml 常用元素介绍</h1>\n<ul>\n<li>project 包含 pom 一些约束的信息</li>\n<li>modelVersion 指定当前 pom 的版本</li>\n<li>groupId（主项目标示，定义当前 maven 属于哪个项目，- 反写公司网址 + 项目名）、</li>\n<li>artifactId（实际项目模块标识，项目名 + 模块名）、</li>\n<li>version（当前项目版本号，第一个 0 标识大版本号，第 - 二个 0 标示分支版本号，第三个 0 标识小版本号，0.0.1，- snapshot 快照，alpha 内部测试，beta 公测，release 稳 - 定，GA 正式发布）</li>\n<li>name 项目描述名</li>\n<li>url 项目地址</li>\n<li>description 项目描述</li>\n<li>developers 开发人员列表</li>\n<li>licenses 许可证</li>\n<li>organization：组织</li>\n<li>dependencies：依赖列表</li>\n<li>dependency：依赖项目 里面放置坐标</li>\n<li>scope：包的依赖范围 test</li>\n<li>optional ：设置依赖是否可选</li>\n<li>exclusions：排除依赖传递列表</li>\n<li>dependencyManagement 依赖的管理</li>\n<li>build：为构建行为提供支持</li>\n<li>plugins：插件列表</li>\n<li>parent：子模块对父模块的继承</li>\n<li>modules：聚合多个 maven 项目</li>\n</ul>\n",
            "tags": [
                "maven"
            ]
        },
        {
            "id": "http://1405904364.github.io/2023/08/18/maven/scope%E6%A0%87%E7%AD%BE/",
            "url": "http://1405904364.github.io/2023/08/18/maven/scope%E6%A0%87%E7%AD%BE/",
            "title": "scope标签的作用",
            "date_published": "2023-08-18T06:16:27.211Z",
            "content_html": "<h1 id=\"scope的作用\"><a class=\"markdownIt-Anchor\" href=\"#scope的作用\">#</a> Scope 的作用</h1>\n<p>概述：</p>\n<blockquote>\n<p>Maven 中使用 scope 来指定当前包的依赖范围和依赖的传递性。常见的可选值有: complie、provide、runtime、test、system 等</p>\n</blockquote>\n<pre><code class=\"language-maven\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n            &lt;version&gt;3.2.1.RELEASE&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<h2 id=\"scope取值\"><a class=\"markdownIt-Anchor\" href=\"#scope取值\">#</a> scope 取值</h2>\n<ul>\n<li>complie\n<ul>\n<li>范围：all</li>\n<li>依赖传递：是</li>\n<li>例子：spring-core</li>\n<li>详解：complie 为默认的依赖有效范围。如果没有明确指定依赖有效范围的花，则默认采用该值。在编译、运行、测试时均有效</li>\n</ul>\n</li>\n<li>provided\n<ul>\n<li>范围：complie、test</li>\n<li>依赖传递：否</li>\n<li>例子：servlet-api</li>\n<li>详解：provided 在编译、测试时有效，但是在运行时无效。例如 servlet-api 依赖，在部署到 tomcat 服务器中，容器已经提供了，就不再需要 maven 重复引入了</li>\n</ul>\n</li>\n<li>runtime\n<ul>\n<li>范围：runtime、test</li>\n<li>依赖传递：是</li>\n<li>例子：JDBC 驱动</li>\n<li>详解：runtime 在运行、测试时有效，但是在编译时无效。例如 JDBC 的驱动实现</li>\n</ul>\n</li>\n<li>test\n<ul>\n<li>范围：test</li>\n<li>依赖传递：否</li>\n<li>例子：JUnit</li>\n<li>详解：只在测试时有效，例如 Junit</li>\n</ul>\n</li>\n<li>system\n<ul>\n<li>范围：complie、test</li>\n<li>依赖传递：是</li>\n<li>例子：</li>\n<li>详解：system 在编译、测试时有效，但是在运行时无效。与 provided 的区别是，使用 system 范围依赖时，必须通过 systemPath 元素显示指定依赖文件的路径。此依赖时通过本机绑定的，不可移植使用，因此要谨慎使用。systemPath 元素可以引用环境变量。例如：<pre><code class=\"language-maven\">        &lt;dependency&gt;\n            &lt;groupId&gt;javax.sql&lt;/groupId&gt;\n            &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt;\n            &lt;version&gt;2.0&lt;/version&gt;\n            &lt;scope&gt;system&lt;/scope&gt;\n            &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;\n        &lt;/dependency&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>在编译或者是运行时有效的范围依赖，在打包时会一起打包</p>\n",
            "tags": [
                "maven"
            ]
        },
        {
            "id": "http://1405904364.github.io/2023/08/10/Java/Stream%E6%B5%81/",
            "url": "http://1405904364.github.io/2023/08/10/Java/Stream%E6%B5%81/",
            "title": "Stream流式编程",
            "date_published": "2023-08-10T08:29:50.064Z",
            "content_html": "<h1 id=\"stream流式编程\"><a class=\"markdownIt-Anchor\" href=\"#stream流式编程\">#</a> Stream 流式编程</h1>\n<h2 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类</h2>\n<p><img data-src=\"/image/Java/13170952_625693608975b29303.webp\" alt=\"分类图片\"></p>\n<p><strong>中间操作</strong>可分为：</p>\n<blockquote>\n<ul>\n<li>无状态：指元素的处理不受之前元素的影响</li>\n<li>有状态：指该操作只有拿到所有元素之后才能继续下去</li>\n</ul>\n</blockquote>\n<p><strong>终结操作</strong>可分为：</p>\n<blockquote>\n<ul>\n<li>非短路操作：指必须处理所有元素才能得到最终结果</li>\n<li>短路操作：指遇到某些符合条件的元素就可以得到最终结果</li>\n</ul>\n</blockquote>\n<p>具体操作如图所示：</p>\n<p><img data-src=\"/image/Java/20201218181011714.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"stream-api使用\"><a class=\"markdownIt-Anchor\" href=\"#stream-api使用\">#</a> Stream API 使用</h2>\n<h3 id=\"流的构成\"><a class=\"markdownIt-Anchor\" href=\"#流的构成\">#</a> 流的构成</h3>\n<blockquote>\n<p>使用流的时候，通常包括三个步骤：</p>\n<ol>\n<li>获取一个数据源</li>\n<li>数据转换<br>\n执行操作获取想要的结果，每次转换原有的 Stream 对象不变，返回一个新的 Stream 对象，这就允许对其操作可以像链条一样排列</li>\n</ol>\n</blockquote>\n<h3 id=\"流的创建\"><a class=\"markdownIt-Anchor\" href=\"#流的创建\">#</a> 流的创建</h3>\n<ul>\n<li>\n<p>通过 java.util.Collection.stream () 方法用集合创建流</p>\n<pre><code class=\"language-Java\">\n  List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;stream&quot;);\n  //创建顺序流\n  Stream&lt;String&gt; stream = list.stream();\n  //创建并行流\n  Stream&lt;String&gt; parallelStream = list.parallelStream();\n\n</code></pre>\n</li>\n<li>\n<p>使用 java.util.Arrays.stream (T [] array) 方法用数组创建流</p>\n<pre><code class=\"language-Java\">\n  String[] array = &#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;&#125;;\n  Stream&lt;String&gt; arrayStream = Arrays.stream(array);\n\n</code></pre>\n</li>\n<li>\n<p>Stream 的静态方法：of ()、iterate ()、generate ()</p>\n<pre><code class=\"language-Java\">\n  Stream&lt;Integer&gt; stream1 = Stream.of(1, 2, 3, 4, 5, 6);\n  \n  Stream&lt;Integer&gt; stream2 = Stream.iterate(0, (x) -&gt; x + 2).limit(3);\n  \n  Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(3);\n\n</code></pre>\n</li>\n<li>\n<p>stream 和 parallelStream 的简单区分</p>\n</li>\n</ul>\n<blockquote>\n<p>stream 是顺序流，由主线程按顺序对流执行操作，而 parallelStream 是并行流，内部以多线程并行执行的方式对流进行操作，需要注意使用并行流的前提是流中的数据处理没有顺序要求（会乱序，即使用了 forEachOrdered）</p>\n</blockquote>\n<hr>\n<h3 id=\"一-stream中间操作\"><a class=\"markdownIt-Anchor\" href=\"#一-stream中间操作\">#</a> 一、Stream 中间操作</h3>\n<pre><code>Stream流中间操作是指在流链当中，可以对数据进行处理操作，包括filter过滤、map映射转换、flatMap合并、distinct去重、sorted排序等操作，这些操作都会返回一个新的Stream流对象，可以通过链式调用多个中间操作进行复杂的数据处理。\n\n需要注意的是，中间操作需要具有终止操作才会触发。\n</code></pre>\n<h4 id=\"无状态stateless操作\"><a class=\"markdownIt-Anchor\" href=\"#无状态stateless操作\">#</a> 无状态 (Stateless) 操作</h4>\n<h5 id=\"filter过滤出符合条件的元素\"><a class=\"markdownIt-Anchor\" href=\"#filter过滤出符合条件的元素\">#</a> filter: 过滤出符合条件的元素</h5>\n<blockquote>\n<p>filter () 方法常用于实现数据过滤，即可以对集合、数组等数据源筛选出符合指定条件的元素，并返回一个新的流</p>\n</blockquote>\n<pre><code class=\"language-Java\">// 将数组转换为一个字符串列表\nList&lt;String&gt; numbers = Arrays.asList&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13358520000&quot;);\n// 通过stream()方法创建一个流，接着使用filter方法过滤出前缀为&quot;133&quot;的元素，最终通过collect()方法将结果收集到一个新的列表中\nList&lt;String&gt; filterNumbers = numbers.stream().filter(s -&gt; s.startWith(&quot;133&quot;)).collect(Collectors.toList());\nSystem.out.println(filterNumbers);\n\n打印结果：[13378520000, 13358520000]\n</code></pre>\n<hr>\n<h5 id=\"map映射转换元素\"><a class=\"markdownIt-Anchor\" href=\"#map映射转换元素\">#</a> map: 映射转换元素</h5>\n<blockquote>\n<p>map 方法用于对流中的每个元素进行映射操作，将其转换为另一个元素或者提取其中的信息，并返回一个新的流</p>\n</blockquote>\n<p>1.2.1 转换元素</p>\n<blockquote>\n<p>获取每个手机号的前七位子字符串</p>\n</blockquote>\n<pre><code class=\"language-Java\">List&lt;String&gt; numbers = Arrays.asList(&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13558520000&quot;);\n//通过stream()方法创建一个流，使用map()方法将每个字符串转换为截取前7位的字符，最后使用collect()方法将结果收集到一个新列表中\nList&lt;String&gt; filterdNumbers = numbers.stream().map(s -&gt; s.substring(0,7)).collect(Collectors.toList());\nSystem.out.println(filterdNumbers);\n\n\n打印结果：[1337852, 1327852, 1317852, 1355852]\n\n</code></pre>\n<hr>\n<p>1.2.2 提取元素信息</p>\n<blockquote>\n<p>获取每个对象的手机号</p>\n</blockquote>\n<pre><code class=\"language-Java\">List&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,&quot;13378520000&quot;),\n        new People(&quot;李二&quot;,&quot;13278520000&quot;),\n        new People(&quot;张四&quot;,&quot;13178520000&quot;)\n);\n//通过stream()方法创建一个流，使用map()方法提取每个用户的手机号，最后使用collect()方法将结果收集到一个新列表中\nList&lt;String&gt; tel = peopleList.stream().map(People::getTel).collect(Collectors.toList());\nSystem.out.println(tel);\n\n\n打印结果：[13378520000, 13278520000, 13178520000]\n</code></pre>\n<hr>\n<h5 id=\"flatmap将多个流合并为一个流\"><a class=\"markdownIt-Anchor\" href=\"#flatmap将多个流合并为一个流\">#</a> flatMap: 将多个流合并为一个流</h5>\n<p>1.3.1 实现多对多的映射</p>\n<blockquote>\n<p>将 A 组数据和 B 组数据一次进行相加</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;Integer&gt; listA = Arrays.asList(1,2,3);\nList&lt;Integer&gt; listB = Arrays.asList(4, 5, 6);\nList&lt;Integer&gt; list = listA.stream().flatMap(a -&gt; listB.stream().map(b -&gt; a +b)).collect(Collectors.toList());\nSystem.out.println(list);\n\n\n打印结果:  [5, 6, 7, 6, 7, 8, 7, 8, 9]\n</code></pre>\n<hr>\n<p>1.3.2 将多个列表合并成一个列表</p>\n<pre><code class=\"language-Java\">\nList&lt;List&lt;String&gt;&gt; listOfLists = Arrays.asList(\n        Arrays.asList(&quot;13378520000&quot;, &quot;13278520000&quot;),\n        Arrays.asList(&quot;13178520000&quot;, &quot;13558520000&quot;),\n        Arrays.asList(&quot;15138510000&quot;, &quot;15228310000&quot;)\n);\nList&lt;String&gt; flatMapList = listOfLists.stream().flatMap(Collection::stream).collect(Collectors.toList());\nSystem.out.println(flatMapList);\n\n\n打印结果：[13378520000, 13278520000, 13178520000, 13558520000, 15138510000, 15228310000]\n\n</code></pre>\n<hr>\n<h5 id=\"peek查看每个元素的信息但不改变流中元素的状态\"><a class=\"markdownIt-Anchor\" href=\"#peek查看每个元素的信息但不改变流中元素的状态\">#</a> peek: 查看每个元素的信息，但不改变流中元素的状态</h5>\n<pre><code class=\"language-Java\">\nList&lt;String&gt; telList = Arrays.asList(&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13558520000&quot;);\ntelList.stream().peek(t -&gt; System.out.println(t))\n        .map(t -&gt; t.substring(0,3))\n        .peek(t -&gt; System.out.println(t))\n        .collect(Collectors.toList());\n\n</code></pre>\n<hr>\n<p><strong>重点:</strong> peek VS map</p>\n<blockquote>\n<p>peek 操作一般用于 不想改变流中元素本身的类型或者只想元素的内部状态改变时<br>\n map 则用于改变流中元素本身，即从元素中派生出另一种类型的操作</p>\n</blockquote>\n<hr>\n<h5 id=\"maptoint-maptolong-maptodouble-flatmaptodouble-flatmaptoint-flatmaptolong\"><a class=\"markdownIt-Anchor\" href=\"#maptoint-maptolong-maptodouble-flatmaptodouble-flatmaptoint-flatmaptolong\">#</a> mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong</h5>\n<blockquote>\n<p>以上操作是 map 和 flatMap 的特别版，也就是针对特定的数据类型进行映射处理</p>\n<p>其对应方法如下：</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nIntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);\n \nLongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper); \n \nDoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);\n \nIntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);\n \nLongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);\n \nDoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);\n\n</code></pre>\n<hr>\n<h4 id=\"有状态stateful操作\"><a class=\"markdownIt-Anchor\" href=\"#有状态stateful操作\">#</a> 有状态 (Stateful) 操作</h4>\n<h5 id=\"distinct去除重复的元素\"><a class=\"markdownIt-Anchor\" href=\"#distinct去除重复的元素\">#</a> distinct: 去除重复的元素</h5>\n<blockquote>\n<p>distinct () 方法可以用来去除流中的重复元素，生成无重复的列表<br>\n需要注意的是：distinct 用于针对流元素去重操作时，需要确定流中的元素实现了 equals () 和 hasCode () 方法</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;String&gt; numbers = Arrays.asList(&quot;13378520000&quot;, &quot;15138510000&quot;,&quot;13178520000&quot;, &quot;15138510000&quot;);\nList&lt;String&gt; disNumbers = numbers.stream().distinct().collect(Collectors.toList());\nSystem.out.println(disNumbers);\t\t\n\n\n打印结果：[13378520000, 15138510000, 13178520000]\n\n</code></pre>\n<hr>\n<h5 id=\"15-sorted排序元素\"><a class=\"markdownIt-Anchor\" href=\"#15-sorted排序元素\">#</a> 1.5 sorted: 排序元素</h5>\n<blockquote>\n<p>sorted 方法用于对流中元素进行排序</p>\n</blockquote>\n<p>1.5.1 升序排序</p>\n<pre><code class=\"language-Java\">\nList&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,20),\n        new People(&quot;李二&quot;,30),\n        new People(&quot;张四&quot;,31)\n);\nList&lt;People&gt; newpeopleList=peopleList.stream().sorted(Comparator.comparing(People::getAge)).collect(Collectors.toList());\n//打印结果\nnewpeopleList.stream().forEach(System.out::println);\n\n\n打印结果：\nPeople&#123;name='王二', age=20&#125;\nPeople&#123;name='李二', age=30&#125;\nPeople&#123;name='张四', age=31&#125;\n\n</code></pre>\n<p>1.5.2 降序排序</p>\n<blockquote>\n<p>通过 reversed () 方法进行逆序排序</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,20),\n        new People(&quot;李二&quot;,30),\n        new People(&quot;张四&quot;,31)\n);\nList&lt;People&gt; newpeopleList = peopleList.stream().sorted(Comparator.comparing(People::getAge).reversed()).collect(Collectors.toList());\n//打印结果\nnewpeopleList.stream().forEach(System.out::println);\n\n打印结果：\nPeople&#123;name='张四', age=31&#125;\nPeople&#123;name='李二', age=30&#125;\nPeople&#123;name='王二', age=20&#125;\n\n</code></pre>\n<hr>\n<h5 id=\"17-limit和skip截取流中的部分元素\"><a class=\"markdownIt-Anchor\" href=\"#17-limit和skip截取流中的部分元素\">#</a> 1.7 limit 和 skip: 截取流中的部分元素</h5>\n<blockquote>\n<p>limit 返回一个包含前 n 个元素的新流<br>\n skip 返回一个丢弃前 n 个元素后剩余元素组成的新流</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nint[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;\nSystem.out.print(&quot;取数组前5个元素:&quot;);\nArrays.stream(arr).limit(5).forEach(n -&gt; System.out.print(n + &quot; &quot;)); // 输出结果为：1 2 3 4 5\n\nSystem.out.print(&quot;跳过前3个元素，取剩余数组元素:&quot;);\nArrays.stream(arr).skip(3).forEach(n -&gt; System.out.print(n + &quot; &quot;)); // 输出结果为：4 5 6 7 8 9 10\n\n</code></pre>\n<hr>\n<h3 id=\"终结操作terminal-operation\"><a class=\"markdownIt-Anchor\" href=\"#终结操作terminal-operation\">#</a> 终结操作 (Terminal Operation)</h3>\n<h4 id=\"短路short-circuiting操作\"><a class=\"markdownIt-Anchor\" href=\"#短路short-circuiting操作\">#</a> 短路 (Short-circuiting) 操作</h4>\n<ul>\n<li>anyMatch: Stream 中只要有一个元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean anyMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>allMatch: Stream 中全部元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean allMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>noneMatch: Stream 中没有一个元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean noneMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>findFirst: 用于返回满足条件的第一个元素 (凡是该元素是封装在 Optional 类中)</li>\n</ul>\n<blockquote>\n<p>Optional<T> findFirst();</p>\n</blockquote>\n<ul>\n<li>findAny: 返回流中的任意元素 (但是该元素也是封装在 Optional 类中)</li>\n</ul>\n<blockquote>\n<p>Optional<T> findAny();</p>\n</blockquote>\n<hr>\n<h4 id=\"非短路操作\"><a class=\"markdownIt-Anchor\" href=\"#非短路操作\">#</a> 非短路操作</h4>\n<h5 id=\"foreach\"><a class=\"markdownIt-Anchor\" href=\"#foreach\">#</a> forEach()</h5>\n<p>该方法接收一个 lambda 表达式，然后在 Stream 的每一个元素上执行该表达式</p>\n<blockquote>\n<p>void forEach(Consumer&lt;? super T&gt; action);</p>\n</blockquote>\n<hr>\n<h5 id=\"foreachordered\"><a class=\"markdownIt-Anchor\" href=\"#foreachordered\">#</a> forEachOrdered()</h5>\n<p>该方法接收一个 Lambda 表达式，然后按顺序在 Stream 中的每一个元素上执行该表达式</p>\n<blockquote>\n<p>void forEachOrdered(Consumer&lt;? super T&gt; action);</p>\n</blockquote>\n<p>该功能其实和 forEach 是很相似的，也是循环操作！那唯一的区别，就在于 forEachOrdered 是可以保证循环时元素是按原来的顺序逐个循环的！</p>\n<hr>\n<h5 id=\"toarray\"><a class=\"markdownIt-Anchor\" href=\"#toarray\">#</a> toArray()</h5>\n<p>返回包含此流元素的数组，当有参数时，</p>\n<blockquote>\n<p>Object [] toArray();</p>\n</blockquote>\n<blockquote>\n<p><A> A[] toArray(IntFunction&lt;A[]&gt; generator);</p>\n</blockquote>\n<p>举例：</p>\n<pre><code class=\"language-Java\">\n\nList&lt;String&gt; strList = Arrays.asList( &quot;Jhonny&quot;, &quot;David&quot;, &quot;Jack&quot;, &quot;Duke&quot;, &quot;Jill&quot;,&quot;Dany&quot;,&quot;Julia&quot;,&quot;Jenish&quot;,&quot;Divya&quot;);\n \nObject [] strAryNoArg = strList.stream().toArray();\nString [] strAry = strList.stream().toArray(String[]::new);\n\n</code></pre>\n",
            "tags": [
                "Java8"
            ]
        },
        {
            "id": "http://1405904364.github.io/2023/08/10/Java/Apache-poi/",
            "url": "http://1405904364.github.io/2023/08/10/Java/Apache-poi/",
            "title": "Apache-Poi",
            "date_published": "2023-08-10T08:29:50.063Z",
            "content_html": "<h1 id=\"apache-poi\"><a class=\"markdownIt-Anchor\" href=\"#apache-poi\">#</a> Apache-Poi</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wb2kuYXBhY2hlLm9yZy8=\">官网</span><br>\n<br/> <br/><br>\n<img data-src=\"/image/Java/project-header.png\" alt=\"官网\"></p>\n</blockquote>\n<hr>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h2>\n<h3 id=\"hssf-sxxf-sxssf的区别\"><a class=\"markdownIt-Anchor\" href=\"#hssf-sxxf-sxssf的区别\">#</a> HSSF SXXF SXSSF 的区别</h3>\n<blockquote>\n<ul>\n<li>HSSF:Excel97-2003 版本，扩展名为.xls。一个 sheet 最大行数 65536，最大列数 256。</li>\n<li>XSSF:Excel2007 版本开始，扩展名为.xlsx。一个 sheet 最大行数 1048576，最大列数 16384。</li>\n<li>SXSSF: 是在 XSSF 基础上，POI3.8 版本开始提供的支持低内存占用的操作方式，扩展名为.xlsx。</li>\n</ul>\n<p>HSSF 用于 Excel03 版本：</p>\n<pre><code>  缺点：最多只能处理65536行，否则会报异常，\n\n  优点：过程中写入缓存，不操作磁盘，最后一次性写入磁盘，速度快\n</code></pre>\n<p>XSSF 用于 Excel07 版本：</p>\n<pre><code>  缺点：写数据时速度非常慢，非常耗内存，也会发生内存溢出，如100万条数据\n  优点：可以写较大的数据量，如20万条数据\n</code></pre>\n<p>SXSSF 可以理解为 SXXF 超大量数据升级版：</p>\n<pre><code>  优点：可以写非常大量的数据库，如100万条甚至更多条，写数据速度快，占用更少的内存\n  注意：\n      - 过程中会产生临时文件，需要清理临时文件\n      - 默认由100条记录被保存在内存中，如果超出这数量，则最前面的数据被写入临时文件\n      - 如果想自定义内存中数据的数量，可以使用new SXSSFWorkbook（数量）\n</code></pre>\n</blockquote>\n<h3 id=\"其他常见名称含义\"><a class=\"markdownIt-Anchor\" href=\"#其他常见名称含义\">#</a> 其他常见名称含义</h3>\n<p><em>其他常见名称含义：</em></p>\n<ul>\n<li>XSSF (XML SpreadSheet Format) – Used to reading and writting Open Office XML (XLSX) format files.</li>\n<li>HSSF (Horrible SpreadSheet Format) – Use to read and write Microsoft Excel (XLS) format files.</li>\n<li>HWPF (Horrible Word Processor Format) – to read and write Microsoft Word 97 (DOC) format files.</li>\n<li>HSMF (Horrible Stupid Mail Format) – pure Java implementation for Microsoft Outlook MSG files</li>\n<li>HDGF (Horrible DiaGram Format) – One of the first pure Java implementation for Microsoft Visio binary files.</li>\n<li>HPSF (Horrible Property Set Format) – For reading “Document Summary” information from Microsoft Office files.</li>\n<li>HSLF (Horrible Slide Layout Format) – a pure Java implementation for Microsoft PowerPoint files.</li>\n<li>HPBF (Horrible PuBlisher Format) – Apache’s pure Java implementation for Microsoft Publisher files.</li>\n<li>DDF (Dreadful Drawing Format) – Apache POI package for decoding the Microsoft Office Drawing format.</li>\n</ul>\n<h2 id=\"使用\"><a class=\"markdownIt-Anchor\" href=\"#使用\">#</a> 使用</h2>\n<h3 id=\"步骤一导入依赖\"><a class=\"markdownIt-Anchor\" href=\"#步骤一导入依赖\">#</a> 步骤一：导入依赖</h3>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi&lt;/artifactId&gt;\n    &lt;version&gt;4.1.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;\n    &lt;version&gt;4.1.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n",
            "tags": [
                "Html"
            ]
        },
        {
            "id": "http://1405904364.github.io/2023/08/10/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
            "url": "http://1405904364.github.io/2023/08/10/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
            "title": "函数式编程",
            "date_published": "2023-08-10T08:29:50.061Z",
            "content_html": "<h1 id=\"函数式编程\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程\">#</a> 函数式编程</h1>\n<p>一种 语法优雅、简洁健壮、高并发、易于测试和调试 的编程方式，这就是函数式编程 (FP) 的意义所在。</p>\n<blockquote>\n<p>OO (Object oriented, 面向对象) 是抽象数据<br>\n FP (Function programming, 函数式编程) 是抽象行为</p>\n</blockquote>\n<p>两个关键概念:</p>\n<blockquote>\n<ul>\n<li>函数是第一等公民</li>\n<li>函数要满足以下约束\n<ul>\n<li>函数的返回值仅取决于传递给函数的输入参数</li>\n<li>函数的执行没有副作用</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"函数是一等公民\"><a class=\"markdownIt-Anchor\" href=\"#函数是一等公民\">#</a> 函数是一等公民</h3>\n<blockquote>\n<p>在函数式编程范式中，函数是语言的第一等公民。这意味着可以创建函数的 “实例”，对函数实例的变量引用，就像对字符串、Map 或者任何其他对象的引用一样。函数也可以作为参数传递给其他函数。</p>\n</blockquote>\n<blockquote>\n<p>在 Java 中，函数显然不是第一等公民，类 (Class) 才是。所以 Java 才引用 Lambda 表达式，这个语法糖从表现层让 Java 拥有了函数，让函数可以作为变量的引用、方法的参数等等。（为什么说是从表现层呢？因为实际上，在编译的时候，Java 编译器还是会把 Lambda 表达式编译成类。</p>\n</blockquote>\n<hr>\n<h3 id=\"纯函数\"><a class=\"markdownIt-Anchor\" href=\"#纯函数\">#</a> 纯函数</h3>\n<p>函数式编程中，有个纯函数 (Pure Function) 的概念，如果一个函数满足以下条件，才是纯函数：</p>\n<ul>\n<li>该函数的执行没有副作用</li>\n<li>函数的返回值仅取决于传递给函数的输入参数</li>\n</ul>\n<pre><code class=\"language-Java\">public class ObjectWithPureFunction&#123;\n    public int sum(int a, int b)&#123;\n        return a+b;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"非纯函数\"><a class=\"markdownIt-Anchor\" href=\"#非纯函数\">#</a> 非纯函数</h3>\n<p>上面的 sum 方法的返回值仅取决于其输入参数，而且 sum 是没有副作用的，它不会在任何地方修改函数之外的任何状态 (变量)</p>\n<p>相反，这个一个非纯函数的例子:</p>\n<pre><code class=\"language-Java\">public class ObjectWithNonPureFunction&#123;\n    private int value = 0;\n\n    public int add(int nextValue) &#123;\n        this.value += nextValue;\n        return this.value;\n    &#125;\n&#125;\n</code></pre>\n<p>add 方法使用成员变量 value 来计算返回值，并且它还修改了 value 成员变量，这代表它有副作用，这两个条件都导致 add 方法不是一个纯函数</p>\n<hr>\n<h2 id=\"函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口\">#</a> 函数式接口</h2>\n<p>所谓函数式接口，实际上就是接口里面有且只能有一个抽象方法的接口。</p>\n<p>函数式接口也称为 单一抽象方法 (SAM) 接口</p>\n<h3 id=\"函数式接口的特点\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口的特点\">#</a> 函数式接口的特点</h3>\n<ul>\n<li>接口有且仅有一个抽象方法，如接口 Comparator</li>\n<li>允许出现 java.lang.Object 中的 public 方法，如 equals</li>\n<li>允许定义静态非抽象方法</li>\n<li>允许定义默认 default 非抽象方法 (default 方法式 java8 开始出现的)</li>\n<li>FunctionInterface 注解不是必须的，如果一个接口符合 “函数式接口” 的定义，那么不加该注解也没有影响</li>\n</ul>\n<blockquote>\n<p>甚至可以说：函数式接口是专门为 lambda 表达式准备的，lambda 表达式是只实现接口中唯一抽象方法的匿名实现类</p>\n</blockquote>\n<h3 id=\"default关键字\"><a class=\"markdownIt-Anchor\" href=\"#default关键字\">#</a> default 关键字</h3>\n<p>在 java8 之前</p>\n<ul>\n<li>接口是不能有方法的实现，所有的方法必须是抽象方法</li>\n<li>实现接口就必须实现接口里面的所有方法</li>\n</ul>\n<blockquote>\n<p>这样导致：当一个接口有很多实现类的时候，修改这个接口，就必须修改所有的实现类。</p>\n</blockquote>\n<p>不过在 java8 中这个问题得到解决，这就是 default 方法</p>\n<ul>\n<li>default 方法可以有自己的默认实现，即有方法体</li>\n<li>接口实现类可以不去实现 default 方法，并且可以使用 default 方法</li>\n</ul>\n<h3 id=\"jdk中函数式接口的举例\"><a class=\"markdownIt-Anchor\" href=\"#jdk中函数式接口的举例\">#</a> JDK 中函数式接口的举例</h3>\n<ul>\n<li>java.lang.Runnable,</li>\n<li>java.util.Comparator,</li>\n<li>java.util.concurrent.Callable</li>\n<li>java.util.function 包下的接口，如 Consumer、Predicate、Supplier 等</li>\n</ul>\n<blockquote>\n<p>编译器会根据 Lambda 表达式的参数和返回值类型推断出其实现的抽象方法，进而推断出其实现的接口，如果一个接口有多个抽象方法，显然是没有办法用 Lambda 表达式实现该接口的</p>\n</blockquote>\n<h3 id=\"functioninterface-注解\"><a class=\"markdownIt-Anchor\" href=\"#functioninterface-注解\">#</a> @FunctionInterface 注解</h3>\n<p><strong>标注接口是一个函数式接口的注解</strong></p>\n<pre><code class=\"language-Java\">@FunctionalInterface // 标明接口为函数式接口\npublic interface MyInterface &#123;\n    public void run(); //抽象方法\n&#125;\n</code></pre>\n<p>一旦使用了该注解标注接口，Java 的编译器会强制检查该接口是否满足函数式接口的要求：“确实仅有一个抽象方法”，否则将会报错</p>\n<p>需要注意的是，及时不适用该注解，只要有一个接口满足函数式接口的要求，那它仍然是一个函数式接口，使用起来都一样。该注解只起到标记接口指示编译器对其进行检查的作用</p>\n<h3 id=\"java内置的函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#java内置的函数式接口\">#</a> Java 内置的函数式接口</h3>\n<p><strong>Function</strong></p>\n<p>Function 接口（全限定名：java.util.function.Function）是 Java 中最核心的函数式接口。 Function 接口表示一个接受单个参数并返回单个值的函数（方法）</p>\n<p><strong>Predicate</strong></p>\n<p>Predicate 接口 （全限定名：java.util.function.Predicate）表示一个接收单个参数，并返回布尔值 true 或 false 的函数</p>\n<p><strong>Supplier</strong></p>\n<p>Supplier 接口（java.util.function.Supplier），表示提供某种值的函数</p>\n<p><strong>Consume</strong></p>\n<p>Consumer 接口（java.util.function.Consume）表示一个函数，该函数接收一个参数，但是不返回任何值</p>\n<p><strong>Optional</strong></p>\n<p>Optional 接口并不是一个函数式接口，它常在 Stream 操作中出现，作为操作的返回值类型。</p>\n<p>Optional 接口是预防 NullPointerException 的好工具，它是一个简单的容器，其值可以是 null 或非 null。比如一个可能返回一个非空结果的方法，方法在有些情况下返回值，有些情况不满足返回条件返回空值，这种情况下使用 Optional 接口作为返回类型，比直接无值时返回 Null 要更安全</p>\n<hr>\n<h2 id=\"lambda表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda表达式\">#</a> Lambda 表达式</h2>\n<h3 id=\"双冒号语法\"><a class=\"markdownIt-Anchor\" href=\"#双冒号语法\">#</a> 双冒号语法</h3>\n<p>其实双冒号就是 lambda 表达式的简写。被用作方法的引用。使用 lambda 表达式会创建匿名方法，但是有时候会需要一个 lambda 表达式只调用一个已经存在的方法，在此才有了方法的引用</p>\n<ol>\n<li>静态方法的引用 (static method)</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Demo &#123;\n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//静态方法语法\tClassName::methodName\n\t\tlist.forEach(Demo::print);\n\t&#125;\n\t\n\tpublic static void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>对象实例方法的引用</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Demo &#123;\n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//静态方法语法\tClassName::methodName\n\t\tlist.forEach(new Demo()::print);\n\t&#125;\n\t\n\tpublic void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>对象的超类方法引用</li>\n</ol>\n<pre><code class=\"language-Java\">public class Example extends BaseExample&#123;\n \n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//对象的超类方法语法： super::methodName \n\t\tlist.forEach(super::print);\n\t&#125;\n&#125;\n \nclass BaseExample &#123;\n\tpublic void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>类构造器引用</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Example &#123;\n \n\t@Test\n\tpublic void test() &#123;\n\t\tInterfaceExample com =  Example::new;\n\t\tExample bean = com.create();\n        Example bean = com.create(&quot;STRING&quot;);\n\t\tSystem.out.println(bean);\n\t&#125;\n&#125;\n \ninterface InterfaceExample&#123;\n    //不带参数\n\tExample create();\n    //带参数\n    Example create(String str);\n&#125;\n</code></pre>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2023/08/10/hello-world/",
            "url": "http://1405904364.github.io/2023/08/10/hello-world/",
            "title": "Hello World",
            "date_published": "2023-08-10T03:59:27.411Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"markdownIt-Anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"markdownIt-Anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"markdownIt-Anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"markdownIt-Anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"markdownIt-Anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}