{
    "version": "https://jsonfeed.org/version/1",
    "title": "Live My Life",
    "description": "个人学习使用",
    "home_page_url": "http://1405904364.github.io",
    "items": [
        {
            "id": "http://1405904364.github.io/2024/02/18/%E8%87%AA%E6%8E%A7/%E6%96%87%E6%A1%A3/",
            "url": "http://1405904364.github.io/2024/02/18/%E8%87%AA%E6%8E%A7/%E6%96%87%E6%A1%A3/",
            "title": "自控",
            "date_published": "2024-02-18T08:13:45.179Z",
            "content_html": "<h2 id=\"数据类型\"><a class=\"markdownIt-Anchor\" href=\"#数据类型\">#</a> 数据类型</h2>\n",
            "tags": [
                "自控"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/",
            "title": "npm更换镜像",
            "date_published": "2024-02-18T08:13:45.171Z",
            "content_html": "<h2 id=\"20240130解决npm更换镜像无效问题\"><a class=\"markdownIt-Anchor\" href=\"#20240130解决npm更换镜像无效问题\">#</a> 20240130 解决 npm 更换镜像无效问题</h2>\n<p>最近公司 gitlab 服务器经常崩溃，需要重整代码，跑前端代码发现 npm install 一直是失败的情况，<br>\n<img data-src=\"/image/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE/20d507fe797343079e85234931964629.png\" alt=\"npm install失败\"><br>\n意思是证书失效了</p>\n<p>网上看了才知道，之前用的淘宝镜像源 (<span class=\"exturl\" data-url=\"aHR0cDovL3JlZ2lzdHJ5Lm5wbS50YW9iYW8ub3Jn\">http://registry.npm.taobao.org</span>) 失效了，所以不管安装什么都会报错</p>\n<p>重新设置 npm 镜像为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5ucG1taXJyb3IuY29t\"> https://registry.npmmirror.com</span><br>\nnpm config set registry <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5ucG1taXJyb3IuY29t\">https://registry.npmmirror.com</span></p>\n<p>设置好了之后，在项目以外的地方使用 npm install 命令没有问题，但是在项目中使用依旧报错，这里就需要使用命令查看一下 npm 的镜像了<br>\n npm config get registry</p>\n<p>结果得到的依旧是淘宝镜像源 (<span class=\"exturl\" data-url=\"aHR0cDovL3JlZ2lzdHJ5Lm5wbS50YW9iYW8ub3Jn\">http://registry.npm.taobao.org</span>)，为什么呢？</p>\n<p>因为在项目中有一个.npmrc 的文件，该文件的优先级比 npm 配置的镜像更高，进入到该文件可以看到<br>\n registry=<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5ucG0udGFvYmFvLm9yZy8=\">https://registry.npm.taobao.org/</span><br>\n<img data-src=\"/image/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240130150059.png\" alt=\".npmrc 淘宝镜像\"></p>\n<p>修改该文件的 registry 配置为<br>\n registry=<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5ucG1taXJyb3IuY29tLw==\">https://registry.npmmirror.com/</span><br>\n<img data-src=\"/image/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240130150204.png\" alt=\".npmrc mirror镜像\"></p>\n<p>这时再次执行 npm config get registry 就能看到镜像改为我们想要的镜像了<br>\n再次执行 npm install</p>\n",
            "tags": [
                "npm"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/JavaScript/Promise/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/JavaScript/Promise/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.171Z",
            "content_html": "<h1 id=\"promise\"><a class=\"markdownIt-Anchor\" href=\"#promise\">#</a> Promise</h1>\n<p>Promise 对象用于表示一个异步操作的最终完成或者失败</p>\n<p>本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样就不需要在一开始把回调函数作为参数传入这个函数中了</p>\n<p>案例 1：将回调函数作为参数传入</p>\n<pre><code>\n// 成功的回调函数\nfunction successCallback(result) &#123;\n  console.log(&quot;音频文件创建成功：&quot; + result);\n&#125;\n\n// 失败的回调函数\nfunction failureCallback(error) &#123;\n  console.log(&quot;音频文件创建失败：&quot; + error);\n&#125;\n\ncreateAudioFileAsync(audioSettings, successCallback, failureCallback)\n\n</code></pre>\n<p>案例 2： 使用 Promise，将回调函数绑定在 Pormise 上</p>\n<pre><code>\nconst promise = createAudioFileAsync(audioSettings);\npromise.then(successCallback, failureCallback);\n\n或者简写为：\n\ncreateAudioFileAsync(audioSettings).then(successCallback, failureCallback);\n\n</code></pre>\n<h2 id=\"约定\"><a class=\"markdownIt-Anchor\" href=\"#约定\">#</a> 约定：</h2>\n<p>不同于 “老式” 的传入回调，在使用 Promise 时，会有如下约定：</p>\n<pre><code>在本轮 “事件循环” 运行完成之前，回调函数是不会被调用的\n即使异步操作已经完成（成功或失败），在这之后通过then(). 添加的回调函数也会被调用\n通过多次调用then(). 可以添加多个回调函数，他们会按照插入顺序进行执行\n</code></pre>\n<h2 id=\"链式调用\"><a class=\"markdownIt-Anchor\" href=\"#链式调用\">#</a> 链式调用</h2>\n<pre><code>const promise2 = doSomething().then(successCallback, failureCallback);\n</code></pre>\n<p><strong>promise2</strong> 不仅表示<strong> doSomething ()<strong> 函数的完成，也代表了你传入的</strong> successCallback</strong> 或者<strong> failureCallback</strong> 的完成。这两个函数也可以返回一个 Promise 对象，从而形成另一个异步操作，这样的话，在 <strong>promise</strong> 上新增的回调函数会排在这个 Promise 对象后面</p>\n<p>案例：Promise 链式调用的样例</p>\n<pre><code>\nfunction fun3() &#123;\n    return new Promise((resolve) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            const str = 'console.log====fun3';\n            console.log(str)\n            resolve(str)\n        &#125;, 500)\n    &#125;)\n&#125;\n\nfunction fun() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            const str = 'console.log====fun';\n            console.log(str)\n            reject(str)\n            // resolve(str)\n        &#125;, 500)\n    &#125;)\n&#125;\n\nconst promise = fun()\nconst p1 = promise.then((suc) =&gt; &#123;\n    console.log('suc===', suc)\n    console.log('算是成功了')\n&#125;, (ero) =&gt; &#123;\n    console.log('ero===', ero)\n    console.log('失败了啊！')\n    // return '失败是成功之母'\n    // 注意下边的fun3()函数的调用方式，一种是作为普通函数调用，另一种是作为返回值调用，效果是不同的\n    // fun3()\n    return fun3()\n&#125;)\nconst p2 = p1.then((suc2) =&gt; &#123;\n    console.log('再让我成功一次', suc2)\n&#125;, (ero2) =&gt; &#123;\n    console.log('失去的下次一定全部拿回来', ero2)\n&#125;)\n\n</code></pre>\n<p>结果：</p>\n<pre><code>\nconsole.log====fun\nero=== console.log====fun\n失败了啊！\nconsole.log====fun3\n再让我成功一次 console.log====fun3\n\n</code></pre>\n<p>在上述代码中，<strong>promise</strong> 的失败回调函数中，也返回了一个 Promise 对象，从而形成了另一个异步操作。因此在 <strong>p1</strong> 上新增的回调函数会排在这个 Promise 对象的后面。— 也印证了上边的结论</p>\n<p><strong>基本上，每一个 Promise 都代表了链中另一个异步过程的完成</strong></p>\n<p>then 里的参数是可选的，catch (failureCallback) 是 then (null, failureCallback) 的缩略形式。</p>\n<p>** 注意：** 一定要有返回值，否则，callback 将无法获取上一个 Promise 的结果。(如果使用箭头函数，() =&gt; x 比 () =&gt; { return x; } 更简洁一些，但后一种保留 return 的写法才支持使用多个语句。）。</p>\n<h2 id=\"catch的后续链式操作\"><a class=\"markdownIt-Anchor\" href=\"#catch的后续链式操作\">#</a> Catch 的后续链式操作</h2>\n<p>通常，一遇到异常抛出，浏览器就会顺着 Promise 链寻找下一个 onRejected 失败回调函数或者由 .catch () 指定的回调函数。这和以下同步代码的工作原理（执行过程）非常相似。</p>\n<pre><code>\ntry &#123;\n  let result = syncDoSomething();\n  let newResult = syncDoSomethingElse(result);\n  let finalResult = syncDoThirdThing(newResult);\n  console.log(`Got the final result: $&#123;finalResult&#125;`);\n&#125; catch(error) &#123;\n  failureCallback(error);\n&#125;\n\n</code></pre>\n<h2 id=\"promise拒绝事件\"><a class=\"markdownIt-Anchor\" href=\"#promise拒绝事件\">#</a> Promise 拒绝事件</h2>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/HTML/1.%E7%AE%80%E4%BB%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/HTML/1.%E7%AE%80%E4%BB%8B/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.162Z",
            "content_html": "<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>HTML 是用来描述网页的一种语言<br>\n HTML 指的是超文本标记语言 (Hyper Text Markup Language)<br>\n HTML 不是编程语言，而是一种标记语言 (markup language)<br>\n 标记语言是一套标记标签<br>\n HTML 使用标记标签来描述网页</p>\n<p>HTML 文档 = 网页<br>\n HTML 文档<strong>描述网页</strong><br>\n HTML 文档 <strong>包含 HTML 标签</strong> 和纯文本<br>\n HTML 文档也被称为网页<br>\n Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释网页的内容</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/HTML/2.%E5%9F%BA%E7%A1%80/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/HTML/2.%E5%9F%BA%E7%A1%80/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.162Z",
            "content_html": "<h1 id=\"html基础\"><a class=\"markdownIt-Anchor\" href=\"#html基础\">#</a> HTML 基础</h1>\n<pre><code>&lt;html&gt;          定义HTML文档\n&lt;body&gt;          定义文档的主体\n&lt;h1&gt; to &lt;h6&gt;    定义 HTML 标题\n&lt;!-- ... --&gt;    定义注释\n</code></pre>\n<p>注意：对于<strong> HTML</strong> 无法在代码中添加额外的空格或换行来改变输出的效果。当显示页面时，浏览器会一处<strong>源代码中</strong>多余的空格和空行。所有连续的空格或空行都会被计算作一个空格。需要注意的是<strong> HTML</strong> 代码中所有连续的空行（换行）也会被显示为一个空格。</p>\n<h2 id=\"标题\"><a class=\"markdownIt-Anchor\" href=\"#标题\">#</a> 标题</h2>\n<pre><code>&lt;h1&gt; ~ &lt;h6&gt;\n块级元素，默认占一行\n确保该标签只用于标题，不是用于产生字体变化而是用\n</code></pre>\n<h2 id=\"水平线\"><a class=\"markdownIt-Anchor\" href=\"#水平线\">#</a> 水平线</h2>\n<pre><code>&lt;hr /&gt;\n在页面中创建水平线\n</code></pre>\n<h2 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\">#</a> 注释</h2>\n<!-- This is a comment -->\n<pre><code>可以将注释插入**HTML**代码中，这样可以提高其可读性\n</code></pre>\n<h2 id=\"段落\"><a class=\"markdownIt-Anchor\" href=\"#段落\">#</a> 段落</h2>\n<pre><code>&lt;p&gt;This is a pargraph&lt;/p&gt;\n块级元素，默认占一行\n</code></pre>\n<h2 id=\"样式\"><a class=\"markdownIt-Anchor\" href=\"#样式\">#</a> 样式</h2>\n<p>style 属性的作用：提供了一种改变所有 HTML 元素的样式通用方法。</p>\n<h2 id=\"格式化\"><a class=\"markdownIt-Anchor\" href=\"#格式化\">#</a> 格式化</h2>\n<p><strong>HTML</strong> 提供了很多可以供格式化输出的元素，比如粗体和斜体字等等。</p>\n<h2 id=\"注释-2\"><a class=\"markdownIt-Anchor\" href=\"#注释-2\">#</a> 注释</h2>\n<pre><code>&lt;!-- 在此处写注释 --&gt;\n浏览器不会显示注释\n</code></pre>\n<h2 id=\"条件注释\"><a class=\"markdownIt-Anchor\" href=\"#条件注释\">#</a> 条件注释</h2>\n<pre><code>&lt;!--[if IE 8]&gt;\n    ... some HTML here ...\n&lt;![endif]--&gt;\n</code></pre>\n<h2 id=\"软件程序标签\"><a class=\"markdownIt-Anchor\" href=\"#软件程序标签\">#</a> 软件程序标签</h2>\n<pre><code>各种HTML软件程序也能够生成HTML注释。\n&lt;!-- webbot boot --&gt; 标签会被包围在由 FrontPage 和 Expression Web创建的 HTML注释中\n作为一项规则，这些标签的存在，有助于对创建这些标签的软件的支持。\n</code></pre>\n<h2 id=\"颜色\"><a class=\"markdownIt-Anchor\" href=\"#颜色\">#</a> 颜色</h2>\n<p>颜色是由红色、绿色、蓝色混合而成</p>\n<pre><code>可以用十六进制符号来表示，也可以用RGB的值来组成\n每种颜色最小值是0（十六进制：#00）\n最大值是255（十六进制：#FF）\n</code></pre>\n<p>颜色名</p>\n<pre><code>大多数的浏览器都支持颜色名集合。\n\n提示：仅仅有 16 种颜色名被 W3C 的 HTML4.0 标准所支持。它们是：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow。\n\n如果需要使用其它的颜色，需要使用十六进制的颜色值。\n</code></pre>\n<h2 id=\"css\"><a class=\"markdownIt-Anchor\" href=\"#css\">#</a> CSS</h2>\n<p>外部样式表</p>\n<pre><code>    &lt;head&gt;\n        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;\n    &lt;/head&gt;\n</code></pre>\n<p>内部样式表</p>\n<pre><code>    &lt;head&gt;\n        &lt;style type=&quot;text/css&quot;&gt;\n            body&#123;\n                bagkground-color: red\n            &#125;\n        &lt;/style&gt;\n    &lt;/head&gt;\n</code></pre>\n<p>内联样式</p>\n<pre><code>    &lt;p style=&quot;color: red; margin-left: 20px&quot;&gt;\n        This is a paragraph\n    &lt;/p&gt;\n</code></pre>\n<h2 id=\"链接\"><a class=\"markdownIt-Anchor\" href=\"#链接\">#</a> 链接</h2>\n<p>创建超链接</p>\n<pre><code>    &lt;a href=&quot;url&quot;&gt;Link text&lt;/a&gt;\n</code></pre>\n<p>创建文档内的书签</p>\n<pre><code>    创建一个书签\n    &lt;a name=&quot;tips&quot;&gt;锚&lt;/a&gt;\n\n    创建一个指向锚的连接\n    &lt;a href=&quot;#tips&quot;&gt;又用的提示&lt;/a&gt;\n\n    也可以\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/HTML/Canvas%E6%A0%87%E7%AD%BE/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/HTML/Canvas%E6%A0%87%E7%AD%BE/",
            "title": "Canvas画布",
            "date_published": "2024-02-18T08:13:45.162Z",
            "content_html": "<p>HTML <canvas>标签通常用于通过脚本动态绘制图形</p>\n<h2 id=\"颜色-样式和阴影\"><a class=\"markdownIt-Anchor\" href=\"#颜色-样式和阴影\">#</a> 颜色、样式和阴影</h2>\n<h3 id=\"属性\"><a class=\"markdownIt-Anchor\" href=\"#属性\">#</a> 属性</h3>\n<ul>\n<li>fillStyle 设置或返回用于填充绘画的颜色、渐变或模式</li>\n</ul>\n<blockquote></blockquote>\n<p><strong>实例 1</strong></p>\n<pre><code class=\"language-Html\">\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;canvas id=&quot;myCanvas&quot; width=&quot;300&quot; height=&quot;150&quot; style=&quot;border:1px solid #d3d3d3;&quot;&gt;\nYour browser does not support the HTML5 canvas tag.&lt;/canvas&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n\n// 通过 id 获取canvas容器\nvar c=document.getElementById(&quot;myCanvas&quot;);\n// 设置2d\nvar ctx=c.getContext(&quot;2d&quot;);\n// 设置填充的颜色\nctx.fillStyle=&quot;#0000ff&quot;;\n// 设置颜色显示的矩形位置\nctx.fillRect(20,20,150,100);\n\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<p><strong>实例 2</strong></p>\n<ul>\n<li>strokeStyle 设置或返回用于笔触的颜色、渐变或模式</li>\n</ul>\n",
            "tags": [
                "Html"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/Vuex/%E4%BB%8B%E7%BB%8DVuex/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/Vuex/%E4%BB%8B%E7%BB%8DVuex/",
            "title": "Vuex介绍",
            "date_published": "2024-02-18T08:13:45.154Z",
            "content_html": "<h1 id=\"什么是vuex\"><a class=\"markdownIt-Anchor\" href=\"#什么是vuex\">#</a> 什么是 Vuex</h1>\n<p>Vuex 是一 i 个专门为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extensnio ，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n<h2 id=\"什么是状态管理模式\"><a class=\"markdownIt-Anchor\" href=\"#什么是状态管理模式\">#</a> 什么是 “状态管理模式”?</h2>\n<pre><code class=\"language-JavaScript\">\nnew Vue(&#123;\n  // state\n  data () &#123;\n    return &#123;\n      count: 0\n    &#125;\n  &#125;,\n  // view\n  template: `\n    &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;\n  `,\n  // actions\n  methods: &#123;\n    increment () &#123;\n      this.count++\n    &#125;\n  &#125;\n&#125;)\n\n</code></pre>\n<p>这个状态自管理应用包含一下几个部分：</p>\n<ul>\n<li>state，驱动应用的数据源</li>\n<li>view，以声明方式将 state 映射到视图</li>\n<li>actions，相应在 view 上的用户输入导致的状态变化</li>\n</ul>\n<p>以下表示 “单向数据流” 理念的简单示意图</p>\n<p><img data-src=\"./image/../../../image/%E5%89%8D%E7%AB%AF/Vuex/flow.png\" alt=\"图片\"></p>\n<p>但是，当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易遭到破坏：</p>\n<ul>\n<li>多个视图依赖于同一个状态</li>\n<li>来自不同视图的行为需要变更同一个状态</li>\n</ul>\n<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>\n<p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的 “视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p>\n<p>通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。</p>\n<p><img data-src=\"./image/../../../image/%E5%89%8D%E7%AB%AF/Vuex/vuex.png\" alt=\"图片\"></p>\n",
            "tags": [
                "Vuex"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/Vuex/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/Vuex/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/",
            "title": "Vuex核心概念",
            "date_published": "2024-02-18T08:13:45.154Z",
            "content_html": "",
            "tags": [
                "Vuex"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/3.%E9%A1%B9%E7%9B%AE/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/3.%E9%A1%B9%E7%9B%AE/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/",
            "title": "Vue项目踩坑经历",
            "date_published": "2024-02-18T08:13:45.146Z",
            "content_html": "<blockquote>\n<h3 id=\"vue前端获取数据做动态路由\"><a class=\"markdownIt-Anchor\" href=\"#vue前端获取数据做动态路由\">#</a> Vue 前端获取数据，做动态路由</h3>\n<p>数据结构符合 router 结构，path、name、meta 等属性，</p>\n<p>其中 path 不要以反斜杠 / 开头，会造成浏览器 url 错误</p>\n</blockquote>\n<blockquote>\n<h3 id=\"父级菜单权限未绑定导致前端菜单项缺失\"><a class=\"markdownIt-Anchor\" href=\"#父级菜单权限未绑定导致前端菜单项缺失\">#</a> 父级菜单权限未绑定，导致前端菜单项缺失</h3>\n<p>从子节点，递归向父节点查询，补全丢失的父节点数据</p>\n<p>（在项目中，有的子节点权限绑定完好，但是其父节点未绑定权限，导致前端菜单项缺失该菜单，所以需要递归，将其父节点至根节点数据补充完整）</p>\n</blockquote>\n<blockquote>\n<h3 id=\"动态路由后页面缓存失效\"><a class=\"markdownIt-Anchor\" href=\"#动态路由后页面缓存失效\">#</a> 动态路由后，页面缓存失效</h3>\n<p>组件 name 属性与缓存页面数据项对应不上</p>\n</blockquote>\n",
            "tags": [
                "Vue"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/2.Vue%E5%9F%BA%E7%A1%80/2.%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/2.Vue%E5%9F%BA%E7%A1%80/2.%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.146Z",
            "content_html": "<h1 id=\"模板语法\"><a class=\"markdownIt-Anchor\" href=\"#模板语法\">#</a> 模板语法</h1>\n<p>Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。<br>\n在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。</p>\n<h2 id=\"文本插值\"><a class=\"markdownIt-Anchor\" href=\"#文本插值\">#</a> 文本插值</h2>\n<p>最基本的数据绑定形式是文本插值，它使用的是 ”Mustache“ 语法（即双大括号）：</p>\n<pre><code>    &lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;\n</code></pre>\n<p>双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。</p>\n<h2 id=\"原始htmnl\"><a class=\"markdownIt-Anchor\" href=\"#原始htmnl\">#</a> 原始 HTMNL</h2>\n<p>双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令：</p>\n<pre><code>&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;\n&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n</code></pre>\n<p>Using text interpolation: <span style=\"color: red\">This should be red.</span></p>\n<p>Using v-html directive: This should be red.</p>\n<p>作用是：在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性保持同步。<br>\nspan 标签中的内容会被替换为 rawHTML 属性的值，插入的值为纯 HTML— 数据绑定将被忽略。</p>\n<p><strong>注意：不能使用 v-html 来拼接组合模板。</strong></p>\n<h2 id=\"attribute-绑定\"><a class=\"markdownIt-Anchor\" href=\"#attribute-绑定\">#</a> Attribute 绑定</h2>\n<p>双括号不能在 HTML attribute 中使用。想要响应式的绑定一个 attribute，应该使用 <strong>v-bind</strong> 指令。</p>\n<pre><code>  &lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>v-bind 指令 指示 Vue 将元素的 id attribute 与组件的 dynamicId 属性保持一致。如果绑定的值是 null 或者 undefined，那么该 attribute 将从渲染的元素上移除。</p>\n<h3 id=\"简写\"><a class=\"markdownIt-Anchor\" href=\"#简写\">#</a> 简写</h3>\n<p>因为 v-bind 非常常用，提供了特定的简写语法</p>\n<pre><code>   &lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id=\"布尔型-attribute\"><a class=\"markdownIt-Anchor\" href=\"#布尔型-attribute\">#</a> 布尔型 attribute</h3>\n<p>布尔型依据 true/false 值来决定 attribute 是否应该存在于元素上。disabled 就是最常见的例子之一。</p>\n<pre><code>    &lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;\n</code></pre>\n<p>当 <strong>isButtonDisabled</strong> 为真值，或者一个空字符串 (即 disabled=“”) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。</p>\n<h3 id=\"动态绑定多个值\"><a class=\"markdownIt-Anchor\" href=\"#动态绑定多个值\">#</a> 动态绑定多个值</h3>\n<p>如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：</p>\n<pre><code>    const objectOfAttrs = &#123;\n    id: 'container',\n    class: 'wrapper'\n    &#125;\n</code></pre>\n<p>通过不带参数的 v-bind，你可以将它们绑定到单个元素上：</p>\n<pre><code>    &lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id=\"使用-javascript-表达式\"><a class=\"markdownIt-Anchor\" href=\"#使用-javascript-表达式\">#</a> 使用 JavaScript 表达式</h3>\n<p>在 Vue 中，所有的数据绑定都支持完整的 JavaScript 表达式。</p>\n<p>例如</p>\n<pre><code>  &#123;&#123; number + 1 &#125;&#125;\n\n  &#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;\n\n  &#123;&#123; message.split('').reverse().join('') &#125;&#125;\n\n  &lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>这些表达式都会被作为 JavaScript，以当前组件实例为作用域解析执行。</p>\n<p>在 Vue 模板中，JavaScript 表达式可以使用在如下场景：</p>\n<ol>\n<li>在文本插值中（双大括号）。</li>\n<li>在任何 Vue 指令（以 v - 开头的特殊 attribute) attribute 的值中。</li>\n</ol>\n<h3 id=\"仅支持表达式\"><a class=\"markdownIt-Anchor\" href=\"#仅支持表达式\">#</a> 仅支持表达式</h3>\n<p>每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 return 后面。</p>\n<p>因此，下面的例子都是无效的：</p>\n<pre><code>    &lt;!-- 这是一个语句，而非表达式 --&gt;\n  &#123;&#123; var a = 1 &#125;&#125;\n\n  &lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;\n  &#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;\n</code></pre>\n<h3 id=\"调用函数\"><a class=\"markdownIt-Anchor\" href=\"#调用函数\">#</a> 调用函数</h3>\n<p>可以在绑定的表达式中使用一个组件暴露的方法。</p>\n<pre><code>  &lt;span :title=&quot;toTitleDate(date)&quot;&gt;\n    &#123;&#123; formatDate(date) &#125;&#125;\n  &lt;/span&gt;\n</code></pre>\n<h3 id=\"受限的全局访问\"><a class=\"markdownIt-Anchor\" href=\"#受限的全局访问\">#</a> 受限的全局访问</h3>\n<p>模板中的表达式将被沙盒化，仅能够访问到<strong>有限的全局对象列表</strong>。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。</p>\n<p>没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 app.config.globalProperties 上显式地添加它们，供所有的 Vue 表达式使用。</p>\n<h3 id=\"指令-directives\"><a class=\"markdownIt-Anchor\" href=\"#指令-directives\">#</a> 指令 Directives</h3>\n<p>指令是带有 v- 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 v-bind 和 v-html。</p>\n<p>指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。</p>\n<p>以 v-if 为例</p>\n<pre><code>  &lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;\n</code></pre>\n<h3 id=\"参数-arguments\"><a class=\"markdownIt-Anchor\" href=\"#参数-arguments\">#</a> 参数 arguments</h3>\n<p>某些指令会需要一个 “参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute：</p>\n<pre><code>  &lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;\n\n  &lt;!-- 简写 --&gt;\n  &lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>另一个例子是 v-on 指令，它将监听 DOM 事件：</p>\n<pre><code>  &lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n\n  &lt;!-- 简写 --&gt;\n  &lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<h3 id=\"动态参数\"><a class=\"markdownIt-Anchor\" href=\"#动态参数\">#</a> 动态参数</h3>\n<p>同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：</p>\n<pre><code>  &lt;!--\n  注意，参数表达式有一些约束，\n  参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释\n  --&gt;\n  &lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;\n\n  &lt;!-- 简写 --&gt;\n  &lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 “href”，那么这个绑定就等价于 v-bind:href。</p>\n<p>相似地，你还可以将一个函数绑定到动态的事件名称上：</p>\n<pre><code>  &lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n\n  &lt;!-- 简写 --&gt;\n  &lt;a @[eventName]=&quot;doSomething&quot;&gt;\n</code></pre>\n<h3 id=\"动态参数值的限制\"><a class=\"markdownIt-Anchor\" href=\"#动态参数值的限制\">#</a> 动态参数值的限制</h3>\n<p>动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。</p>\n<h3 id=\"动态参数语法的限制\"><a class=\"markdownIt-Anchor\" href=\"#动态参数语法的限制\">#</a> 动态参数语法的限制</h3>\n<p>动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：</p>\n<pre><code>  &lt;!-- 这会触发一个编译器警告 --&gt;\n  &lt;a :['foo' + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p><strong>如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式，</strong></p>\n<p>当使用 DOM 内嵌模板（直接写在 HTML 文件里的模板）时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：</p>\n<pre><code>  &lt;a :[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>上面例子将会在 DOM 内嵌模板中被转换为 ‘:[someattr]’ 。如果你的组件拥有属性 ‘someAttr’ 属性而非 ‘someattr’，那么这段代码将不会工作。单文件组件内的模板<strong>不受此限制</strong>。</p>\n<h3 id=\"修饰符-modifiers\"><a class=\"markdownIt-Anchor\" href=\"#修饰符-modifiers\">#</a> 修饰符 MOdifiers</h3>\n<p>修饰符是以点开头的特殊后缀，表明指令需要一些特殊方式被绑定。例如   ‘.prevent’ 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault ():</p>\n<pre><code>  &lt;form @submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/2.Vue%E5%9F%BA%E7%A1%80/3.%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/2.Vue%E5%9F%BA%E7%A1%80/3.%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.146Z",
            "content_html": "<h2 id=\"定义一个组件\"><a class=\"markdownIt-Anchor\" href=\"#定义一个组件\">#</a> 定义一个组件</h2>\n<pre><code>一般会将Vue组件定义在一个单独的.vue文件中，这叫做单文件组件（SFC）\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/2.Vue%E5%9F%BA%E7%A1%80/1.%E5%88%9B%E5%BB%BAVue%E5%BA%94%E7%94%A8/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/2.Vue%E5%9F%BA%E7%A1%80/1.%E5%88%9B%E5%BB%BAVue%E5%BA%94%E7%94%A8/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.137Z",
            "content_html": "<h2 id=\"应用实例\"><a class=\"markdownIt-Anchor\" href=\"#应用实例\">#</a> 应用实例</h2>\n<p>每个 Vue 应用都是通过 <strong>createApp</strong> 函数创建的一个新的 <strong>应用实例</strong></p>\n<pre><code>import &#123; createApp &#125; from 'vue'\n\nconst app = createApp(&#123;\n  /* 根组件选项 */\n&#125;)\n</code></pre>\n<h2 id=\"根组件\"><a class=\"markdownIt-Anchor\" href=\"#根组件\">#</a> 根组件</h2>\n<p>我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个 “根组件” ，其他组件将作为其子组件。</p>\n<pre><code>    import &#123; createApp &#125; from 'vue'\n    // 从一个单文件组件中导入根组件\n    import App from './App.vue'\n\n    const app = createApp(App)\n</code></pre>\n<h2 id=\"挂载应用\"><a class=\"markdownIt-Anchor\" href=\"#挂载应用\">#</a> 挂载应用</h2>\n<p>应用实例必须调用 mount () 方法才会渲染出来。该方法接受一个 “容器” 参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串。</p>\n<pre><code>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n    app.mount('#app')\n</code></pre>\n<p>应用根组件的内容会被渲染在容器元素<strong>里面</strong>，容器元素自己将<strong>不会</strong>被视为应用的一部分。</p>\n<p>mount () 方法应该始终在整个应用配置和资源注册完成之后被调用。</p>\n<p>同时需要注意的是：不同于其他资源注册方法，它的返回值是根实例而非应用实例。</p>\n<h2 id=\"应用配置\"><a class=\"markdownIt-Anchor\" href=\"#应用配置\">#</a> 应用配置</h2>\n<p>应用实例会暴露一个.config 对象允许我们配置一些应用级别的选项，例如定<br>\n义一个应用级别的错误处理器，用来捕捉所有子组件上的错误。</p>\n<pre><code>    app.config.errorHandler = (err) =&gt; &#123;\n    /* 处理错误 */\n    &#125;\n</code></pre>\n<p>应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件：</p>\n<pre><code>    app.component('TodoDeleteButton', TodoDeleteButton)\n</code></pre>\n<p><strong>确保在挂载应用实例之前完成所有应用配置！！！</strong></p>\n<h2 id=\"多个应用实例\"><a class=\"markdownIt-Anchor\" href=\"#多个应用实例\">#</a> 多个应用实例</h2>\n<p>应用实例不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。</p>\n<pre><code>    const app1 = createApp(&#123;\n    /* ... */\n    &#125;)\n    app1.mount('#container-1')\n\n    const app2 = createApp(&#123;\n    /* ... */\n    &#125;)\n    app2.mount('#container-2')\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/1.Vue%E7%AE%80%E4%BB%8B/Vue%E7%AE%80%E4%BB%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/1.Vue%E7%AE%80%E4%BB%8B/Vue%E7%AE%80%E4%BB%8B/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.137Z",
            "content_html": "<h1 id=\"vue简介\"><a class=\"markdownIt-Anchor\" href=\"#vue简介\">#</a> VUE 简介</h1>\n<p><em>注意：VUE2 将于 2023 年 12 月 31 日停止维护</em><br>\n Vue 是一款用于构建用户界面的 JavaScript 框架。</p>\n<p>基本实例：</p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n  &lt;button @click=&quot;count++&quot;&gt;\n    Count is: &#123;&#123; count &#125;&#125;\n  &lt;/button&gt;\n&lt;/div&gt;\n\nimport &#123; createApp &#125; from 'vue'\n\ncreateApp(&#123;\n  data() &#123;\n    return &#123;\n      count: 0\n    &#125;\n  &#125;\n&#125;).mount('#app')\ntemplate\n</code></pre>\n<p>展示出了 Vue 的两个核心功能：</p>\n<ol>\n<li>\n<p><strong>声明式渲染</strong>：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。</p>\n</li>\n<li>\n<p><strong>响应性</strong>：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。</p>\n</li>\n</ol>\n<h2 id=\"单文件组件\"><a class=\"markdownIt-Anchor\" href=\"#单文件组件\">#</a> 单文件组件</h2>\n<p>在大多数构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件（也被称为 *.vue 文件，英文名称：Single-File Components，缩写为 SFC）。Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件中。</p>\n<h2 id=\"api风格\"><a class=\"markdownIt-Anchor\" href=\"#api风格\">#</a> API 风格</h2>\n<p>Vue 的组件可以按照两种不同风格书写：<strong>选项式 API</strong> 和<strong>组合式 API</strong>。</p>\n<h3 id=\"选项式api\"><a class=\"markdownIt-Anchor\" href=\"#选项式api\">#</a> 选项式 API</h3>\n<p>使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods、和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。</p>\n<pre><code>    &lt;script&gt;\n    export default &#123;\n    // data() 返回的属性将会成为响应式的状态\n    // 并且暴露在 `this` 上\n    data() &#123;\n        return &#123;\n        count: 0\n        &#125;\n    &#125;,\n\n    // methods 是一些用来更改状态与触发更新的函数\n    // 它们可以在模板中作为事件监听器绑定\n    methods: &#123;\n        increment() &#123;\n        this.count++\n        &#125;\n    &#125;,\n\n    // 生命周期钩子会在组件生命周期的各个不同阶段被调用\n    // 例如这个函数就会在组件挂载完成后被调用\n    mounted() &#123;\n        console.log(`The initial count is $&#123;this.count&#125;.`)\n    &#125;\n    &#125;\n    &lt;/script&gt;\n\n    &lt;template&gt;\n    &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;\n    &lt;/template&gt;\n</code></pre>\n<h3 id=\"组合式api\"><a class=\"markdownIt-Anchor\" href=\"#组合式api\">#</a> 组合式 API</h3>\n<pre><code>通过组合式API，我们可以使用导入的API函数来描述组件逻辑。\n在单文件组件中，组合式 API 通常会与 &lt;script setup&gt; 搭配使用。\n这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。\n比如，&lt;script setup&gt; 中的导入和顶层变量/函数都能够在模板中直接使用。\n</code></pre>\n<pre><code>    &lt;script setup&gt;\n    import &#123; ref, onMounted &#125; from 'vue'\n\n    // 响应式状态\n    const count = ref(0)\n\n    // 用来修改状态、触发更新的函数\n    function increment() &#123;\n    count.value++\n    &#125;\n\n    // 生命周期钩子\n    onMounted(() =&gt; &#123;\n    console.log(`The initial count is $&#123;count.value&#125;.`)\n    &#125;)\n    &lt;/script&gt;\n\n    &lt;template&gt;\n    &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;\n    &lt;/template&gt;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/NodeJs/2.nvm%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/NodeJs/2.nvm%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.121Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/NodeJs/1.%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AENodeJs/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%89%8D%E7%AB%AF/NodeJs/1.%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AENodeJs/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.121Z",
            "content_html": "<h1 id=\"安装并配置nodejs\"><a class=\"markdownIt-Anchor\" href=\"#安装并配置nodejs\">#</a> 安装并配置 NodeJs</h1>\n<h3 id=\"第一步下载nodejs\"><a class=\"markdownIt-Anchor\" href=\"#第一步下载nodejs\">#</a> 第一步：下载 NodeJs</h3>\n<blockquote>\n<p>这是 nodejs 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2Vu\">官网</span><br>\n这个访问更快 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL3poLWNu\">中文官网</span></p>\n</blockquote>\n<p>官网提供了两个版本:</p>\n<ul>\n<li>LTS (Long Time Support)：即长期支持版本，重点在于稳定性和安全性。每个 LTS 版本的大版本号都是偶数，建议首次下载以及后续的每次升级都选择 LTS 版本，减少开发过程中出现的未知问题。</li>\n<li>Current 版本：即最新发布版本</li>\n</ul>\n<p>如何选择：</p>\n<blockquote>\n<p>使用 LTS 版本</p>\n</blockquote>\n<ul>\n<li>一般用于生产环境，重点在于稳定，如果你需要稳定性并拥有复杂的生产环境（例如中型或大型企业），建议使用 LTS 版本。</li>\n</ul>\n<blockquote>\n<p>使用 Current 版本</p>\n</blockquote>\n<ul>\n<li>一般用于测试环境，如果你是为了尝试新的版本和新特性（比如 ECMAScript 新特性），或者能够在不干扰环境的情况下快速轻松地升级版本，建议使用 Current 版本。</li>\n</ul>\n<p>注意：选择自己电脑系统的版本</p>\n<hr>\n<h3 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\">#</a> 安装：</h3>\n<p>点击安装包，一路 next (下一步) 即可</p>\n<p>先使用命令测试一下 nodejs 安装是否成功</p>\n<blockquote>\n<p>node -v</p>\n</blockquote>\n<p><img data-src=\"./img/%E6%B5%8B%E8%AF%95nodejs%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png\" alt=\"测试nodejs安装成功\"></p>\n<blockquote>\n<p>npm -v</p>\n</blockquote>\n<blockquote>\n<p><img data-src=\"./img/%E6%B5%8B%E8%AF%95npm.png\" alt=\"测试npm\"></p>\n</blockquote>\n<p>出现对应的版本号，则说明 node 已经按照完成了</p>\n<hr>\n<h3 id=\"配置\"><a class=\"markdownIt-Anchor\" href=\"#配置\">#</a> 配置：</h3>\n<p>到这里，node 已经安装完成了</p>\n<p>接下来就是配置 node 环境</p>\n<ol>\n<li>在 node 的安装目录下新建两个文件夹 【node_global】及【node_cache】</li>\n</ol>\n<p><img data-src=\"./img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230810143257.png\" alt=\"创建文件夹\"></p>\n<p>注意：因为我已经安装过了，node 的安装目录下可能有些其他我自己创建的的文件</p>\n<ol start=\"2\">\n<li>通过命令行配置</li>\n</ol>\n<blockquote>\n<p>npm config set prefix “[你电脑 node 的安装目录]\\node_global”<br>\nnpm config set cache “[你电脑 node 的安装目录]\\node_cache”</p>\n</blockquote>\n<ol start=\"3\">\n<li>配置环境变量 (必须)</li>\n</ol>\n<p>在用户环境变量的 Path 中<br>\n找到该配置<br>\n<img data-src=\"./img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230810143841.png\" alt=\"环境配置\"></p>\n<p>将其改为:<br>\n[你电脑 node 的安装目录]\\node_global</p>\n<p><strong>注意：如果不配置上边的环境变量，则安装在全局的依赖不能直接使用，造成如下结果：</strong><br>\n<img data-src=\"./img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230810150436.png\" alt=\"没有配置环境变量所导致\"></p>\n<hr>\n<p>参考文章: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdXNob3drbS9hcnRpY2xlL2RldGFpbHMvMTMwNTY2Mzkw\">npm 包全局安装和局部安装</span></p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/WebSocket/1.%E7%AE%80%E4%BB%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/WebSocket/1.%E7%AE%80%E4%BB%8B/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.112Z",
            "content_html": "<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h1>\n<pre><code>WebSocket协议在2008年诞生，2011年成为国际标准，所有游览器都已经支持了。\n</code></pre>\n<p>最大的特点就是，服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送消息，是真正的实现双平等对话，属于服务器推送数据技术的一种。</p>\n<ol>\n<li>节约带宽：不停的使用轮询服务端获取数据使用的是 http 协议，head 信息很大，有效数据占比低，而使用 webSocket 方式，head 信息很小，有效数据占比高</li>\n<li>无浪费：轮询 10 次，可能前 9 次都是白浪费，因为前 9 次可能没有拿到新数据，而 WebSocket 是由服务器主动发起的，来的都是新数据</li>\n<li>实时性：考虑到服务器压力，轮询的时间不能太长，否则服务器压力太大，所有轮询的时间都是间隔较长，比如 10 多秒进行一次轮询，而使用 webSocket，数据都是服务器主动推过来的，实时性很高</li>\n</ol>\n<p>其它特点有：<br>\n1. 建立在 TCP 协议之上，服务端实现比较容易。<br>\n2. 与 HTTP 协议有良好的兼容性，默认端口 80 和 443，并且握手阶段采用 HTTP 协议，因此不容易屏蔽，能通过各种 HTTP 代理服务器。<br>\n3. 数据格式比较轻量，性能开销较小，通信高效。<br>\n4. 可以发送二进制数据，也可以发送文本。<br>\n5. 没有同源限制，客户端可以与任意服务器通信。<br>\n6. 协议标识是：ws ，如果是加密，则为：wss ，服务器网址就是 URL。</p>\n<p>JavaScript 客户端</p>\n<pre><code>\n      const ws = new WebSocket('ws://127.0.0.1:8080/webSocketTest/ws/ucy')\n\n      ws.onopen = function (evt) &#123;\n        console.log(&quot;Connection open ...&quot;);\n        ws.send(&quot;Hello WebSockets!&quot;);\n      &#125;;\n\n      ws.onmessage = function (evt) &#123;\n        console.log(&quot;Received Message: &quot; + evt.data);\n        ws.close();\n      &#125;;\n      \n      ws.onclose = function (evt) &#123;\n        console.log(&quot;Connection closed.&quot;);\n      &#125;;\n\n</code></pre>\n<p>Java 服务端</p>\n<pre><code>\nimport org.springframework.messaging.Message;\nimport org.springframework.stereotype.Component;\n\nimport javax.websocket.CloseReason;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\n/**\n * @ClassName WebSocketEchoServer\n * @Description TODO\n * @Author JY\n * @Date 2023/4/24\n **/\n\n@Component\n@ServerEndpoint(&quot;/ws/&#123;username&#125;&quot;)\npublic class WebSocketEchoServer &#123;\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(&quot;username&quot;) String username) &#123;\n        System.out.println(&quot;username = &quot; + username + &quot; is online.&quot;);\n\n    &#125;\n\n    @OnClose\n    public void onClose(Session session, @PathParam(&quot;username&quot;) String username, CloseReason closeReason) &#123;\n        System.out.println(&quot;username = &quot; + username + &quot; is offline.&quot;);\n        System.out.println(&quot;Closing a WebSocket due to &quot; + closeReason.getReasonPhrase());\n    &#125;\n\n    // @OnMessage\n    // public String onMessage(String message, Session session) throws IOException &#123;\n    //     System.out.println(&quot;received message=&quot; + message);\n    //     return &quot;echo &quot; + message;\n    // &#125;\n\n    @OnMessage\n    public void onMessage(String message, Session session) throws IOException &#123;\n        System.out.println(&quot;received message=&quot; + message);\n        session.getBasicRemote().sendText(&quot;echo &quot; + message);\n    &#125;\n\n    @OnError\n    public void onError(Session session, Throwable throwable) &#123;\n        System.out.println(&quot;发生错误&quot;);\n        throwable.printStackTrace();\n    &#125;\n\n    public void boardCast(Message message) &#123;\n        // todo: 遍历所有的session，给所有session发送消息\n\n    &#125;\n\n&#125;\n\n\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/SqlServer/%E4%BB%8B%E7%BB%8D/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/SqlServer/%E4%BB%8B%E7%BB%8D/",
            "title": "SqlServer介绍",
            "date_published": "2024-02-18T08:13:45.104Z",
            "content_html": "<h1 id=\"microsoft-sql-server-介绍\"><a class=\"markdownIt-Anchor\" href=\"#microsoft-sql-server-介绍\">#</a> Microsoft SQL Server 介绍</h1>\n<p>Sql Server 是 Microsoft 开发的一个关系数据库管理系统（RDBMS）, 现在是世界上最常用的数据库。</p>\n<p>Sql Server 是一个高度可扩展的产品，可以从一个单一笔记本上运行的任何东西或以高倍云服务器网络，或在两者之间任何东西。</p>\n<p>Sql Server 1.0 在 1989 年发布，至今 Sql Server 已称为一个真正的企业信息化平台。Sql Server 2014 包括内置的商务智能工具，以及一系列的分析报告工具，可以创建数据库、备份、复制、安全性更好以及更多。</p>\n<h1 id=\"server-数据库系统\"><a class=\"markdownIt-Anchor\" href=\"#server-数据库系统\">#</a> Server 数据库系统</h1>\n<p>Sql Server 是一个作为服务器的数据库系统使用的，并非桌面系统，比如 MS Access。</p>\n<p>Sql Server 被设计为在中央服务器上运行（或服务器），使多个使用者可以同时访问相同的数据，用户通常通过应用程序访问数据库。</p>\n<h1 id=\"数据库管理工具\"><a class=\"markdownIt-Anchor\" href=\"#数据库管理工具\">#</a> 数据库管理工具</h1>\n<p>Sql Server 通过一些工具来管理数据库和编程任务。</p>\n<p>以下是一些典型的数据库管理和编程任务，包括：</p>\n<ul>\n<li>创建和维护数据库</li>\n<li>创建和维护表</li>\n<li>创建和维护其他数据库对象，如存储过程，视图等</li>\n<li>创建和维护和调度数据备份</li>\n<li>复制（例如，创建数据库副本）</li>\n<li>创建和维护用户，角色等</li>\n<li>优化任务</li>\n</ul>\n<h1 id=\"sql-server版本\"><a class=\"markdownIt-Anchor\" href=\"#sql-server版本\">#</a> Sql Server 版本</h1>\n<p>SQL Server 有很多版本。下面来看几个版本的新增功能：</p>\n<p><strong>SQL SERVER 2000</strong></p>\n<ul>\n<li>日志传送</li>\n<li>索引视图</li>\n</ul>\n<p><strong>SQL SERVER 2005</strong></p>\n<ul>\n<li>分区</li>\n<li>数据库镜像（只有 SQL Server 2005 Enterprise Edition SP1 和更高版本支持异步数据库镜 - 像。）</li>\n<li>联机索引</li>\n<li>数据库快照</li>\n<li>复制</li>\n<li>故障转移群集</li>\n<li>SQL SERVER 2008</li>\n<li>数据压缩</li>\n<li>资源调控器</li>\n<li>备份压缩</li>\n</ul>\n<p><strong>SQL SERVER 2008 R2</strong></p>\n<ul>\n<li>R2 标志表示这是 SQL Server 的一个中间版本，而不是一个主版本。此版本目前我的客户中，使用还是非常多，性能稳定，虽然新增功能比较少：</li>\n<li>新增数据中心版，最大支持 256 核</li>\n<li>Unicode 压缩</li>\n<li>(为 Unicode 存储提供一个简单的压缩方案，通过 Unicode 压缩，可以减少 Unicode 字符对空间的占用)</li>\n</ul>\n<p><strong>SQL SERVER 2012</strong></p>\n<ul>\n<li>AlwaysOn</li>\n<li>Columnstore</li>\n<li>索引增强的审计功能</li>\n<li>大数据支持</li>\n</ul>\n<p><strong>SQL SERVER 2014</strong></p>\n<p>这个版本的新特效特别多，和非常有用，可以多了解下：</p>\n<ul>\n<li>内存优化表</li>\n<li>备份加密</li>\n<li>针对基数估计的新设计</li>\n<li>AlwaysOn 增强功能</li>\n<li>延迟持续性 （将部分或所有事务指定为延迟持久事务，从而能够缩短延迟）</li>\n<li>分区切换和索引生成 (官网写得 Partition Switching and Indexing，感觉是有问题的，其实就是分区表的单个分区可以重建)</li>\n<li>列存储索引缓冲池扩展 就是使用 SSD 扩展缓冲池</li>\n<li>增量统计信息</li>\n<li>资源调控器增强功能（–之前只能控制 CPU 和内存，2014 开始可以控制 IO）</li>\n<li>DBCC CHECK 支持 maxdop 提示</li>\n</ul>\n<p><strong>SQL SERVER 2016</strong></p>\n<ul>\n<li>全程加密技术 (Always Encrypted)</li>\n<li>JSON 支持</li>\n<li>多 TempDB 数据库文件（以前也是支持的，在 2014 开始就在 error log 提示，2016 中，在安装时就可以设置。）</li>\n<li>Query Store （前几天去参加微软的培训还讲到的，挺不错的功能。可以帮助解决参数嗅探的问 - 题，数据库升级的时候也可以用到它）</li>\n<li>支持 R 语言</li>\n<li>Live Quer y St at ist ics（可以更清晰的看到执行计划的开销（水流式）</li>\n</ul>\n<p>172.22.1.36</p>\n",
            "tags": [
                "SqlServer"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/webService/%E7%AE%80%E4%BB%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/webService/%E7%AE%80%E4%BB%8B/",
            "title": "webService的使用",
            "date_published": "2024-02-18T08:13:45.104Z",
            "content_html": "<h1 id=\"什么是webservice\"><a class=\"markdownIt-Anchor\" href=\"#什么是webservice\">#</a> 什么是 webService</h1>\n<blockquote>\n<p>webService 也称为 web 服务，它是一种跨编程语言和操作系统平台的远程调用技术。<br>\nWebService 采用标准的 SOAP 协议传输 (SOAP Simple Object Access Protocol 简单对象访问协议)，soap 属于 w3c 标准，并且 soap 协议是基于 http 的应用层协议传输 xml 数据。WebService 采用 WSDL 作为描述语言，也就是 WebService 的使用说明书。并且 W3C 为 WebService 制定了一套传输数据类型，使用 xml 进行描述，即 XSD (XML Schema Datatypes), 任何语言写的 webService 接口在发送数据的时候都要转成 webService 标准的 XSD 发送。</p>\n</blockquote>\n<h1 id=\"webservice的三要素\"><a class=\"markdownIt-Anchor\" href=\"#webservice的三要素\">#</a> WebService 的三要素</h1>\n<h2 id=\"soap\"><a class=\"markdownIt-Anchor\" href=\"#soap\">#</a> SOAP</h2>\n<blockquote>\n<p>SOAP 也叫做简单对象访问协议，是一种简单的基于 xml 的协议，它使应用程序通过 HTTP 来交换数据，可以简单的理解为 SOAP = http + xml 。 SOAP 协议目前的主流版本为 SOAP1.1 和 SOAP1.2（SOAP1.2 是被纳入 w3c 标准后的版本）。SOAP 也不是 WebService 的专有协议，其他的应用程序也是用 SOAP 传输数据，例如：tr069 也是使用 SOAP 协议来传输数据</p>\n</blockquote>\n<p>区分 http 请求和 SOAP (http + xml) 请求:<br>\n<img data-src=\"/image/webService/20180320112817939.png\" alt=\"图片\"></p>\n<p>SOAP 协议格式</p>\n<ol>\n<li>必须有 Envelope 元素，此元素将整个 xml 文档表示为一条 SOAP 消息。</li>\n<li>可选 Header 元素，包含头部信息。</li>\n<li>必须有 Body 元素，包含所有的调用和响应信息。</li>\n<li>可选的 Fault 元素，提供有关在处理此消息所发生的错误信息。</li>\n</ol>\n<p>SOAP1.1 和 SOAP1.2 的区别</p>\n<p>相同点：<br>\n1. 请求方式都是采用 POST 方式<br>\n 2. 协议内容相同，都有 Envelope 和 Body 标签</p>\n<p>不同点：<br>\n1. 数据格式不同：content-type 不同<br>\n - SOAP1.1:text/xml;charset=utf-8<br>\n- SOAP1.2:application/soap+xml;charset=utf-8<br>\n2. 命名空间不同<br>\n - SOAP1.1：<span class=\"exturl\" data-url=\"aHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvc29hcC9lbnZlbG9wZS8=\">http://schemas.xmlsoap.org/soap/envelope/</span><br>\n- SOAP1.2：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53My5vcmcvMjAwMy8wNS9zb2FwLWVudmVsb3Bl\">http://www.w3.org/2003/05/soap-envelope</span></p>\n<h2 id=\"wsdl\"><a class=\"markdownIt-Anchor\" href=\"#wsdl\">#</a> WSDL</h2>\n<blockquote>\n<p>WSDL 是基于 XML 的用于描述 WebService 及其函数（方法）、参数和返回值。也就是说 wsdl 是对发布出来的服务中的方法和返回值以及参数的描述（也可以说是 WebService 的使用说明书）</p>\n</blockquote>\n<p>WSDL 文档结构：</p>\n<p>WSDL 文档主要包括的 5 个标签</p>\n<ol>\n<li><service>: 服务视图，WebService 的服务节点，它包括服务端点</li>\n<li><binding>: 为每个服务端点定义消息格式和协议细节</li>\n<li><portType>: 服务端点，描述 WebService 可执行的操作方法，以及相关消息，通过 binging 指向 protType</li>\n<li><message>: 定义一个操作（方法）的数据参数（可有多个参数）</li>\n<li><types>: 定义 WebService 使用的全部数据类型</li>\n</ol>\n<h2 id=\"uddi\"><a class=\"markdownIt-Anchor\" href=\"#uddi\">#</a> UDDI</h2>\n<blockquote>\n<p>UDDI 是一种目录服务，通过它，企业可注册并搜集 Web Service。企业将自己提供的 Web Service 注册在 UDDI，也可以使用别的企业在 UDDI 注册 Web Service 服务，从而达到资源共享。UDDI 旨在将全球的 Web Service 资源进行共享</p>\n</blockquote>\n<h2 id=\"webservice开发规范\"><a class=\"markdownIt-Anchor\" href=\"#webservice开发规范\">#</a> WebService 开发规范</h2>\n<h3 id=\"jax-ws\"><a class=\"markdownIt-Anchor\" href=\"#jax-ws\">#</a> JAX-WS</h3>\n<blockquote>\n<p>JAX-WS (Java API for XML-Based Web Service): 一个远程调用可以转换基于 XML 协议 (例如：SOAP 协议), 在使用 JAX-WS 过程中，开发者不需要使用任何代码来编写生成和处理 SAOP。JAX-WS 运行时会自动将这些 API 调用转换为 SOAP 协议的消息。</p>\n</blockquote>\n<blockquote>\n<p>在服务端，用户只需要通过 JAVA 语言定义远程调用所需要实现的接口 (SEI: Service EndPoit Interface), 并对其提供相关的实现，通过调用 JAX-WS 的服务来调用接口，这样就可以发布 Web Service 接口了</p>\n</blockquote>\n<blockquote>\n<p>在客户端，用户可以通过 JAX-WS 的 API 创建一个代理来（用本地代理对象替代远程的服务对象）实现远程服务端调用。</p>\n</blockquote>\n<p>从 Java5 开始就支持 JAX-WS2.0 版本，Java6 以后的版本支持 JAX-WS2.1 版本，Java1.7 支持 JAX-WS2.2 的版本。</p>\n<h3 id=\"jaxmsaaj\"><a class=\"markdownIt-Anchor\" href=\"#jaxmsaaj\">#</a> JAXM&amp;SAAJ</h3>\n<blockquote>\n<p>JAXM（Java API for XML Message）：主要定义了包含接收信息和发送信息所需要的 API，SAAJ (SOAP With Attachment API For Java) 是与 JAXM 搭配使用的 API，为构建 SOAP 和解析 SOAP 包提供了重要的支持，支持附件传输等。</p>\n</blockquote>\n<h3 id=\"jax-rs\"><a class=\"markdownIt-Anchor\" href=\"#jax-rs\">#</a> JAX-RS</h3>\n<blockquote>\n<p>JAX-RS 是 Java 针对 REST（Representtation state Transfer）风格制定的一套 Web 服务规范，由于该规范推出来的较晚，因此该规范（JAX-WS 的版本为 1.0）并未随 Java6 一起发行。</p>\n</blockquote>\n<h2 id=\"webservice应用场景\"><a class=\"markdownIt-Anchor\" href=\"#webservice应用场景\">#</a> WebService 应用场景</h2>\n<p>适用场景：<br>\n1. 用于软件集成和复用<br>\n 2. 用于接口服务，不考虑客户端类型，不考虑性能<br>\n 3. 服务端已经确定使用了 WebService，客户端只能选择 WebService 使用</p>\n<p>不适用场景：<br>\n1. 对性能要求比较高 (因为 WebService 是采用 http 发送 soap 协议的数据，该协议迭代了太多标签，导致数据跟多，因此性能也有所降低)<br>\n 2. 同构程序之间不建议使用</p>\n<h2 id=\"wsimport命令介绍\"><a class=\"markdownIt-Anchor\" href=\"#wsimport命令介绍\">#</a> wsimport 命令介绍</h2>\n<blockquote>\n<p>wsimport 命令是 jdk 自带的 webService 客户端工具，可以根据 wsdl 文档生成对应服务代理类（客户端调用类），当然不管服务端用什么语言写的，都可以生成调用 WebService 的客户端代码，服务端通过客户端调用 WebService。</p>\n</blockquote>\n<p>wsimport 命令常用参数为：</p>\n<ul>\n<li>-d &lt;目录&gt;: 指定放置生成的输出文件的位置</li>\n<li>-s &lt;目录&gt;: 指定放置生成的源文件的位置</li>\n<li>-p &lt;包名&gt;: 指定目标程序包</li>\n</ul>\n<p>例如：在 com-&gt;test 文件夹中生成源文件</p>\n<blockquote>\n<p>wsimport -p com.test -s . <span class=\"exturl\" data-url=\"aHR0cDovL3dlYlNlcnZpY2Uud2VieG1sLmNvbS5jbi9XZWJTZXJ2aWNlL01vYmlsZUNPZGVXUy5hc214P3dzZGw=\">http://webService.webxml.com.cn/WebService/MobileCOdeWS.asmx?wsdl</span></p>\n</blockquote>\n<p>注意：-s .  表示在 -p 指定的文件夹下生成源文件</p>\n<h2 id=\"发布jax-ws的web-service服务\"><a class=\"markdownIt-Anchor\" href=\"#发布jax-ws的web-service服务\">#</a> 发布 JAX-WS 的 Web Service 服务</h2>\n<ol>\n<li>创建 SEI 接口 (本质上就是 Java 接口)</li>\n</ol>\n<pre><code class=\"language-Java\">public interface WeatherInterface &#123;\n    public String querryWeather(String cityName);\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>创建接口实现类</li>\n</ol>\n<blockquote>\n<ol>\n<li>\n<p>@WebService 注解：表示该实现类是一个 Web Service 服务。</p>\n<ul>\n<li>\n<p>targetNamespace 属性：指定命名空间。</p>\n</li>\n<li>\n<p>name 属性：指定 portType 的名称。</p>\n</li>\n<li>\n<p>serviceName 属性：服务名称。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>@WebMethod 注解：定义公共方法。</p>\n<ul>\n<li>\n<p>operationName 属性：方法的名称。（也就是 WSDL 中的 operation 的名称）</p>\n</li>\n<li>\n<p>exclude 属性：如果设置为 true 表示该方法不是 Web Service 服务中的方法。反之则是 WebService 中的方法。默认也是 &gt; false。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>@WebResult 注解：定义返回值。</p>\n<ul>\n<li>name 属性：返回结果值的名称</li>\n</ul>\n</li>\n<li>\n<p>@WebParam 注解：定义参数。</p>\n<ul>\n<li>name 属性：指定参数的名称</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"language-Java\">\n@WebService(targetNamespace=&quot;http://service.cn_lc&quot;,name=&quot;WeatherWSSoap&quot;,portName=&quot;WeatherWSSoapPort&quot;,serviceName=&quot;WeatherWS&quot;\n)//只加这个注解就只能生成SAOP1.1的WSDL\n//@BindingType(SOAPBinding.SOAP12HTTP_BINDING)\npublic class WeatherInterfaceImpl implements WeatherInterface &#123;\n    @WebMethod(operationName=&quot;getWeather&quot;,exclude=false)\n    @Override\n    @WebResult(name=&quot;resultWeather&quot;)\n    public  String querryWeather(@WebParam(name=&quot;cityName&quot;)String cityName) &#123;\n        System.out.println(&quot;form client ...&quot; + cityName);\n        String weather = &quot;晴&quot;;\n        return weather;\n    &#125;\n&#125;\n\n</code></pre>\n<ol start=\"3\">\n<li>通过 EndPoint 发布 WebService 服务 (EndPoint 只能发布实现类，不能发布接口)</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class WeatherServer &#123;\n    public static void main(String[] args) &#123;\n        /*** 参数解释：* address：服务器地址* implementor:实现类*/\n        Endpoint.publish(&quot;http://127.0.0.1:12345/weather&quot;,new WeatherInterfaceImpl());\n        System.out.println(&quot;http://127.0.0.1:12345/weather?wsdl&quot;);\n        &#125;\n&#125;\n\n</code></pre>\n<p><img data-src=\"/image/webService/20180320145116683.png\" alt=\"图片\"><br>\n<img data-src=\"/image/webService/20180320145359572.png\" alt=\"图片\"></p>\n<h2 id=\"webservice的四种客户端调用方式\"><a class=\"markdownIt-Anchor\" href=\"#webservice的四种客户端调用方式\">#</a> WebService 的四种客户端调用方式</h2>\n<p>第一种：通过 wsimport 生成客户端方式调用<br>\n 1. 通过 wsimport 生成客户端代码<br>\n wsimport -p com.test jaxws -s <span class=\"exturl\" data-url=\"aHR0cDovLzEyNy4wLjAuMToxMjM0NS93ZWF0aGVyP3dzZGw=\">http://127.0.0.1:12345/weather?wsdl</span><br>\n2. 阅读使用说明书 WSDL，使用生成客户端代码调用服务端</p>\n<pre><code class=\"language-Java\">\npublic class WeatherClient &#123;\n    public static void main(String[] args) &#123;\n        //创建服务视图\n        WeatherWS weatherInterfaceImplService = new WeatherWS();\n        //通过服务视图对象获取服务实现类\n        WeatherWSSoap weatherInterfaceImpl = weatherInterfaceImplService.getPort(WeatherWSSoap.class);\n        //通过服务实现对象调用查询方法\n        System.out.println(weatherInterfaceImpl.getWeather(&quot;北京&quot;));\n    &#125;\n&#125;\n\n</code></pre>\n<p>采用 wsimport 生成客户端代码方式的特点：这种方式使用简单，但是一些关键的元素 (比如 wsdl 地址、命名空间、服务类名等都写死在生成的客户端代码中) 不方便维护</p>\n<hr>\n<p>第二种：通过 Service 编程调用方式<br>\n 1. 通过 wsimport 生成客户端代码<br>\n wsimport -p com.test jaxws -s <span class=\"exturl\" data-url=\"aHR0cDovLzEyNy4wLjAuMToxMjM0NS93ZWF0aGVyP3dzZGw=\">http://127.0.0.1:12345/weather?wsdl</span><br>\n2. 自己编写服务视图类，并通过该服务视图类来获取服务实现类实例</p>\n<pre><code class=\"language-Java\">\npublic class WeatherClient &#123;\n    public static void main(String[] args) &#123;\n        //创建WSDL的URL，注意不是服务地址\n        URL url = new URL(&quot;http://127.0.0.1:12345/weather?wsdl&quot;);\n        // 创建服务名称//namespaceURI:命名空间地址。//localPart：服务视图名。\n        QName qname = new QName(&quot;http://service.cn_lc&quot;, &quot;WeatherWS&quot;);\n        //创建服务视图//1.wsdlDocumentLocation - wsdl地址//2.serviceName - 服务名称\n        Service service = Service.create(url, qname);\n        WeatherWSSoap weatherWSSoap = service.getPort(WeatherWSSoap.class);\n        String result = weatherWSSoap.getWeather(&quot;成都&quot;);\n        System.out.println(result);\n    &#125;\n&#125;\n\n</code></pre>\n<hr>\n<p>第三种：通过 HttpURLConnection 调用方式<br>\n 1. 创建服务地址<br>\n 2. 打开一个通向服务地址的连接<br>\n 3. 设置参数（例如请求方式为 POST）<br>\n4. 组织 SOAP 数据发送数据<br>\n 5. 接收服务端相应，并打印</p>\n<pre><code class=\"language-Java\">\npublic class WeatherClient &#123;\n    public static void main(String[] args) throws IOException &#123;\n        //第一步：创建服务地址\n        URL url = new URL(&quot;http://127.0.0.1:54321/weather&quot;);\n        // 第二步：打开一个通向服务端地址的连接\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        //设置参数\n        connection.setRequestMethod(&quot;POST&quot;);\n        connection.setRequestProperty(&quot;content-type&quot;, &quot;text/xml;charset=utf-8&quot;);\n        //设置输入输出\n        connection.setDoOutput(true);\n        connection.setDoInput(true);\n        //准备SOAP数据，发送请求\n        String soapxml = getXML(&quot;成都&quot;);\n        OutputStream out = connection.getOutputStream();\n        OutputStreamWriter writer = new OutputStreamWriter(out, &quot;utf-8&quot;);\n        writer.write(soapxml);\n        writer.close();\n        out.close();\n        //第五步接收服务端响应并打印\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) &#123;\n            InputStream input = connection.getInputStream();\n            InputStreamReader reader = new InputStreamReader(input, &quot;utf-8&quot;);\n            BufferedReader buffered = new BufferedReader(reader);\n            String temp = null;\n            StringBuilder sb = new StringBuilder();\n            while ((temp = buffered.readLine()) != null) &#123;\n                sb.append(temp);\n            &#125;\n            buffered.close();\n            reader.close();\n            input.close();\n            System.out.println(sb.toString());\n        &#125;\n    &#125;\n\n    public static String getXML(String cityName) &#123;\n        return &quot;&lt;?xml version=\\&quot;1.0\\&quot; ?&gt;&quot; + &quot;&lt;S:Envelope xmlns:S=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot;&gt;&quot; + &quot;&lt;S:Body&gt;&quot; + &quot;&lt;ns2:getWeather xmlns:ns2=\\&quot;http://service.cn_lc\\&quot;&gt;&quot; + &quot;&lt;cityName&gt;&quot; + cityName + &quot;&lt;/cityName&gt;&quot; + &quot;&lt;/ns2:getWeather&gt;&quot; + &quot;&lt;/S:Body&gt;&quot; + &quot;&lt;/S:Envelope&gt;&quot;;\n    &#125;\n&#125;\n\n</code></pre>\n<hr>\n<p>第四种：通过 ajax 方式调用服务端</p>\n<pre><code class=\"language-Html\">\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;title&gt;查询天气&lt;/title&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;function querryWeather() &#123;\n            var xhr = new XMLHttpRequest(); xhr.open(&quot;post&quot;, &quot;http://127.0.0.1:12345/weather&quot;, true);\n            //设置数据类型\n            xhr.setRequestHeader(&quot;content-type&quot;, &quot;text/xml;charset=utf-8&quot;);\n            //设置回调函数\n            if (4 == xhr.readState &amp;&amp; 200 == xhr.status) &#123;\n                alert(xhr.responseText);\n            &#125;\n            //组织数据\n            var soapXml = &quot;&lt;?xml version=\\&quot;1.0\\&quot; ?&gt;&quot; + &quot;&lt;S:Envelope xmlns:S=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot;&gt;&quot; + &quot;&lt;S:Body&gt;&quot; + &quot;&lt;ns2:getWeather xmlns:ns2=\\&quot;http://service.cn_lc\\&quot;&gt;&quot; + &quot;&lt;cityName&gt;&quot; + document.getElementById(&quot;cityName&quot;).value + &quot;&lt;/cityName&gt;&quot; + &quot;&lt;/ns2:getWeather&gt;&quot; + &quot;&lt;/S:Body&gt;&quot; + &quot;&lt;/S:Envelope&gt;&quot;; alert(soapXml);\n            //发送数据\n            xhr.send(soapXml);\n        &#125;\n    &lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;center&gt;天气查询：&lt;input type=&quot;text&quot; id=&quot;cityName&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;查询&quot;\n            οnclick=&quot;javascript:querryWeather();&quot; /&gt;&lt;/center&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"cxf\"><a class=\"markdownIt-Anchor\" href=\"#cxf\">#</a> CXF</h2>\n<blockquote>\n<p>CXF 是一个开源的 WebService 框架，提供了很多完善的功能<br>\n CXF 支持的协议有 SOAP1.1/SOAP1.2,REST<br>\nCXF 支持的数据格式有 XML，JSON (仅在 REST 方式下支持，不再 SOAP 方式下支持，因为 SOAP 使 http+xml)</p>\n</blockquote>\n",
            "tags": [
                "webService"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Spring/SpringBoot/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Spring/SpringBoot/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.096Z",
            "content_html": "<h1 id=\"springboot-配置静态资源文件映射\"><a class=\"markdownIt-Anchor\" href=\"#springboot-配置静态资源文件映射\">#</a> SpringBoot 配置静态资源文件映射</h1>\n<h2 id=\"配置文件映射为项目路径下\"><a class=\"markdownIt-Anchor\" href=\"#配置文件映射为项目路径下\">#</a> 配置文件映射为项目路径下</h2>\n<h3 id=\"properties-文件配置方式\"><a class=\"markdownIt-Anchor\" href=\"#properties-文件配置方式\">#</a> .properties 文件配置方式</h3>\n<pre><code>spring.mvc.static-path-pattern=/static/images/**\nspring.web.resources.static-locations=classpath:/static\n\n图例：\n</code></pre>\n<h3 id=\"java代码配置方式\"><a class=\"markdownIt-Anchor\" href=\"#java代码配置方式\">#</a> java 代码配置方式</h3>\n<pre><code>\n    package org.example.config;\n\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\n    import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n    /**\n    * @ClassName WebConfig\n    * @Description TODO\n    * @Date 2023/2/28\n    **/\n\n    @Configuration\n    public class WebConfig implements WebMvcConfigurer &#123;\n\n        @Override\n        public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n            registry.addResourceHandler(&quot;/static/images/**&quot;).addResourceLocations(&quot;classpath:&quot; + &quot;/static&quot;);\n        &#125;\n    &#125;\n\n\n</code></pre>\n<h2 id=\"配置\"><a class=\"markdownIt-Anchor\" href=\"#配置\">#</a> 配置</h2>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Spring/SpringCloud/SpringCloud/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Spring/SpringCloud/SpringCloud/",
            "title": "SpringCloud",
            "date_published": "2024-02-18T08:13:45.096Z",
            "content_html": "<h1 id=\"springcloud简介\"><a class=\"markdownIt-Anchor\" href=\"#springcloud简介\">#</a> SpringCloud 简介</h1>\n<blockquote>\n<p>Spring Cloud 是一个基于 Spring Boot 实现的云应用开发工具，它为基于 JVM 的云应用开发中的配置管理、服务发现、断路由、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>\n</blockquote>\n<blockquote>\n<p>pring Cloud 中包含了 spring-cloud-config、spring-cloud-bus 等近 20 个子项目</p>\n</blockquote>\n<p>Spring Cloud 本身并不是一个拿来即可用的框架，他是一套微服务规范，共有两代实现</p>\n<blockquote>\n<ul>\n<li>Spring Cloud Netflix 是 Spring Cloud 的第一代实现，主要由 Eureka、Ribbon、Feign、Hystrix 等组件组成</li>\n<li>Spring Cloud Alibaba 是 Spring Cloud 的第二代实现，主要由 Nacos、Sentinel、Seata 等组件组成</li>\n</ul>\n</blockquote>\n<p>这里介绍的 Spring Cloud 特指 Spring Cloud 的第一代实现</p>\n<h2 id=\"spring-cloud常用组件\"><a class=\"markdownIt-Anchor\" href=\"#spring-cloud常用组件\">#</a> Spring Cloud 常用组件</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Spring Cloud 组件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Netflix Eureka</td>\n<td>Spring Cloud Netflix 中的服务治理组件，包含服务注册中心、服务注册与发现机制的实现。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Netflix Ribbon</td>\n<td>Spring Cloud  Netflix 中的服务调用和客户端负载均衡组件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Netflix Hystrix</td>\n<td>人称 “豪猪哥”，Spring Cloud Netflix 的容错管理组件，为服务中出现的延迟和故障提供强大的容错能力。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Netflix Feign</td>\n<td>基于 Ribbon 和 Hystrix 的声明式服务调用组件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Netflix Zuul</td>\n<td>Spring Cloud Netflix 中的网关组件，提供了智能路由、访问过滤等功能。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Gateway</td>\n<td>一个基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关框架，它使用 Filter 链的方式提供了网关的基本功能，例如安全、监控 / 指标和限流等。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Config</td>\n<td>Spring Cloud 的配置管理工具，支持使用 Git 存储配置内容，实现应用配置的外部化存储，并支持在客户端对配置进行刷新、加密、解密等操作。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Bus</td>\n<td>Spring Cloud 的事件和消息总线，主要用于在集群中传播事件或状态变化，以触发后续的处理，例如动态刷新配置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Stream</td>\n<td>Spring Cloud 的消息中间件组件，它集成了 Apache Kafka 和 RabbitMQ 等消息中间件，并通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件之间的隔离。通过向应用程序暴露统一的 Channel 通道，使得应用程序不需要再考虑各种不同的消息中间件实现，就能轻松地发送和接收消息。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Sleuth</td>\n<td>Spring Cloud 分布式链路跟踪组件，能够完美的整合 Twitter 的 Zipkin。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"spring-cloud-erueka\"><a class=\"markdownIt-Anchor\" href=\"#spring-cloud-erueka\">#</a> Spring Cloud Erueka</h1>\n<h2 id=\"eureka注册中心\"><a class=\"markdownIt-Anchor\" href=\"#eureka注册中心\">#</a> Eureka 注册中心</h2>\n<p>Eureka 采用 C/S 架构，它包括两大组件：</p>\n<ol>\n<li><strong>EurekaServer：服务端，注册中心</strong></li>\n</ol>\n<blockquote>\n<p>当微服务启动时，会将自己注册到 Eureka Server，Eureka Server 维护一个可用服务列表，存储所有注册到其中的可用的服务信息，这些信息可以在 Eureka Server 的管理界面中看到</p>\n</blockquote>\n<ul>\n<li>记录服务信息</li>\n<li>心跳监控</li>\n</ul>\n<ol start=\"2\">\n<li><strong>EurkaClient：客户端</strong>\n<ul>\n<li>Provider：服务提供者。\n<ul>\n<li>注册自己的信息到 EurekaServer。</li>\n<li>每隔 30 秒内想 EurekaServer 发送心跳</li>\n</ul>\n</li>\n<li>consumer：服务消费者。\n<ul>\n<li>根据服务名称从 EurekaServer 中拉去服务列表。</li>\n<li>基于服务列表做负载均衡，选中一个微服务后发起远程调用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注：“心跳” 指的是一段定时发送的自定义信息，让对方知道自己 “存活”，以确保连接的有效性。大部分 CS 架构的应用程序都采用了心跳机制，服务端和客户端都可以发心跳。通常情况下是客户端向服务器端发送心跳包，服务端用于判断客户端是否在线。</p>\n</blockquote>\n<h2 id=\"eureka服务注册与发现\"><a class=\"markdownIt-Anchor\" href=\"#eureka服务注册与发现\">#</a> Eureka 服务注册与发现</h2>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Spring/SpringCloud/1010305209-0.png\" alt=\"\"></p>\n<p>图 1：Eureka 原理图</p>\n<p>三个角色：</p>\n<ul>\n<li>服务注册中心 (Register Server): 它是一个 Erueka Server，用于提供服务注册和发现功能。</li>\n<li>服务提供者 (Provider Service): 它是一个 Erueka Client，用于提供服务，它将自己提供的服务注册到服务注册中心，以供服务消费者发现。</li>\n<li>服务消费者 (Consumer Service): 他是一个 Erueka Client，用于服务消费，它可以从服务注册中心获取服务列表，调用所需的服务。</li>\n</ul>\n<p>Eureka 实现服务注册与发现的流程如下：</p>\n<ol>\n<li>搭建一个 Eureka Server 作为服务注册中心；</li>\n<li>服务提供者 Eureka Client 启动时，会把当前服务器的信息以服务名（<span class=\"exturl\" data-url=\"aHR0cDovL3NwcmluZy5hcHBsaWNhdGlvbi5uYW1l\">spring.application.name</span>）的方式注册到服务注册中心；</li>\n<li>服务消费者 Eureka Client 启动时，也会向服务注册中心注册；</li>\n<li>服务消费者还会获取一份可用服务列表，该列表中包含了所有注册到服务注册中心的服务信息（包括服务提供者和自身的信息）；</li>\n<li>在获得了可用服务列表后，服务消费者通过 HTTP 或消息中间件远程调用服务提供者提供的服务。</li>\n</ol>\n<blockquote>\n<p>服务注册中心（Eureka Server）所扮演的角色十分重要，它是服务提供者和服务消费者之间的桥梁。服务提供者只有将自己的服务注册到服务注册中心才可能被服务消费者调用，而服务消费者也只有通过服务注册中心获取可用服务列表后，才能调用所需的服务。</p>\n</blockquote>\n",
            "tags": [
                "SpringCloud"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/RabbitMq/1.%E7%AE%80%E4%BB%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/RabbitMq/1.%E7%AE%80%E4%BB%8B/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.079Z",
            "content_html": "<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>RabbitMQ 采用 Erlang 语言实现 AMQP（Anvanced Message Queuing Protocol 高级消息队列协议）的消息中间件，起初用于金融系统，在分布式系统种存储转发消息。</p>\n<p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p>\n<p><img data-src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f862069e8a040808fb783cc4aaf0bd2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?\" alt=\"Mq总体架构图\"></p>\n<h1 id=\"消息中间件的作用\"><a class=\"markdownIt-Anchor\" href=\"#消息中间件的作用\">#</a> 消息中间件的作用</h1>\n<h2 id=\"解耦\"><a class=\"markdownIt-Anchor\" href=\"#解耦\">#</a> 解耦</h2>\n<pre><code>：假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可。\n\n![解耦](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e00b95a616b49998b59732fe65e5623~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n</code></pre>\n<h2 id=\"异步\"><a class=\"markdownIt-Anchor\" href=\"#异步\">#</a> 异步</h2>\n<pre><code>：一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。\n\n![异步](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc5d3a46a8ca4c25ac51e2903a7d3ba4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n</code></pre>\n<h2 id=\"削峰\"><a class=\"markdownIt-Anchor\" href=\"#削峰\">#</a> 削峰</h2>\n<pre><code>：这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃。\n\n![削峰](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17eaea6ddb05400bbb70955dff5b2241~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n</code></pre>\n<h2 id=\"顺序保证\"><a class=\"markdownIt-Anchor\" href=\"#顺序保证\">#</a> 顺序保证</h2>\n<pre><code>：在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。\n</code></pre>\n<h2 id=\"冗余存储\"><a class=\"markdownIt-Anchor\" href=\"#冗余存储\">#</a> 冗余（存储）</h2>\n<pre><code>：有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息已经被处理完成，从而确保你的数据被安全地保存直到你使用完毕。\n</code></pre>\n<h1 id=\"核心概念\"><a class=\"markdownIt-Anchor\" href=\"#核心概念\">#</a> 核心概念</h1>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/RabbitMq/3.%E4%BA%A4%E6%8D%A2%E5%99%A8%E7%B1%BB%E5%9E%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/RabbitMq/3.%E4%BA%A4%E6%8D%A2%E5%99%A8%E7%B1%BB%E5%9E%8B/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.079Z",
            "content_html": "<h1 id=\"交换类型\"><a class=\"markdownIt-Anchor\" href=\"#交换类型\">#</a> 交换类型</h1>\n<p>RabbitMQ 常用的交换器类型有 fanout、direct、topic、headers 这四种。</p>\n<h2 id=\"fanout交换器\"><a class=\"markdownIt-Anchor\" href=\"#fanout交换器\">#</a> fanout 交换器</h2>\n<pre><code>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。\n</code></pre>\n<h2 id=\"direct交换器\"><a class=\"markdownIt-Anchor\" href=\"#direct交换器\">#</a> direct 交换器</h2>\n<pre><code>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。\n\n比如发送一条消息，并在发送消息的时候设置路由键为“warning”，则消息会路由到Queue1和Queue2。\n如果在发送消息的时候设置路由键为“info”或者“debug”，消息只会路由到 Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。\ndirect 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。\n\n![direct交换器](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b109102e82745e2a337cd27ab91bdfd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n</code></pre>\n<h2 id=\"topic交换器\"><a class=\"markdownIt-Anchor\" href=\"#topic交换器\">#</a> topic 交换器</h2>\n<pre><code>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：\n\nRoutingKey 为一个点号.分隔的字符串（被点号.分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;\nBindingKey 和 RoutingKey 一样也是点号.分隔的字符串；\nBindingKey 中可以存在两种特殊字符串*和#，用于做模糊匹配，其中*用于匹配一个单词，#用于匹配多个单词(可以是零个)。\n\n![topic交换器](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6525404137b4203acc95aabb5d9fb3f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queuel 和 Queue2;\n\n\n路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；\n\n\n路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；\n\n\n路由键为 “java.rabbitmq.demo” 的消息只会路由到Queuel中；\n\n\n路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。\n</code></pre>\n<h2 id=\"headers不推荐交换器\"><a class=\"markdownIt-Anchor\" href=\"#headers不推荐交换器\">#</a> headers (不推荐) 交换器</h2>\n<pre><code>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)'对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/RabbitMq/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/RabbitMq/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.079Z",
            "content_html": "<h1 id=\"核心概念\"><a class=\"markdownIt-Anchor\" href=\"#核心概念\">#</a> 核心概念</h1>\n<h2 id=\"生产者-producer\"><a class=\"markdownIt-Anchor\" href=\"#生产者-producer\">#</a> 生产者 Producer</h2>\n<pre><code>生产消息，然后发布到MQ中。消息一般分为两部分：消息体和标签。\n\n消息体也可以称之为payload，在实际应用中，消息体一般为一个JSON格式字符串。\n消息标签用来表述这条消息，比如一个交换器的名称和一个路由键。\n\nRabbitMQ根据标签把消息发送给感兴趣的消费者当中。\n</code></pre>\n<h2 id=\"消费者-consumer\"><a class=\"markdownIt-Anchor\" href=\"#消费者-consumer\">#</a> 消费者 Consumer</h2>\n<pre><code>连接到RabbitMQ，并订阅到队列上，当消费者消费一条消息时，只是消费消息的消息体（payload）。在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体，也就不知道消息的生产者是谁，当然消费者也不需要知道。\n</code></pre>\n<h2 id=\"broker-消息中间件的服务节点\"><a class=\"markdownIt-Anchor\" href=\"#broker-消息中间件的服务节点\">#</a> Broker 消息中间件的服务节点</h2>\n<pre><code>对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个RabbitMQ服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。\n\n![Borker流程](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfee805a9c734185afe6e783a571da1d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n</code></pre>\n<h2 id=\"queue-队列\"><a class=\"markdownIt-Anchor\" href=\"#queue-队列\">#</a> Queue 队列</h2>\n<pre><code>RabbitMQ 的内部对象，用于存储消息\n\nRabbitMQ中消息都只能存储在队列中，这一点和Kafka这种消息中间件相反。Kafka将消息存储在  topic（主题）这个逻辑层面，而相对应的队列逻辑只是  topic 实际存储文件中的位移标识。RabbitMQ的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。\n</code></pre>\n<h2 id=\"exchange-交换器\"><a class=\"markdownIt-Anchor\" href=\"#exchange-交换器\">#</a> Exchange 交换器</h2>\n<pre><code>生产者将消息发送到Exchange（交换器），由交换器将消息路由到一个或者多个队列当中，如果路由不到或许会返还给生产者，或许直接丢弃。\n</code></pre>\n<h2 id=\"routingkey-路由键\"><a class=\"markdownIt-Anchor\" href=\"#routingkey-路由键\">#</a> RoutingKey 路由键</h2>\n<pre><code>生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个Routing Key需要与交换器类型和绑定键（BindingKey）联合使用才能最终生效。在交换器类型和绑定键（BindingKey）固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。\n</code></pre>\n<h2 id=\"binding-绑定\"><a class=\"markdownIt-Anchor\" href=\"#binding-绑定\">#</a> Binding 绑定</h2>\n<pre><code>RabbitMQ 中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键（BindingKey），这样RabbitMQ就知道如何正确地将消息路由到队列了。\n\n生产者将消息发送给交换器时，需要一个RoutingKey，当BindingKey和RoutingKey相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的BindingKey。BindingKey并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视BindingKey，而是将消息路由到所有绑定到该交换器的队列中。\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/9.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/9.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql分组查询",
            "date_published": "2024-02-18T08:13:45.079Z",
            "content_html": "<h2 id=\"分组查询\"><a class=\"markdownIt-Anchor\" href=\"#分组查询\">#</a> 分组查询</h2>\n<h3 id=\"sql语句各个关键字的执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#sql语句各个关键字的执行顺序\">#</a> SQL 语句各个关键字的执行顺序</h3>\n<pre><code>select\n    ...         5\nfrom\n    ...         1\nwhere\n    ...         2\ngroup by\n    ...         3\nhaving\n    ...         4\norder by\n    ...         6\n</code></pre>\n<p>执行顺序：<br>\n1. from<br>\n2. where<br>\n3. group by<br>\n4. having<br>\n5. select<br>\n6. order by</p>\n<h3 id=\"重点结论\"><a class=\"markdownIt-Anchor\" href=\"#重点结论\">#</a> 重点结论</h3>\n<pre><code>在一条select语句当中，如果有group by语句的话，select后面只能跟分组函数，以及参加分组的字段。其他的一律不能跟。（Mysql可以执行，但没有意义，Oracle数据库当中会报错）\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/8.%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E8%A1%8C%E6%95%B0/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/8.%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E8%A1%8C%E6%95%B0/",
            "title": "Mysql多行处理行数",
            "date_published": "2024-02-18T08:13:45.071Z",
            "content_html": "<h2 id=\"多行处理行数分组函数\"><a class=\"markdownIt-Anchor\" href=\"#多行处理行数分组函数\">#</a> 多行处理行数（分组函数）</h2>\n<p>特点：输入多行、最终输出一行</p>\n<h4 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意：</h4>\n<pre><code>分组函数在使用时必须先进行分组，然后才能使用。\n如果你没有对数据进行分组，整张表默认为一组\n</code></pre>\n<h3 id=\"count-计数\"><a class=\"markdownIt-Anchor\" href=\"#count-计数\">#</a> count 计数</h3>\n<p>计算员工数量总和<br>\n select count (name) from emp;</p>\n<h3 id=\"sum-求和\"><a class=\"markdownIt-Anchor\" href=\"#sum-求和\">#</a> sum 求和</h3>\n<p>计算工资合<br>\n select sum (sal) from emp;</p>\n<h3 id=\"avg-平均值\"><a class=\"markdownIt-Anchor\" href=\"#avg-平均值\">#</a> avg 平均值</h3>\n<p>计算平均工资<br>\n select avg (sal) from emp;</p>\n<h3 id=\"max-最大值\"><a class=\"markdownIt-Anchor\" href=\"#max-最大值\">#</a> max 最大值</h3>\n<p>找出最高工资<br>\n select max (sal) from emp;</p>\n<h3 id=\"min-最小值\"><a class=\"markdownIt-Anchor\" href=\"#min-最小值\">#</a> min 最小值</h3>\n<p>找出最低工资<br>\n select min (sal) from emp;</p>\n<h2 id=\"分组函数使用时需要注意的地方\"><a class=\"markdownIt-Anchor\" href=\"#分组函数使用时需要注意的地方\">#</a> 分组函数使用时，需要注意的地方</h2>\n<pre><code>1. 分组函数自动忽略 NULL, 不需要提前处理。\n 例如：求所有员工津贴/补助的总和。\n    select sum(comm) from emp;//不需要加where comm is not null条件。\n2. 分组函数count(*) 和 count(具体字段)的区别。\n   1. count(具体字段)：表示统计该字段下所有不为 NULL 的元素的总数。\n   2. count(*)：统计表中所有行数。\n3. 分组函数不能直接用在where子句中。\n 例如：找出比最低工资高的员工信息。\n select ename, sal from emp where sal &gt; min(sal);// 错误SQL语句\n4. 所有分组函数可以组合起来一起使用。\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/7.%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/7.%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/",
            "title": "Mysql单行处理函数",
            "date_published": "2024-02-18T08:13:45.062Z",
            "content_html": "<p>单行处理函数也叫做数据处理函数</p>\n<p>单行处理函数的特点：</p>\n<p>​\t一个输入对应一个输出</p>\n<p>和单行处理函数相对的是：</p>\n<p>​\t多行处理函数（特点：多个输入，对应一个输出）</p>\n<p>常见的单行处理函数</p>\n<ol>\n<li>\n<p>lower 转换小写</p>\n<p>select  lower(name)  from city;</p>\n</li>\n<li>\n<p>upper 转换大写</p>\n<p>select  upper(name)  from city;</p>\n</li>\n<li>\n<p>substr 取子串</p>\n<p>substr (被截取的字符串，起始下标，截取的长度)// 注意起始下标从 1 开始，没有 0</p>\n<p>select  substr(name, 1, length(name))  from city;</p>\n</li>\n<li>\n<p>concat 进行字符串拼接</p>\n<p>select concat(name, countrycode) from city;</p>\n</li>\n<li>\n<p>length 取长度</p>\n<p>select length(name) from city;</p>\n</li>\n<li>\n<p>trim 去除空格</p>\n<p>select * from city where name = trim (’   King   ');// 将查询条件中的前后空格去除</p>\n</li>\n<li>\n<p>round 四舍五入</p>\n<p>select 字段 from 表名；</p>\n<p>select name from city;</p>\n<p>select ‘abc’ from city;//select 后面直接跟 “字面量”/“字面值”</p>\n<p><strong>结论：select 后面可以跟某个表的字段名（可以等同看作变量名），也可以跟字面量 / 字面值（数据）</strong></p>\n<p>例如：</p>\n<p>select round (1276.567, 2) from city;// 保留二位小数 1276.57</p>\n<p>select round (1276.567, 1) from city;// 保留一位小数 1276.6</p>\n<p>select round (1276.567, 0) from city;// 保留整数 1277</p>\n<p>select round (1276.567, -1) from city;// 保留到十位 1270</p>\n<p>select round (1276.567, -2) from city;// 保留到百位 1280</p>\n</li>\n<li>\n<p>rand 生成随机数</p>\n<p>select rand() from city;</p>\n<p>例如：生成 100 以内的随机数</p>\n<p>select round(rand() * 100, 0) from city;</p>\n</li>\n<li>\n<p>ifnull 可以将 null 转换成一个具体值。</p>\n<p>ifnull 是空处理函数。专门处理空的。（因为在所有数据库中，只要有 null 参与的数学运算，最终结果都为 null）</p>\n<p>ifnull 函数语法：ifnull (数据，被当作那个值)</p>\n<p>如果 “数据” 为 null 的时候，把这个数据当作那个值</p>\n</li>\n<li>\n<p>case when … then … when … then … else … end</p>\n<p>例如：当员工的岗位为 MANAGER 的时候，工资上调 %10，当工作岗位是 SALESMAN 的时候，工资上调 %50，其他正常。</p>\n<p>（注意：不修改数据库，只是将查询结果显示为工资上调）</p>\n<p>select</p>\n<p>ename,</p>\n<p>job,</p>\n<p>sal as oldsal,</p>\n<p>(case when ‘MANAGER’ then sal*1.1 when ‘SALESMAN’ then sal**1.5 else sal end) as newsal</p>\n<p>from emp;</p>\n</li>\n<li>\n<p>format 数字格式化<br>\n format (数字，‘格式’)</p>\n<p>select ename, (sal, ‘$999,999’) from emp;</p>\n</li>\n<li>\n<p>str_to_date</p>\n<p>字符串转换为 date 类型</p>\n<p>str_to_date (‘日期字符串’, ‘日期格式’)</p>\n<p>Mysql 中日期格式：<br>\n% Y 年<br>\n % m 月<br>\n % d 日<br>\n % h 时<br>\n % i 分<br>\n % s 秒</p>\n<p>Java 中日期格式：<br>\nyyyy-MM-dd HH:mm:ss SSS</p>\n</li>\n<li>\n<p>date_format</p>\n</li>\n</ol>\n<p>从 date 类型转换为具有一定格式的字符串类型</p>\n<p>date_format (日期值，‘日期格式’)</p>\n<p>insert into test values(1, ‘zhangsan’, str_to_date(‘10:13:20 11-11-1999’, ‘%h:%i:%s %d-%m-%Y’));</p>\n<p>insert into test values (1, ‘zhangsan’, str_to_date (‘11-1999’, ‘% m-% Y’));//date 类型为年月日，插入的值不完整，所以报错</p>\n<p>insert into test values(1, ‘zhangsan’, str_to_date(‘11-1999’, ‘11-%m-%Y’));</p>\n<p>insert into test values(1, ‘zhangsan’, str_to_date(‘10-11-1999’, ‘10-%m-%Y’));</p>\n<p>insert into test values (1, ‘zhangsan’, str_to_date (‘10-11-1999’, ‘% d-% m-% Y’));// 正确</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/6.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/6.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/",
            "title": "Mysql综合案例",
            "date_published": "2024-02-18T08:13:45.062Z",
            "content_html": "<ol>\n<li>\n<p>找出工资在 1250 到 3000 之间的员工信息，要求按照薪资降序排列。</p>\n<p>select ename, sal</p>\n<p>​\tfrom emp</p>\n<p>​\twhere sal between 1250 and 3000</p>\n<p>order by sal desc;</p>\n</li>\n</ol>\n<p>以上语句的执行顺序：</p>\n<ol>\n<li>from</li>\n<li>where</li>\n<li>select</li>\n<li>order by (排序总是在最后执行的！！！)</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/",
            "title": "简单的查询语句",
            "date_published": "2024-02-18T08:13:45.054Z",
            "content_html": "<ol>\n<li>\n<p>查询一个字段</p>\n<p>select 字段名 from 表名；</p>\n<p>其中要注意：</p>\n<p>​\tselect 和 from 都是关键字。</p>\n<p>​\t字段名和表名都是标识符。</p>\n<p><strong>强调：对于 SQL 语句来说，是通用的。所有的 SQL 语句以 &quot;;&quot; 结尾。另外 SQL 语句不区分大小写，都行。</strong></p>\n</li>\n<li>\n<p>查询多个字段</p>\n<p>使用逗号隔开 &quot;,&quot;</p>\n<p>select deptno,dname from dept;</p>\n</li>\n<li>\n<p>查询所有字段</p>\n<ol>\n<li>\n<p>可以把每个字段都写上</p>\n</li>\n<li>\n<p>可以使用 *</p>\n<ol>\n<li>\n<p>效率低</p>\n</li>\n<li>\n<p>可读性差</p>\n<p>在实际开发中不建议。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>给查询的列起别名</p>\n<ol>\n<li>\n<p>使用 as 关键字起别名。</p>\n<p>select deptno, dname as deptname from dept;</p>\n</li>\n<li>\n<p>省略 as 关键字。</p>\n<p>select deptno, dname deptname from dept;</p>\n</li>\n<li>\n<p>起别名的时候，别名中有空格，怎么办？</p>\n<p>例如：</p>\n<p>select deptno, dname dept name from dept;</p>\n<p>DBMS 会进行 SQL 编译，检查出不符合 SQL 语法，编译报错。</p>\n<p>解决:</p>\n<p>​\tselect deptno, dname ‘dept name’ from dept;// 加单引号</p>\n<p>​\tselect deptno, dname “dept name” from dept;// 加双引号</p>\n<p><strong>注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准。双引号在 oracle 数据库中用不了。但是在 mysql 中可以使用。</strong></p>\n<p><strong>再次强调：数据库中的字符串都是采用单引号括起来。这是标准的，双引号不标准。</strong></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"二列参与数学运算\"><a class=\"markdownIt-Anchor\" href=\"#二列参与数学运算\">#</a> 二：列参与数学运算</h2>\n<ol>\n<li>\n<p>计算员工年薪？sal * 12</p>\n<p>select ename, sal * 12 from emp;// 结论：列可以参与数学运算</p>\n<p>select ename, sal * 12 as ‘年薪’ from emp;// 别名是中文，用单引号括起来。</p>\n</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql条件查询",
            "date_published": "2024-02-18T08:13:45.054Z",
            "content_html": "<h2 id=\"条件查询\"><a class=\"markdownIt-Anchor\" href=\"#条件查询\">#</a> 条件查询</h2>\n<p>什么是条件查询？</p>\n<p>不是将表中所有数据都查出来。是查询出来符合条件的。</p>\n<p>语法格式：</p>\n<p>​\tselect 字段 1，字段 2，字段 3 from 表名 where 条件；</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">=</span> 等于</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">&lt;></span>或<span class=\"token operator\">!=</span> 不等于</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">&lt;</span> 小于</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">&lt;=</span> 小于等于</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> 大于</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token operator\">>=</span> 大于等于</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">between</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token operator\">and</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> 两个值之间，等同于 <span class=\"token operator\">>=</span> <span class=\"token operator\">and</span> <span class=\"token operator\">&lt;=</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t注意：</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t在使用<span class=\"token operator\">between</span> <span class=\"token operator\">and</span> 时，必须要遵循左小右大。</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token operator\">between</span> <span class=\"token operator\">and</span> 是闭区间，包括两端的值。</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t例如： <span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename<span class=\"token punctuation\">,</span>sal <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> sal <span class=\"token operator\">between</span> <span class=\"token number\">2450</span> <span class=\"token operator\">and</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t错误写法：<span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename<span class=\"token punctuation\">,</span>sal <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> sal <span class=\"token operator\">between</span> <span class=\"token number\">3000</span> <span class=\"token operator\">and</span> <span class=\"token number\">2450</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token operator\">is</span> <span class=\"token boolean\">null</span> 为 <span class=\"token boolean\">null</span> （<span class=\"token operator\">is</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span> 不为空）</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>查询那些员工的津贴<span class=\"token operator\">/</span>补助为<span class=\"token boolean\">null</span>？</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>错误查询：<span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> comm <span class=\"token operator\">=</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>正确写法：<span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> comm <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token operator\">and</span> 并且</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>查询工作岗位是MANAGER并且工资大于<span class=\"token number\">2500</span>的员工信息？</pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename<span class=\"token punctuation\">,</span>job<span class=\"token punctuation\">,</span>sal <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'MANAGER'</span> <span class=\"token operator\">and</span> sal<span class=\"token operator\">></span><span class=\"token number\">2500</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token operator\">or</span> 或者</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>查询工作岗位是MANAGER或SALESMAN的员工信息？</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename<span class=\"token punctuation\">,</span>job<span class=\"token punctuation\">,</span>sal <span class=\"token keyword\">from</span> emo <span class=\"token keyword\">where</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'MANAGER'</span> <span class=\"token operator\">or</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'SALESMAN'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token operator\">in</span> 包含，相当于多个 <span class=\"token operator\">or</span> （<span class=\"token operator\">not</span> <span class=\"token operator\">in</span> 不在这个范围中）</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>注意：<span class=\"token operator\">in</span>不是一个区间。<span class=\"token operator\">in</span>后面跟的是具体的值。</pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token operator\">not</span> <span class=\"token operator\">not</span>可以取非，主要用在<span class=\"token operator\">is</span> 或 <span class=\"token operator\">in</span> 中</pre></td></tr><tr><td data-num=\"37\"></td><td><pre>相当于多个 <span class=\"token operator\">or</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token operator\">like</span> <span class=\"token operator\">like</span>称为模糊匹配查询，支持<span class=\"token operator\">%</span> 或下划线匹配</pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token operator\">%</span> 匹配任意个字符</pre></td></tr><tr><td data-num=\"41\"></td><td><pre>下划线，一个下划线只匹配一个字符</pre></td></tr><tr><td data-num=\"42\"></td><td><pre>找出名字中有下划线的</pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token keyword\">select</span> name <span class=\"token keyword\">from</span> t_student <span class=\"token keyword\">where</span> name <span class=\"token operator\">like</span> <span class=\"token string\">\"%\\_%\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 使用 \\ 转义字符</span></pre></td></tr></table></figure><p>注意： 在数据库中 null 不能使用等号进行衡量。需要使用 is null。因为数据库中的 null 代表什么也没有，它不是一个值，所以不能用等号衡量。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/5.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/5.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/",
            "title": "Mysql排序",
            "date_published": "2024-02-18T08:13:45.054Z",
            "content_html": "<ol>\n<li>\n<p>查询所有员工薪资，排序</p>\n<p>select ename,sal from emp order by sal;// 默认升序</p>\n<p>select ename,sal from emp order by sal asc;// 指定 ASC 升序</p>\n<p>select ename,sal from emp order by sal desc;// 指定 DESC 降序</p>\n</li>\n<li>\n<p>多个字段进行排序</p>\n<p>例如：查询员工名字和薪资，要求按照薪资升序，如果薪资相同，再按照名字升序排列。</p>\n<p>select ename, sal from emp order by sal asc, ename asc;</p>\n</li>\n<li>\n<p>根据字段位置进行排序</p>\n<p>例如：按照查询结果的第 2 列 sal 进行排序。</p>\n<p>select ename, sal from emp order by 2;</p>\n<p>注意：不建议在开发中这样写，因为不健壮。</p>\n<p>因为列的顺序很容易发生改变，列顺序修改之后，2 就废了。</p>\n<p><strong>排序采用 order by 子句，order by 后面跟上排序字段，排序可以放多个，多个可以采用逗号（,）间隔，order by 默认采用升序，如果存在 where 子句那么 order by 必须放到最后面。</strong></p>\n</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/",
            "title": "",
            "date_published": "2024-02-18T08:13:45.046Z",
            "content_html": "<pre><code class=\"language-Sql\">\ncreate\n    definer = sofmes_qpzz@`%` procedure calculateEqutRunTime(IN startDateTime varchar(20), IN endDateTime varchar(20),\n                                                             IN equtFk varchar(100))\nBEGIN\n    ## 20231027-jy\n    ## 计算【equipments设备表】中每个设备的运行时间，最后存入到【equipmentproperty设备属性表】中\n    ## 主要使用的表：eps_working_rec\n    # 属性记录id\n    declare proId int default 0;\n    # 设备运行时间(秒)\n    declare runTime int default 0;\n    declare num int default 0;\n    declare v_euptPk varchar(100);\n    declare v_equtName varchar(100);\n    declare paramEqutFk varchar(100);\n    # 游标结束标志\n    declare done int default 0;\n    # 创建游标\n    DECLARE cur CURSOR FOR (select EuptPK, EqutName from equipments);\n    # 指定游标循环结束时的返回值\n#     declare continue HANDLER for SQLSTATE '02000' set done = 1;\n    declare continue HANDLER FOR NOT FOUND set done = 1;\n    #打开游标\n    open cur;\n    # 开始循环游标里的数据\n    read_loop:\n    loop\n        # 根据游标当前指向的一条数据 插入到上面申明的局部变量中\n        fetch cur into v_euptPk, v_equtName;\n        # 判断游标的循环是否结束\n        if done = 1 then\n            begin\n                leave read_loop; # 跳出游标循环\n            end;\n        end if;\n        if equtFk is not null &amp;&amp; equtFk &lt;&gt; ''\n        then\n            set paramEqutFk = equtFk;\n        else\n            set paramEqutFk = v_euptPk;\n        end if;\n        if !(startDateTime is not null &amp;&amp; startDateTime &lt;&gt; '') &amp;&amp; !(endDateTime is not null &amp;&amp; endDateTime &lt;&gt; '')\n        then\n            # 获取设备运行时间\n            select sum(if(Time_Cum is null, 0, Time_Cum))\n            into runTime\n            from eps_working_rec\n            where eps_working_rec.EqutFK = + paramEqutFk\n              and Rec_Type = 1;\n        end if;\n        if (startDateTime is not null &amp;&amp; startDateTime &lt;&gt; '') &amp;&amp; (endDateTime is not null &amp;&amp; endDateTime &lt;&gt; '')\n        then\n            # 获取设备运行时间\n            select sum(if(Time_Cum is null, 0, Time_Cum))\n            into runTime\n            from eps_working_rec\n            where eps_working_rec.EqutFK = + paramEqutFk\n              and BeginTime &gt;= + startDateTime\n              and EndTime &lt;= + endDateTime\n              and Rec_Type = 1;\n        end if;\n        # 开始时间条件\n        if (startDateTime is not null &amp;&amp; startDateTime &lt;&gt; '') &amp;&amp; !(endDateTime is not null &amp;&amp; endDateTime &lt;&gt; '')\n        then\n            # 获取设备运行时间\n            select sum(if(Time_Cum is null, 0, Time_Cum))\n            into runTime\n            from eps_working_rec\n            where eps_working_rec.EqutFK = + paramEqutFk\n              and BeginTime &gt;= + startDateTime\n              and Rec_Type = 1;\n        end if;\n        # 结束时间条件\n        if !(startDateTime is not null &amp;&amp; startDateTime &lt;&gt; '') &amp;&amp; (endDateTime is not null &amp;&amp; endDateTime &lt;&gt; '')\n        then\n            # 获取设备运行时间\n            select sum(if(Time_Cum is null, 0, Time_Cum))\n            into runTime\n            from eps_working_rec\n            where eps_working_rec.EqutFK = + paramEqutFk\n              and EndTime &gt;= + endDateTime\n              and Rec_Type = 1;\n        end if;\n        select runTime;\n        # 运行时间大于0的设备，继续做操作\n        if runTime is not null &amp;&amp; runTime &gt; 0 then\n            begin\n                # 获取设备属性为 【运行时间】得记录\n                set proId = 0;\n                select if(count(ID) &gt; 0, ID, 0)\n                into proId\n                from equipmentproperty equtPro\n                where equtPro.EqutPropertyName = '运行时间'\n                  and equtPro.EqutFK = + paramEqutFk\n                limit 1;\n                # 设备属性中不存在运行时间记录，则插入数据，否则进行更新数据\n                if proId is null || proId = 0 then\n                    set num = num + 1;\n                    begin\n                        insert into equipmentproperty(equtpropertyname, equtfk, equtpropertyvalue, epvaluetype,\n                                                      equtpropertydesc,\n                                                      vuom)\n                        values ('运行时间', paramEqutFk, runTime, 'NumberType', '运行时间', '秒');\n                    end;\n                else\n                    set num = num + 1;\n                    begin\n                        update equipmentproperty\n                        set EqutPropertyValue = runTime\n                        where equipmentproperty.EqutFK = paramEqutFk\n                          and EqutPropertyName = '运行时间';\n                    end;\n                end if;\n            end;\n        end if;\n        if equtFk is not null &amp;&amp; equtFk &lt;&gt; ''\n        then\n            begin\n                # 参数 EqutFK不为空， 执行一次，就退出整个循环\n                leave read_loop;\n            end;\n        end if;\n#             有loop 就一定要有end loop\n    end loop;\n    # 关闭游标\n    close cur;\n\nEND;\n\n\n\n</code></pre>\n<h3 id=\"使用游标\"><a class=\"markdownIt-Anchor\" href=\"#使用游标\">#</a> 使用游标</h3>\n<p>声明游标</p>\n<blockquote>\n<p>DECLARE cur CURSOR FOR (select EuptPK, EqutName from equipments);</p>\n<ol>\n<li>游标的 sql 语句中，不能有动态参数。</li>\n<li>游标的声明，一定是在存储过程的变量声明处（前面不能存在任何变量的计算等操作）</li>\n<li>使用游标前需要 open [游标标识], 结束需要 close [游标标识]</li>\n<li>fetch cur into v_euptPk, v_equtName; 每执行一次该语句，游标都会指向下一行记录数据（相当于数组的下一项）</li>\n</ol>\n</blockquote>\n<p>注意：</p>\n<blockquote>\n<p>declare continue HANDLER FOR NOT FOUND set done = 1;</p>\n<p>此 sql 语句是为在游标循环结束后将标志位置为 1，但是如果使用了 select into 的语句，且返回数据为空，则会同样将标志位置 1，导致游标循环提前结束</p>\n</blockquote>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/3.%E7%90%86%E8%A7%A3Sql/%E7%90%86%E8%A7%A3Sql/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/3.%E7%90%86%E8%A7%A3Sql/%E7%90%86%E8%A7%A3Sql/",
            "title": "理解Sql",
            "date_published": "2024-02-18T08:13:45.046Z",
            "content_html": "<ol>\n<li>数据库当中最近基本的单元是表：table</li>\n</ol>\n<p>数据库当中是以表格的形式表示数据的。因为比较直观。</p>\n<p>任何一张表都有行和列：</p>\n<p>​\t行（row）：被称为数据 / 记录。</p>\n<p>​\t列（column）：被称为字段。</p>\n<p>每个字段都有：字段名，数据类型，约束等属性。</p>\n<ol start=\"2\">\n<li>\n<p>关于 SQL 语句的分类</p>\n<p>SQL 语句有很多，最好进行分门别类，这样更容易记忆。</p>\n<p>分为：</p>\n<ol>\n<li>\n<p>DQL：数据查询语言（凡是带 select 关键字的都是查询语句）</p>\n</li>\n<li>\n<p>DML：数据操作语言（凡是对表中的数据进行增删改查的都是 DML）</p>\n<ol>\n<li>\n<p>insert：增</p>\n</li>\n<li>\n<p>update：改</p>\n</li>\n<li>\n<p>delete：删</p>\n<p><strong>！！！主要操作表中的数据 data。</strong></p>\n</li>\n</ol>\n</li>\n<li>\n<p>DDL：数据定义语言（凡是带有 create，drop，alter 的都是 DDL），DDL 主要操作的是表结构。不是表中的数据。</p>\n<ol>\n<li>\n<p>alter：修改</p>\n</li>\n<li>\n<p>create：新建，等同于增</p>\n</li>\n<li>\n<p>drop：删除</p>\n<p><strong>！！！主要对表结构进行操作。</strong></p>\n</li>\n</ol>\n</li>\n<li>\n<p>TCL：事务控制语言。</p>\n<p>包括：</p>\n<ol>\n<li>事务提交：commit;</li>\n<li>事务回滚：rollback;</li>\n</ol>\n</li>\n<li>\n<p>DCL：是数据控制语言。</p>\n<p>例如：授权 grant，撤销权限 revoke…</p>\n</li>\n</ol>\n</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/23.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/23.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/",
            "title": "数据库范式",
            "date_published": "2024-02-18T08:13:45.038Z",
            "content_html": "<h1 id=\"数据库设计三范式\"><a class=\"markdownIt-Anchor\" href=\"#数据库设计三范式\">#</a> 数据库设计三范式</h1>\n<p>什么是数据库设计范式？<br>\n数据库表的设计依据。</p>\n<h2 id=\"第一范式\"><a class=\"markdownIt-Anchor\" href=\"#第一范式\">#</a> 第一范式</h2>\n<pre><code>要求任何一张表必须有主键，每一个字段原子性不可再分\n\n案例：\n学生编号    学生姓名    联系方式\n1001        张三        zs@gmail.com,135999999\n1002        李四        li@gmail.com,136999999\n1003        王五        ww@gmail.com,137999999\n\n以上表设计不满足第一范式--没有主键，联系方式可拆分\n\n修改：\n学生编号(pk)    学生姓名        邮箱                联系电话\n1001            张三        zs@gmail.com       135999999\n1002            李四        li@gmail.com       136999999\n1003            王五        ww@gmail.com       137999999\n</code></pre>\n<h2 id=\"第二范式\"><a class=\"markdownIt-Anchor\" href=\"#第二范式\">#</a> 第二范式</h2>\n<pre><code>建立在第一范式基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖\n\n案例：\n学生编号        学生姓名        教师编号        教师姓名\n1001            张三            001             王老师\n1002            李四            002             赵老师\n1002            李四            002             王老师\n1001            张三            001             赵老师\n\n以上表设计不满足第一范式--没有主键\n\n修改：\n学生编号    +    教师编号（pk）        学生姓名          教师姓名\n1001            001             张三               王老师\n1002            002             李四               赵老师\n1002            002             李四               王老师\n1001            001             张三               赵老师\n\n学生编号和教师编号连个字段做复合主键\n以上修改完之后表不满足第二范式--非主键字段，产生部分依赖(学生和教师关系产生多对多关系)\n    导致：数据冗余，空间浪费\n\n修改：\n学生编号    学生姓名\n1001        张三\n1002        李四\n\n教师编号    教师姓名\n001         王老师\n002         赵老师\n\n学生教师联合表\nid(pk)      学生编号(fk)   教师编号(fk)\n1            1001          001\n2            1002          001\n3            1001          002\n4            1002          002\n</code></pre>\n<h2 id=\"第三范式\"><a class=\"markdownIt-Anchor\" href=\"#第三范式\">#</a> 第三范式</h2>\n<pre><code>建立在第二范式基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖\n\n案例：\n学生编号（PK）        学生姓名        班级编号         班级名称\n1001                   张三            01             一班\n1002                   李四            02             二班\n1003                   王五            03             三班\n1004                   赵六            03             四班\n\n以上表的设计满足第一范式--有主键\n以上表的设计满足第二范式--主键是单一主键，不是复合主键，没有产生部分依赖（表中学生和班级是一对多关系）\n\n以上表不满足第三范式--传递性依赖（班级名称依赖班级编号，产生了传递依赖，不符合第三范式，产生了数据冗余）\n\n修改：\n班级表\n班级编号（pk）      班级名称\n01                  一班\n02                  二班\n...\n\n学生表\n学生编号（pk）      学生姓名        班级编号\n1001                张三            01\n...\n</code></pre>\n<p>作用：避免数据冗余，空间的浪费</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<pre><code>一对多：\n    一对多，两张表，多的表加外键\n\n多对多：\n    多对多，三张表，关系表两个外键\n\n一对一：\n    在一对一中，可能存在表字段太多，太庞大，需要拆分表\n    \n    案例：\n    id      login_name      login_pwd       real_name       email\n    1           admin       admin           张三            zs@gmail.com\n\n\n    修改：\n    登录信息表：\n    id      login_name      login_pwd\n    1       admin           admin\n\n    用户详细信息表：\n    id      real_name       email           login_id(fk+unique)\n    100        admin        zs@gmail.com        1\n\n    在一对一拆分表时，可以使用 外键+唯一性约束 设计表\n</code></pre>\n<h2 id=\"重点\"><a class=\"markdownIt-Anchor\" href=\"#重点\">#</a> 重点</h2>\n<pre><code>数据库设计三范式是理论上的。\n实践和理论有时候有偏差。\n最终的目的都是为了满足客户的需求，有的时候会拿数据冗余换速度。因为Sql中，表和表之间的连接次数过多，效率越低（笛卡尔积）\n有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的。\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/24.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/24.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/",
            "title": "主从同步机制",
            "date_published": "2024-02-18T08:13:45.038Z",
            "content_html": "<h1 id=\"主从同步机制\"><a class=\"markdownIt-Anchor\" href=\"#主从同步机制\">#</a> 主从同步机制</h1>\n<p>作用</p>\n<ul>\n<li>可以用作一种备份机制，相当于热备份</li>\n<li>可以用做读写分离，均衡数据库负载</li>\n</ul>\n<p>概述</p>\n<p>MySQL 主从复制也能够称为 MySQL 主从同步，它是构建数据库高可用集群架构的基础。它经过将一台主机的数据复制到其余一台或多台主机上，并从新应用 relay log 中的 SQL 语句来实现复制功能。MySQL 支持单向、双向、链式级联、异步复制，5.5 版本以后加入的半同步复制，5.6 版本以后的 GTID 复制，MySQL5.7 的多源复制、并行复制、loss-less 复制。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/",
            "title": "Mysql存储过程",
            "date_published": "2024-02-18T08:13:45.038Z",
            "content_html": "<h1 id=\"mysql存储过程\"><a class=\"markdownIt-Anchor\" href=\"#mysql存储过程\">#</a> Mysql 存储过程</h1>\n<p>存储过程是在数据库中定义一些 SQL 语句的集合，可以直接去调用这些存储过程来执行已经定义好的 SQL 语句。</p>\n<p>触发器和存储过程相似，都是嵌入到 MySql 中的一段程序。触发器是由事件来触发某个操作。当数据库执行这些事件时，就会激活触发器来执行相应的操作。</p>\n<p><strong>优点：</strong></p>\n<blockquote>\n<ul>\n<li>存储过程可封装，并隐藏复杂的商业逻辑。</li>\n<li>存储过程可以回传值，并可以接受参数。</li>\n<li>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li>\n<li>存储过程可以用在数据检验，强制实行商业逻辑等。</li>\n</ul>\n</blockquote>\n<p><strong>缺点：</strong></p>\n<blockquote>\n<ul>\n<li>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</li>\n<li>存储过程的性能调校与撰写，受限于各种数据库系统。</li>\n</ul>\n</blockquote>\n<h2 id=\"存储过程\"><a class=\"markdownIt-Anchor\" href=\"#存储过程\">#</a> 存储过程</h2>\n<p>数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。例如，为了确认学生能否毕业，需要同时查询学生档案、成绩表和从何表，此时就需要使用多条 SQL 语句来针对这几个数据表完成处理要求。存储过程就是这样一组为了完成特定功能的 SQL 语句的集合。</p>\n<p>使用存储过程的目的是将经常或复杂的工作预先使用 SQL 语句写好，并用一个指定的名称存储起来，这个过程经编译和优化由存储在数据库服务器中，因此成为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需要调用 “CALL 存储过程名字” 即可自动完成。</p>\n<p>常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。</p>\n<p>一个存储过程即一个可编程的函数，它可以在数据库中创建并保存，一般由 SQL 语句和一些特殊控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。</p>\n<pre><code>MySql5.0版本以前并不支持存储过程。\n</code></pre>\n<p>存储过程时数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以被调用，完成指定的功能操作。</p>\n<p>使用存储过程不仅可以提高数据的访问效率，同时也可以提高数据库使用的安全性。</p>\n<p>对于调用者来说，存储过程封装了 SQL 语句，调用者无需考虑逻辑功能的具体实现过程。只是简单调用即可，它可以被 Java 和 C# 等编程语言调用。</p>\n<h3 id=\"创建存储过程\"><a class=\"markdownIt-Anchor\" href=\"#创建存储过程\">#</a> 创建存储过程</h3>\n<p>创建存储过程使用 create procedure 语句，语法格式如下</p>\n<pre><code>create procedure &lt;过程名&gt; ([过程参数[,...]]) &lt;过程体&gt;\n</code></pre>\n<pre><code class=\"language-Sql\">\nCREATE\n    [DEFINER = &#123; user | CURRENT_USER &#125;]\n　PROCEDURE sp_name ([proc_parameter[,...]])\n    [characteristic ...] routine_body\n \nproc_parameter:\n    [ IN | OUT | INOUT ] param_name type\n \ncharacteristic:\n    COMMENT 'string'\n  | LANGUAGE SQL\n  | [NOT] DETERMINISTIC\n  | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;\n  | SQL SECURITY &#123; DEFINER | INVOKER &#125;\n \nroutine_body:\n　　Valid SQL routine statement\n \n[begin_label:] BEGIN\n　　[statement_list]\n　　　　……\nEND [end_label]\n\n</code></pre>\n<p><strong>Mysql 存储过程中的关键语法</strong></p>\n<p>声明语句结束符，可以自定义</p>\n<blockquote>\n<p>DELIMTER &amp;&amp;<br>\n 或<br>\n DELIMTER //</p>\n<p>在 Mysql 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符号，那么 MySQL 服务器在处理存储过程时，会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的额结束符，而不再去处理存储过程体后面的 SQL 语句，这样显然不行。为了解决以上问题，通常使用 <strong>DELIMITER</strong> 命令将结束命令修改为其他字符。</p>\n<p>语法说明如下：<br>\n'$$' 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个 “？” 或两个 “￥“ 等。<br>\n当使用 DELIMITER 命令时，应该避免使用反斜杠 &quot;&quot; 字符，因为它是 MySQL 的转义字符。</p>\n<p>在 MySQL 命令行客户端使用：<br>\nmysql&gt; DELIMITER ??<br>\n 执行该命令后，任何命令、语句或程序的结束标志就换为两个问号 &quot;??“了。<br>\n注意：DELIMITER 和分号 “;” 之间一定要有一个空格（使用分号”;&quot; 作为 MySQL 语句结束符）。</p>\n</blockquote>\n<p>声明存储过程</p>\n<blockquote>\n<p>create procedure demo_in_parameter(IN pin int)</p>\n</blockquote>\n<p>存储过程开始和结束符号</p>\n<blockquote>\n<p>BEGIN<br>\n…<br>\nEND</p>\n<p>过程体是存储过程的主体部分，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 <strong>BEGIN</strong> 开始，以关键字 <strong>END</strong> 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。</p>\n</blockquote>\n<p>变量赋值</p>\n<blockquote>\n<p>SET @pin=1</p>\n</blockquote>\n<p>变量定义</p>\n<blockquote>\n<p>declare l_int int unsigned default 400;</p>\n</blockquote>\n<p>创建 Mysql 存储过程</p>\n<blockquote>\n<p>create procedure 存储过程名 (参数)</p>\n</blockquote>\n<p>创建存储过程体</p>\n<blockquote>\n<p>create function 存储函数名 (参数)</p>\n</blockquote>\n<pre><code>默认情况下，存储过程和默认数据库相关联，如果想指定存储过程创建在某个特定的数据库下，那么在过程名前面加数据库名做前缀。\n</code></pre>\n<h3 id=\"存储过程的参数\"><a class=\"markdownIt-Anchor\" href=\"#存储过程的参数\">#</a> 存储过程的参数</h3>\n<p>其中，过程参数是存储过程的参数列表。MySQL 存储过程支持三种类型的参数，即输入参数，输出参数和输入 / 输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输出 / 输出参数既可以充当输入参数也可以充当输出参数。格式如下</p>\n<pre><code>[ IN | OUT | INOUT ] &lt;参出名&gt; &lt;类型&gt;\n</code></pre>\n<p>在创建存储过程时，必须具有 create routine 权限。</p>\n<p>例如：<br>\nmysql&gt; DELIMITER //<br>\nmysql&gt; CREATE PROCEDURE GetScoreByStu<br>\n-&gt; (IN name VARCHAR(30))<br>\n-&gt; BEGIN<br>\n-&gt; SELECT student_score FROM tb_students_score<br>\n-&gt; WHERE student_name=name;<br>\n-&gt; END //<br>\nQuery OK, 0 rows affected (0.01 sec)</p>\n<h2 id=\"12-查看存储过程\"><a class=\"markdownIt-Anchor\" href=\"#12-查看存储过程\">#</a> 1.2 查看存储过程</h2>\n<pre><code>SHOW PROCEDURE STATUS LIKE 存储过程名;\n</code></pre>\n<p>也可以查看存储过程的定义，语法格式如下</p>\n<pre><code>SHOW CREATE PROCEDURE 存储过程名\n</code></pre>\n<h2 id=\"13修改存储过程\"><a class=\"markdownIt-Anchor\" href=\"#13修改存储过程\">#</a> 1.3 修改存储过程</h2>\n<h2 id=\"14-执行sql语句\"><a class=\"markdownIt-Anchor\" href=\"#14-执行sql语句\">#</a> 1.4 执行 Sql 语句</h2>\n<pre><code class=\"language-Sql\">\nPREPARE statement_name FROM sql_statement -- 使用 PREPARE 语句准备要执行的SQL语句，statement_name 是语句的名称， sql_statement 是要执行的SQL语句。\n\nEXECUTE statement_name USING @variable_name -- 使用 EXECUTE 语句执行准备好的SQL语句，statement_name 是语句的名称， @variable_name 是要传递给SQL语句的参数。\n\nDEALLOCATE PREPARE statement_name -- 使用 DEALLOCATE PREPARE 语句释放已准备的SQL语句，statement_name 是要释放的语句的名称。\n\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/21.%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/21.%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/",
            "title": "视图",
            "date_published": "2024-02-18T08:13:45.029Z",
            "content_html": "<h1 id=\"视图\"><a class=\"markdownIt-Anchor\" href=\"#视图\">#</a> 视图</h1>\n<p>什么是视图？<br>\nview：站在不同的角度，去看待同一份数据</p>\n<h2 id=\"创建视图\"><a class=\"markdownIt-Anchor\" href=\"#创建视图\">#</a> 创建视图</h2>\n<pre><code>create view 视图名 as DQL语句;\n\ncreate view emp_view as select * from emp;\n</code></pre>\n<p>注意：只有 DQL 语句才能以 view 的形式创建</p>\n<h2 id=\"删除视图\"><a class=\"markdownIt-Anchor\" href=\"#删除视图\">#</a> 删除视图</h2>\n<pre><code>drop view emp_view;\n</code></pre>\n<h2 id=\"视图作用可以干什么方便-简化开发-利于维护\"><a class=\"markdownIt-Anchor\" href=\"#视图作用可以干什么方便-简化开发-利于维护\">#</a> 视图作用（可以干什么）–方便、简化开发、利于维护</h2>\n<pre><code>可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作\n\n特点：对视图的操作，会影响到原表数据\n\nselect * from dept2_view;\n\ninsert into dept2_view(deptno, dname, loc) vlaues(60, 'SALES', 'BJ');// （insert、delete、update）操作会影响到原表\n</code></pre>\n<p>视图对象在实际开发中，到底有什么作用？<br>\n假设有一条 SQL 语句，需要在不同位置反复使用，每次使用需要重新编写，可以把这条复杂的 SQL 语句以视图对象的形式创建出来<br>\n在需要编写这条 SQL 语句的位置直接使用视图对象。可以简化开发，并且利于后期维护。因为只需要修改一个位置就行了，只需要修改视图对象所映射的 SQL 语句</p>\n<p>使用视图开发的时候，可以像使用 table 一样，可以对视图进行增删改查等操作。<br>\n视图对象是存储在硬盘上的，不会消失</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/22.DBA%E5%91%BD%E4%BB%A4/DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/22.DBA%E5%91%BD%E4%BB%A4/DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "title": "DBA命令",
            "date_published": "2024-02-18T08:13:45.029Z",
            "content_html": "<h1 id=\"dba命令\"><a class=\"markdownIt-Anchor\" href=\"#dba命令\">#</a> DBA 命令</h1>\n<p><strong>必须超级管理员操作</strong></p>\n<h2 id=\"新建用户\"><a class=\"markdownIt-Anchor\" href=\"#新建用户\">#</a> 新建用户</h2>\n<pre><code>create USER username IDENTIFIED by 'password';\n\ncreate USER 'username'@'host' IDENTIFIED by 'password';\n</code></pre>\n<p>username：创建的用户名。</p>\n<p>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符 %</p>\n<p>password：该用户的登陆密码。密码可以为空，如果为空则该用户可以不需要密码登陆服务器。</p>\n<h2 id=\"授权\"><a class=\"markdownIt-Anchor\" href=\"#授权\">#</a> 授权</h2>\n<pre><code>GRANT SELECT,INSERT on *.* to 'guest'@'%';\n</code></pre>\n<p><em>.</em>：表示表示所有库的所有表</p>\n<pre><code>grant all privileges on 数据库 to '用户名'@'IP地址';\n</code></pre>\n<h2 id=\"回收权限\"><a class=\"markdownIt-Anchor\" href=\"#回收权限\">#</a> 回收权限</h2>\n<pre><code>revoke all privileges from 数据库 to '用户名'@'IP地址';\n</code></pre>\n<p>all privileges 指除了 grant 之外的所有权限，也可以自己设置权限</p>\n<p>例如：grant insert on world.* to ‘用户名’@‘IP 地址’;(只能对 world 数据库做插入操作，world.* 表示对 world 中所有表）</p>\n<h2 id=\"导出导入\"><a class=\"markdownIt-Anchor\" href=\"#导出导入\">#</a> 导出导入</h2>\n<pre><code>导出\n    在windows的dos命令窗口中：\n    mysqldump nk&gt;D:\\nk.sql -uroot -proot\n\n    导出指定的表:导出nk数据库中 student表\n    mysqldump nk student&gt;D:\\nk.sql -uroot -proot\n\n\n导入\n    登录到mysql中，创建数据库 create database nk;\n    然后导入sql文件\n    source D:\\nk.sql\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95/",
            "title": "索引",
            "date_published": "2024-02-18T08:13:45.021Z",
            "content_html": "<h1 id=\"索引\"><a class=\"markdownIt-Anchor\" href=\"#索引\">#</a> 索引</h1>\n<p>什么是索引？<br>\n索引在数据库表的字段上添加的，是为了提高检索（查询）效率存在的一种机制</p>\n<pre><code>一张表的一个字段可以添加一个索引，多个字段可以联合起来添加索引\n\n索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制\n</code></pre>\n<p>举例：<br>\n查字典：<br>\n1. 一页一页查找，直到找到为止。这种查找属于全表扫描，效率低</p>\n<pre><code>    3. 通过目录（索引），去定位一个大概的位置，然后直接定位到该位置，做局域性扫描，缩小扫描的范围，快速的查找。这种方式属于索引检索，效率高\n\nMysql中查询的两种方式：\n    1. 全表扫描\n    2. 根据索引检索\n</code></pre>\n<p>注意：<br>\n在 Mysql 数据库当中索引也是需要排序的，并且这个索引的排序和 TreeSet 数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！<br>\n在 Mysq 中索引是一个 B-Tree 数据结构。</p>\n<pre><code>遵循左小右大原则存放，采用中序遍历方式遍历取数据\n</code></pre>\n<p><strong>在任何数据库当中，主键都会自动添加索引对象</strong></p>\n<p><strong>在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号</strong></p>\n<p><strong>在 Mysql 中，一个字段上如果右 unique 约束的话，也会自动创建索引对象</strong></p>\n<p><strong>在 Mysql 当中，索引是一个单独的对象，不同的存储引擎以不同形式存在。</strong><br>\n1. 在 MyISAM 存储引擎中，索引存储在一个.MYI 文件中<br>\n 2. 在 InnoDB 存储引擎当中，索引存储在一个叫 tablespace 当中。<br>\n3. 在 Memory 存储引擎当中，被存储在内存当中<br>\n不管索引存储在哪里，索引在 Mysql 中都是一个树的形式存在。（自平衡二叉树：B-Tree）</p>\n<h2 id=\"在mysql中主键以及unique字段上都会自动添加索引\"><a class=\"markdownIt-Anchor\" href=\"#在mysql中主键以及unique字段上都会自动添加索引\">#</a> 在 Mysql 中，主键以及 unique 字段上都会自动添加索引</h2>\n<p>什么条件下，需要考虑给字段添加索引？<br>\n1. 数据量庞大（需要测试）<br>\n2. 该字段经常出现在 where 查询条件中<br>\n 3. 该字段很少的 DML 操作（因为 DML 之后，索引经常需要重新排序）<br>\n注意：<br>\n建议不要随意添加索引，因为索引也是需要维护的，太多反而会降低系统性能<br>\n建议通过主键查询，建议通过 unique 约束字段进行查询，效率是比较高的</p>\n<h2 id=\"创建和删除索引\"><a class=\"markdownIt-Anchor\" href=\"#创建和删除索引\">#</a> 创建和删除索引</h2>\n<h3 id=\"创建索引\"><a class=\"markdownIt-Anchor\" href=\"#创建索引\">#</a> 创建索引</h3>\n<pre><code>create index 索引名 on 表名(要添加索引的字段名);\n\ncreate index emp_ename_index on emp(ename);\n</code></pre>\n<h3 id=\"删除索引\"><a class=\"markdownIt-Anchor\" href=\"#删除索引\">#</a> 删除索引</h3>\n<pre><code>drop index 索引名 on 表名;\n\ndrop index emp_ename_index on emp;\n\n\n在Mysql中查看一个SQL语句是否使用了索引进行检索\nexplain select * from t_user where name = 'zhangsan6';\n</code></pre>\n<p>举例：<br>\n## 查看 sql 语句执行详情<br>\n mysql&gt; explain select * from t_user where name = ‘zhangsan6’;<br>\n±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+<br>\n| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>\n±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+<br>\n|  1 | SIMPLE      | t_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   12 |    10.00 | Using where |<br>\n±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+<br>\n1 row in set, 1 warning (0.00 sec)</p>\n<pre><code>## 为name字段创建索引\ncreate index user_name_index on t_user(name);\n\n## 在索引创建后，重新执行sql语句，查看sql执行情况\nmysql&gt; explain select * from t_user where name = 'zhangsan6';\n+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+\n| id | select_type | table  | partitions | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+\n|  1 | SIMPLE      | t_user | NULL       | ref  | user_name_index | user_name_index | 1023    | const |    1 |   100.00 | Using index |\n+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<p>性能分析：</p>\n<blockquote>\n<p>1）、id 列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id 列为 null 的就表是这是一个结果集，不需要使用它来进行查询。</p>\n<p>2）、select_type 列常见的有：<br>\nA：simple：表示不需要 union 操作或者不包含子查询的简单 select 查询。有连接查询时，外层的查询为 simple，且只有一个<br>\n B：primary：一个需要 union 操作或者含有子查询的 select，位于最外层的单位查询的 select_type 即为 primary。且只有一个<br>\n C：union：union 连接的两个 select 查询，第一个查询是 dervied 派生表，除了第一个表外，第二个以后的表 select_type 都是 union<br>\nD：dependent union：与 union 一样，出现在 union 或 union all 语句中，但是这个查询要受到外部查询的影响<br>\n E：union result：包含 union 的结果集，在 union 和 union all 语句中，因为它不需要参与查询，所以 id 字段为 null<br>\nF：subquery：除了 from 字句中包含的子查询外，其他地方出现的子查询都可能是 subquery<br>\nG：dependent subquery：与 dependent union 类似，表示这个 subquery 的查询要受到外部表查询的影响<br>\n H：derived：from 字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套 select</p>\n<p>3）、table<br>\n 显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为 null，如果显示为尖括号括起来的<derived N>就表示这个是临时表，&gt; 后边的 N 就是执行计划中的 id，表示结果来自于这个查询产生。如果是尖括号括起来的 &lt;union M,N&gt;，与<derived N>类似，也是一个临时表，表示这个结果来自于 union 查询的 id 为 M,&gt; N 的结果集。</p>\n<p>4）、type<br>\n 依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了 all 之外，其他的 type 都 &gt; 可以使用到索引，除了 index_merge 之外，其他的 type 只可以用到一个索引<br>\n A：system：表中只有一行数据或者是空表，且只能用于 myisam 和 memory 表。如果是 Innodb 引擎表，type 列在这个情况通常都是 all 或者 index<br>\nB：const：使用唯一索引或者主键，返回记录一定是 1 行记录的等值 where 条件时，通常 type 是 const。其他数据库也叫做唯一索引扫描<br>\n C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为 not null，唯一索引和主键是多列时，只有所有的 &gt; 列都用作比较时才会出现 eq_ref<br>\nD：ref：不像 eq_ref 那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一 &gt; 个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。<br>\nE：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql 不管代价，优先选择使用全文索引<br>\n F：ref_or_null：与 ref 方法类似，只是增加了 null 值的比较。实际用的不多。<br>\nG：unique_subquery：用于 where 中的 in 形式子查询，子查询返回不重复值唯一值<br>\n H：index_subquery：用于 in 形式子查询使用到了辅助索引或者 in 常数列表，子查询可能返回重复值，可以使用索引将子查询去重。<br>\nI：range：索引范围扫描，常见于使用 &gt;,&lt;,is null,between ,in ,like 等运算符的查询中。<br>\nJ：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见 and ，or 的条件使用了不同的索引，官方排序这个在 ref_or_null 之后，但是实际上由于要读取所个 &gt; 索引，性能可能大部分时间都不如 range<br>\nK：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。<br>\nL：all：这个就是全表扫描数据文件，然后再在 server 层进行过滤返回符合要求的记录。</p>\n<p>5）、possible_keys<br>\n 查询可能使用到的索引都会在这里列出来</p>\n<p>6）、key<br>\n 查询真正使用到的索引，select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个。</p>\n<p>7）、key_len<br>\n 用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进 &gt; 去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql 的 ICP 特性使用到的索引不会计入其中。&gt; 另外，key_len 只计算 where 条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到 key_len 中。</p>\n<p>8）、ref<br>\n 如果是使用的常数等值查询，这里会显示 const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部 &gt; 隐式转换，这里可能显示为 func</p>\n<p>9）、rows<br>\n 这里是执行计划中估算的扫描行数，不是精确值</p>\n<p>10）、extra<br>\n 这个列可以显示的信息非常多，有几十种，常用的有<br>\n A：distinct：在 select 部分使用了 distinc 关键字<br>\n B：no tables used：不带 from 字句的查询或者 From dual 查询<br>\n C：使用 not in () 形式子查询或 not exists 运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。<br>\nD：using filesort：排序时无法使用到索引时，就会出现这个。常见于 order by 和 group by 语句中<br>\n E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。<br>\nF：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x 之后的版本优化关联查询的 BNL，BKA 特性。主要是减少内表的循环数量以及比 &gt; 较顺序地扫描查询。<br>\nG：using sort_union，using_union，using intersect，using sort_intersection：<br>\nusing intersect：表示使用 and 的各个索引的条件时，该信息表示是从处理结果获取交集<br>\n using union：表示使用 or 连接各个使用索引的条件时，该信息表示从处理结果获取并集<br>\n using sort_union 和 using sort_intersection：与前面两个对应的类似，只是他们是出现在用 and 和 or 查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返 &gt; 回。<br>\nH：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看 status 变量，used_tmp_table，&gt; used_tmp_disk_table 才能看出来。<br>\nI：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在 server 层进行过滤。查询条件中分为限制条件和检查条件，5.6 之前，存储引擎只能根据限制条件 &gt; 扫描数据并返回，然后 server 层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x 之后支持 ICP 特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数 &gt; 据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra 列显示 using index condition<br>\nJ：firstmatch (tb_name)：5.6.x 开始引入的优化子查询的新特性之一，常见于 where 字句含有 in () 类型的子查询。如果内表的数据量比较大，就可能出现这个<br>\n K：loosescan (m…n)：5.6.x 之后引入的优化子查询的新特性之一，在 in () 类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p>\n<p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</p>\n<p>11）、filtered<br>\n 使用 explain extended 时会出现这个列，5.7 之后的版本默认就有这个字段，不需要使用 explain extended 了。这个字段表示存储引擎返回的数据在 server 层过滤后，剩下多少满足 &gt; 查询的记录数量的比例，注意是百分比，不是具体记录数。</p>\n</blockquote>\n<h3 id=\"性能分析2-explain-analyze\"><a class=\"markdownIt-Anchor\" href=\"#性能分析2-explain-analyze\">#</a> 性能分析 2 Explain Analyze</h3>\n<pre><code class=\"language-Sql\">\n-- auto-generated definition\ncreate table eps_working_rec\n(\n    RecNo      int auto_increment comment '记录编号'\n        primary key,\n    ShiftNo    varchar(20)    null,\n    WorkDate   datetime       null comment '生产日期',\n    LineFK     varchar(50)    null comment '包装线编号',\n    EqutFK     varchar(20)    not null comment '设备编号',\n    Rec_Type   int            not null comment '记录类型',\n    StopReason varchar(50)    null comment '停机类型：A—交接班，B—工艺清洗，C—更换品种，D—外部原因，E—故障停机',\n    BeginTime  datetime       null comment '开始时间',\n    EndTime    datetime       null comment '结束时间',\n    Time_Cum   int            null comment '时长',\n    BBQty      decimal(18, 4) null comment '清酒量(单位：KL)',\n    FinalBot   int            null comment '成品瓶数（单位：瓶）',\n    IsValid    tinyint        null comment '数据是否有效',\n    DataSrouce varchar(10)    null comment '数据来源：数据采集Automatic，人工维护Manual',\n    CreateBy   varchar(20)    null comment '创建者（默认值：数据采集）',\n    CreateOn   datetime       null comment '创建时间（记录插入时的系统时间）',\n    UpdateBy   varchar(20)    null comment '修改人',\n    UpdateOn   datetime       null comment '修改时间',\n    StopClass  varchar(50)    null,\n    Qty_Bottle int            null,\n    Qty_Box    int            null,\n    Qty_Stack  int            null,\n    IsFillStop tinyint        null,\n    Classes    varchar(20)    null,\n    StopNature varchar(50)    null\n)\n    charset = utf8mb3;\n\ncreate index PK_EPS_VBT\n    on eps_working_rec (IsValid, BeginTime, Time_Cum);\n\ncreate index PK_LineFK_EqutFk\n    on eps_working_rec (LineFK, EqutFK);\n\ncreate index dta_index_EPS_Working_Rec\n    on eps_working_rec (EqutFK, StopReason, BeginTime, EndTime, Time_Cum, Rec_Type, RecNo);\n\n\n# 执行的sql语句\nexplain analyze\nselect sum(Time_Cum)\nfrom eps_working_rec\nwhere Rec_Type = 1\n  and EqutFK = 'EQPK21004'\n\n# 执行sql返回的结果\n-&gt; Aggregate: sum(eps_working_rec.Time_Cum)  (cost=3496.35 rows=1) (actual time=15.869..15.869 rows=1 loops=1)\n    -&gt; Filter: (eps_working_rec.Rec_Type = 1)  (cost=2762.65 rows=7337) (actual time=0.054..14.458 rows=20016 loops=1)\n        -&gt; Covering index lookup on eps_working_rec using dta_index_EPS_Working_Rec (EqutFK='EQPK21004')  (cost=2762.65 rows=73370) (actual time=0.053..12.303 rows=40293 loops=1)\n\n</code></pre>\n<blockquote>\n<p>(cost=3496.35 rows=1) cost 预计执行时间、rows 预计返回记录条数</p>\n<p>(cost=2762.65 rows=7337) (actual time=0.054…14.458 rows=20016 loops=1)<br>\n 实际执行结果情况：<br>\ntime 分为两部分: 0.054 返回第一条记录的时间  14.458 返回所有记录耗时<br>\n row 返回准确的记录数<br>\n loops 是当前过滤迭代器所执行的循环的数量。</p>\n</blockquote>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/",
            "title": "索引失效",
            "date_published": "2024-02-18T08:13:45.021Z",
            "content_html": "<h1 id=\"索引失效\"><a class=\"markdownIt-Anchor\" href=\"#索引失效\">#</a> 索引失效</h1>\n<p>什么时候索引会失效？</p>\n<pre><code>第一种情况：\n select * from t_user where name like '%z';\n\n 因为模糊匹配中以 '%' 开头了，索引失效（存在索引，但不走索引）\n\n\n第二种情况：\n 使用or的时候会失效，如果使用or，那么要求or两边字段条件都要有索引，才会走索引。如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效\n\n\n第三种情况：\n 使用复合索引的时候，没有使用左侧的列查找，索引失效( 最左原则 )\n create index emp_job_sal_index on emp(job, sal);\n\n explain select * from emp where job = 'MANAGER';// 走索引\n explain select * from emp where sal = 1000;// 索引失效\n\n\n第四种情况：\n 在where当中，索引参与了数学运算，索引失效\n\n create index emp_sal_index on emp(sal);\n\n explain select * from emp where sal = 800;// 走索引\n explain select * from emp where sal = 800 + 100;// 走索引\n\n explain select * from emp where sal + 100 = 800;// 索引失效\n\n\n第五种情况：\n 在where当中，索引列使用了函数，索引失效\n\n create index emp_ename_index on emp(ename);\n\n explain select * from emp where ename = 'SIMTH';// 走索引\n\n explain select * from emp where lower(ename) = 'simth';// 索引失效\n\n\n第六种情况：....\n第七种情况：....\n...\n\n\n\n索引是数据库优化的重要手段，优化的时候，优先考虑的因素就是索引。\n</code></pre>\n<p>索引分类：<br>\n单一索引：<br>\n复合索引：<br>\n主键索引：<br>\n唯一性索引：<br>\n…</p>\n<p>注意：唯一性比较弱的字段上添加索引用处不大。（可能存在大量重复数据，这个时候索引起不到什么作用，越唯一，效率越高）</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/",
            "title": "事务隔离",
            "date_published": "2024-02-18T08:13:45.013Z",
            "content_html": "<h1 id=\"事务隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#事务隔离级别\">#</a> 事务隔离级别</h1>\n<h2 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类</h2>\n<h3 id=\"读未提交read-uncommitted\"><a class=\"markdownIt-Anchor\" href=\"#读未提交read-uncommitted\">#</a> 读未提交：read uncommitted</h3>\n<pre><code>概念：\n    事务A可以读取到事务B未提交的数据\n\n存在脏读现象（Dirty Rread）：称读到脏数据\n</code></pre>\n<h3 id=\"读已提交readcommitted\"><a class=\"markdownIt-Anchor\" href=\"#读已提交readcommitted\">#</a> 读已提交：readcommitted</h3>\n<pre><code>概念：\n    事务A只能读取到事务B提交之后的数据\n这种隔离级别解决了脏读现象\n\n存在‘不可重复读取数据’问题：在事务开启后，每次读取到的数据可能不一致。比如A开始事务循环读取数据的过程中，B事务不断修改数据并提交，导致A事务在后续的数据读取过程中，数据产生不一致的现象\n\n这种隔离级别是比较真实的数据，每一次读到的数据绝对真实\n注意：Oracle数据库默认的隔离级别是： read committed\n</code></pre>\n<h3 id=\"可重复读repeatable-read\"><a class=\"markdownIt-Anchor\" href=\"#可重复读repeatable-read\">#</a> 可重复读：repeatable read</h3>\n<pre><code>概念：\n    事务A开启后，不管多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据修改，并且提交了。事务A读取到的数据还是没有发生改变，这就是可重复读\n解决了不可重复读的现象\n\n存在幻读现象：每一次读取到的数据都是幻象，不够真实\n\nMysql默认隔离级别\n</code></pre>\n<h3 id=\"序列化串行化serializable\"><a class=\"markdownIt-Anchor\" href=\"#序列化串行化serializable\">#</a> 序列化 / 串行化：serializable</h3>\n<pre><code>概念：\n\n隔离级别最高，效率最低。解决了所有问题\n不能并发\n</code></pre>\n<h2 id=\"测试隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#测试隔离级别\">#</a> 测试隔离级别</h2>\n<pre><code>查看变量：\nshow variables;\n通过like 通配符查询\nshow variables like '%isolation%';\n\n查看隔离级别：\nselect @@transaction_isolation; \n\n设置全局事务等级\nset global transaction isolation level read committed;\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/2.Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/2.Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "title": "Mysql常用命令",
            "date_published": "2024-02-18T08:13:45.013Z",
            "content_html": "<ol>\n<li>在 windows 操作系统中，怎么使用命令行来启动 Mysql 和关闭 Mysql 服务？</li>\n</ol>\n<p>语法：</p>\n<p>​\tnet stop 服务名称；</p>\n<p>​\tnet start 服务名称；</p>\n<ol start=\"2\">\n<li>\n<p>登录 Mysql 数据库</p>\n<p>明文密码登录：mysql -u [用户名] -p [密码]</p>\n<p>隐藏密码登录：mysql -u [用户名] -p + 回车键，然后输入密码</p>\n</li>\n<li>\n<p>退出 Mysql</p>\n<p>exit</p>\n</li>\n<li>\n<p>查看数据库有哪些数据库？mysql 默认自带了 4 个数据库</p>\n<p>show databases;</p>\n</li>\n<li>\n<p>怎么选择使用哪个数据库？</p>\n<p>use [数据库名]</p>\n</li>\n<li>\n<p>怎么创建数据库？</p>\n<p>create database [数据库名];</p>\n</li>\n<li>\n<p>怎么查看有哪些表？</p>\n<p>show tables;</p>\n</li>\n<li>\n<p>怎么查看表结构？</p>\n<p>desc [表名]</p>\n<p>全写为：</p>\n<p>​\tdescribe [表名]</p>\n</li>\n<li>\n<p>将 sql 文件中的数据导入？</p>\n<p>source [路径]</p>\n<p><strong>注意路径中不要有中文。</strong></p>\n<p>例如： source D:\\coure\\03-Mysql\\document\\bjpowernode.sql</p>\n</li>\n<li>\n<p>查看数据库版本号</p>\n<p>select version();</p>\n</li>\n<li>\n<p>查看当前使用的是那个数据库</p>\n<p>select database();</p>\n</li>\n<li>\n<p>中止输入的 mysql 命令（还未执行的命令）</p>\n<p>\\c 用来中止一条命令的输入。</p>\n<p>例如：</p>\n<p><em>mysql&gt; show</em><br>\n<em>-&gt;</em><br>\n<em>-&gt;</em><br>\n<em>-&gt;</em><br>\n<em>-&gt; \\c</em><br>\n<em>mysql&gt;</em></p>\n</li>\n<li>\n<p>查看 Mysql 支持那些存储引擎</p>\n</li>\n</ol>\n<p>show engines \\G;</p>\n<ol start=\"14\">\n<li>查看建表语句</li>\n</ol>\n<p>show create table 表名；</p>\n<p>！！！以上命令不区分大小写</p>\n<p>！！！注意：Mysql 中命令是不见分号；则不会执行命令。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/18.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/18.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/",
            "title": "存储引擎",
            "date_published": "2024-02-18T08:13:45.004Z",
            "content_html": "<h1 id=\"存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#存储引擎\">#</a> 存储引擎</h1>\n<p>什么是存储引擎？有什么用？</p>\n<pre><code>存储引擎是Mysql中特有的一个术语。其他数据库中没有（Oracle中也有，不叫这个名字）\n\n存储引擎实际上是一张表存储/组织数据的方式。\n\n不同的存储引擎，表存储的方式不同。\n</code></pre>\n<p>如何制定表的存储引擎？</p>\n<pre><code>可以在建表时，最后来指定表的存储引擎。\ncharset 来指定表的字符编码方式\n\nshow create table student;\n\nCREATE TABLE `student` (\n`id` int NOT NULL AUTO_INCREMENT,\n`name` varchar(255) DEFAULT NULL,\n`cno` int DEFAULT NULL,\nPRIMARY KEY (`id`),\nKEY `cno` (`cno`),\nCONSTRAINT `student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`t_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |\n</code></pre>\n<p>结论：<br>\nmysql 默认的存储引擎是 InnoDB<br>\nmysql 默认的字符编码方式： utf8mb4</p>\n<pre><code>create table test(\n    id int,\n    name varchar(10)\n) engine=InnoDB default CHARSET=utf8mb4;\n</code></pre>\n<h2 id=\"查看mysql支持哪些存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#查看mysql支持哪些存储引擎\">#</a> 查看 Mysql 支持哪些存储引擎</h2>\n<pre><code>show engines \\G;\n\nmysql&gt; show engines \\G;\n*************************** 1. row ***************************\n    Engine: MEMORY\n    Support: YES\n    Comment: Hash based, stored in memory, useful for temporary tables\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 2. row ***************************\n    Engine: MRG_MYISAM\n    Support: YES\n    Comment: Collection of identical MyISAM tables\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 3. row ***************************\n    Engine: CSV\n    Support: YES\n    Comment: CSV storage engine\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 4. row ***************************\n    Engine: FEDERATED\n    Support: NO\n    Comment: Federated MySQL storage engine\nTransactions: NULL\n        XA: NULL\nSavepoints: NULL\n*************************** 5. row ***************************\n    Engine: PERFORMANCE_SCHEMA\n    Support: YES\n    Comment: Performance Schema\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 6. row ***************************\n    Engine: MyISAM\n    Support: YES\n    Comment: MyISAM storage engine\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 7. row ***************************\n    Engine: InnoDB\n    Support: DEFAULT\n    Comment: Supports transactions, row-level locking, and foreign keys\nTransactions: YES\n        XA: YES\nSavepoints: YES\n*************************** 8. row ***************************\n    Engine: ndbinfo\n    Support: NO\n    Comment: MySQL Cluster system information storage engine\nTransactions: NULL\n        XA: NULL\nSavepoints: NULL\n*************************** 9. row ***************************\n    Engine: BLACKHOLE\n    Support: YES\n    Comment: /dev/null storage engine (anything you write to it disappears)\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 10. row ***************************\n    Engine: ARCHIVE\n    Support: YES\n    Comment: Archive storage engine\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 11. row ***************************\n    Engine: ndbcluster\n    Support: NO\n    Comment: Clustered, fault-tolerant tables\nTransactions: NULL\n        XA: NULL\nSavepoints: NULL\n11 rows in set (0.00 sec)\n</code></pre>\n<h2 id=\"常用存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#常用存储引擎\">#</a> 常用存储引擎</h2>\n<h3 id=\"myisam\"><a class=\"markdownIt-Anchor\" href=\"#myisam\">#</a> MyISAM</h3>\n<pre><code>特征：\n    使用三个文件夹表示每个表\n        格式文件-存储表结构的定义（mytable.frm)\n        数据文件-存储表行的内容（mytable.MYD)\n        索引文件-存储表上的索引（mytable.MYI) ：索引是一本数的目录，缩小扫描范围，提高效率\n    可被转换为压缩、只读表来节省空间\n\n优点：可被转换为压缩、只读表来节省空间\n缺点：不支持事务机制，安全性低\n</code></pre>\n<h3 id=\"innodb\"><a class=\"markdownIt-Anchor\" href=\"#innodb\">#</a> InnoDB</h3>\n<pre><code>Mysql默认的存储引擎，同时也是一个重量级的存储引擎\n主要特点：非常安全\n    InnoDB支持事务\n    支持数据库崩溃后自动回复机制\n\n特征：\n    1. 每个InnoDB表在数据库目录中以.frm格式文件表示\n    2. InnoDB表空间tablespace被用于存储表的内容\n    3. 提供一组用于记录事务特性活动的日志文件\n    4. 用commit（提交）、savepoint 及 rollback（回滚）支持事务处理\n    5. 提供全ACID兼容\n    6. 在Mysql服务器崩溃后提供自动恢复\n    7. 多版本（MVCC）和行级锁定\n    8. 支持外键及引用的完整性，包括级联删除和更新\n    \n优点：支持事务\n    以保证数据的安全。\n缺点：\n    1. 效率不是很高\n    2. 不能压缩\n    3. 不能转换为只读\n    4. 不能很好的节省存储空间\n</code></pre>\n<h3 id=\"memory\"><a class=\"markdownIt-Anchor\" href=\"#memory\">#</a> MEMORY</h3>\n<pre><code>内存存储引擎（别名堆引擎）\n\n使用MEMORY存储引擎的表，其数据存储在内存中，且长度固定\n这俩个特点使得MEMORY存储引擎非常快\n\n特征：\n    1. 在数据库目录中，每个表都以.frm 格式的文件表示\n    2. 表数据和索引被存储在内存中（目的：查询快）\n    3. 表级锁机制\n    4. 不能包含 TEXT 或 BLOB 字段\n\nMEMORY 存储引擎以前被称为HEAP引擎。\n\n优点：查询效率最高\n缺点：不安全，关机后数据消失，因为数据和索引都是存储在内存当中\n</code></pre>\n<h2 id=\"注意对于一张表来说只要是主键或者加有unique约束的字段上会自动创建索引\"><a class=\"markdownIt-Anchor\" href=\"#注意对于一张表来说只要是主键或者加有unique约束的字段上会自动创建索引\">#</a> 注意：对于一张表来说，只要是主键，或者加有 unique 约束的字段上会自动创建索引。</h2>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/",
            "title": "事务",
            "date_published": "2024-02-18T08:13:45.004Z",
            "content_html": "<h1 id=\"事务\"><a class=\"markdownIt-Anchor\" href=\"#事务\">#</a> 事务</h1>\n<p>什么是事务？<br>\n一个事务就是一个完整的业务逻辑。<br>\n是一个最小的工作单元。</p>\n<pre><code>例如转账的业务逻辑，就是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。\n</code></pre>\n<p>本质：就是多条 DML 语句同时成功或者同时失败</p>\n<p><strong>只有 DML 语句和事务有关系，其他语句无关。</strong><br>\ninsert<br>\nupdate<br>\ndelete<br>\n 因为以上三个语句是操作数据库中数据的</p>\n<p>事务是怎么做到同时成功或者同时失败的？</p>\n<pre><code>InnoDB：提供一组用于记录事务特性活动的日志文件\n\n在事务执行的过程中，每一条DML的操作都会被记录到“事务特性活动的日志文件”中\n</code></pre>\n<p><strong>在事务执行的过程中，可以提交事务，也可以回滚事务</strong></p>\n<pre><code>提交事务： 清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中\n    标志着事务的结束，并且是一种全部成功的结束\n\n回滚事务： 将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件\n    回滚事务标志着事务的结束，并且是一种全部失败的结束\n</code></pre>\n<h2 id=\"提交事务-回滚事务\"><a class=\"markdownIt-Anchor\" href=\"#提交事务-回滚事务\">#</a> 提交事务、回滚事务</h2>\n<pre><code>提交事务：commit\n回滚事务：rollback (回滚只能回滚到上一次的提交点)\n\n事务对应的单词：transaction\n\nMysql中默认情况下是自动提交事务的（自动提交）\n\n开启事务\n    start transaction;\n</code></pre>\n<h2 id=\"事务特性\"><a class=\"markdownIt-Anchor\" href=\"#事务特性\">#</a> 事务特性</h2>\n<pre><code>A：原子性\n    说明事务是最小工作单元，不可再分\n\nC：一致性\n    所有事务要求，在同一个事务中，所有操作必须同时成功，或者同时失败，以保证数据的一致性\n\nI：隔离性\n    A事务和B事务之间具有一定的隔离\n\nD：持久性\n    事务最终结束的一个保障，事务提交，将没有保存到硬盘上的数据保存到硬盘上\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/15.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/15.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
            "title": "数据类型",
            "date_published": "2024-02-18T08:13:44.996Z",
            "content_html": "<h1 id=\"mysql-数据类型\"><a class=\"markdownIt-Anchor\" href=\"#mysql-数据类型\">#</a> Mysql 数据类型</h1>\n<pre><code>varchar\n    可变长度的字符串\n    比较智能，节省空间\n    会根据实际长度，动态的分配空间\n\n    缺点：需要动态分配空间，速度慢\n    优点：节省空间\n\nchar\n    定长字符串\n    不管实际长度是多少\n    分配固定长度的空间去存储数据\n    使用不恰当的时候，可能导致空间浪费\n\n    缺点：使用不当，可能导致空间浪费\n    优点：不需要动态分配空间，速度快\n\nint\n\nbigint\n\nfloat\n\ndouble\n\ndate\n    短日期类型\n\ndatetime\n    长日期类型\n\nclob\n    字符大对象\n    最多存储4g的字符串\n    比如：存储一篇文章\n    超过255个字符的，尽量都使用clob\n    Character Large Object: clob\n\nblob\n    存储二进制对象\n    图片，声音，视频，等流媒体数据\n    往blob字段中插入数据时，需要使用IO流。\n\ndate\n    短日期：只包括 年月日\n\n    Mysql默认格式：可以将该格式的时间字符串直接插入到date类型的字段中\n    %Y-%m-%d\n\n\ndatetime\n    长日期：包括 年月日时分秒\n\n    Mysql默认格式：可以将该格式的时间字符串直接插入到date类型的字段中\n    %Y-%m-%d %h:%i:%s\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/16.DML/DML/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/16.DML/DML/",
            "title": "DML",
            "date_published": "2024-02-18T08:13:44.996Z",
            "content_html": "<h1 id=\"insert\"><a class=\"markdownIt-Anchor\" href=\"#insert\">#</a> insert</h1>\n<pre><code>// 根据字段名，插入数据\n// 注意： 字段名和值要一一对应\ninsert into 表名(字段名1,字段名2...) values(值1,值2...);\n\n\n//表示插入所有字段\ninsert into 表名 values(值1,值2...);\n\n// 一次插入多条数据，用逗号隔开\ninsert into test values(1, '张三', '1999-12-13'), (2, '李四', '2000-01-02');\n</code></pre>\n<h2 id=\"将查询结果插入到一张表\"><a class=\"markdownIt-Anchor\" href=\"#将查询结果插入到一张表\">#</a> 将查询结果插入到一张表</h2>\n<pre><code>快速创建dept_bak表，同时数据也存入了dept_bak表中。\ncreate table dept_bak as select * from dept;\n\n将查询到的结果insert into到dept_bak表中\ninsert into dept_bak select * from dept;\n</code></pre>\n<h1 id=\"update\"><a class=\"markdownIt-Anchor\" href=\"#update\">#</a> update</h1>\n<pre><code>update 表名 set 字段名1 = 值1, 字段名2 = 值2 where 条件;\n</code></pre>\n<h1 id=\"delete\"><a class=\"markdownIt-Anchor\" href=\"#delete\">#</a> delete</h1>\n<pre><code>delete from 表名 where 条件;\n\n原理：\n表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放\n\n优点：支持回滚，可以恢复\n缺点：删除效率低\n</code></pre>\n<h2 id=\"快速删除表\"><a class=\"markdownIt-Anchor\" href=\"#快速删除表\">#</a> 快速删除表</h2>\n<pre><code>truncate 语句删除数据（属于DDL）\n    删除效率高，表被一次截断，物理删除\n\n    优点：效率高，快\n    缺点：不支持回滚\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/17.%E7%BA%A6%E6%9D%9F/%E7%BA%A6%E6%9D%9F/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/17.%E7%BA%A6%E6%9D%9F/%E7%BA%A6%E6%9D%9F/",
            "title": "约束",
            "date_published": "2024-02-18T08:13:44.996Z",
            "content_html": "<h1 id=\"约束\"><a class=\"markdownIt-Anchor\" href=\"#约束\">#</a> 约束</h1>\n<h2 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h2>\n<pre><code>constraint，在创建表的时候，创建一些约束，保证表中数据的完整性、有效性\n</code></pre>\n<h2 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用</h2>\n<pre><code>保证表中的数据有效。\n</code></pre>\n<h3 id=\"非空约束\"><a class=\"markdownIt-Anchor\" href=\"#非空约束\">#</a> 非空约束</h3>\n<pre><code>not null：字段值不能为NULL\n\ncreate table student(\n    id int,\n    name varchar(50) not null   // 只有列级 '非空约束'，没有表级 '非空约束'\n);\n</code></pre>\n<h3 id=\"唯一性约束\"><a class=\"markdownIt-Anchor\" href=\"#唯一性约束\">#</a> 唯一性约束</h3>\n<pre><code>unique:字段值不能重复，但可以为NULL（可以有多条NULL值）\n\ncreate table student(\n    id int,\n    name varchar(50) unique\n);\n\n案例：\nmysql&gt; select * from student;\n+------+------+\n| id   | name |\n+------+------+\n|    1 | z    |\n|    1 | NULL |\n|    1 | NULL |\n|    1 | NULL |\n|    1 | NULL |\n|    1 | NULL |\n+------+------+\n6 rows in set (0.00 sec)\n\nmysql&gt; desc student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int         | YES  |     | NULL    |       |\n| name  | varchar(50) | YES  | UNI | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n2 rows in set (0.00 sec)\n</code></pre>\n<h4 id=\"建立多个字段唯一性约束\"><a class=\"markdownIt-Anchor\" href=\"#建立多个字段唯一性约束\">#</a> 建立多个字段唯一性约束</h4>\n<pre><code>1. 多字段各自唯一性约束\ncreate table student(\n    id int unique,\n    name varchar(50) unique // 列级约束\n);\n上边的表，id 和 name 字段各自有唯一性约束，互不影响。\n\n2. 多字段组合后唯一性约束\ncreate table student(\n    id int,\n    name varchar(50),\n    unique(id, name)    // 表级约束\n);\n上边的表，id 和 name 字段联合起来唯一。\n</code></pre>\n<h3 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h3>\n<pre><code>在Mysql中，如果一个字段同时被 not null 和 unique 约束的话，该字段自动成为主键。（Oracle中不一样）\n</code></pre>\n<h3 id=\"主键约束\"><a class=\"markdownIt-Anchor\" href=\"#主键约束\">#</a> 主键约束</h3>\n<pre><code>primary key\n\n主键值是每一行的唯一标识\n主键特征：unique + not null\n\n写法一：列级约束\ncreate table student(\n    id int primary key,\n    name varchar(255)\n);\n\n写法二：表级约束\ncreate table student(\n    id int,\n    name varchar(255),\n    primary key(id)\n);\n</code></pre>\n<h4 id=\"多个字段建立主键约束\"><a class=\"markdownIt-Anchor\" href=\"#多个字段建立主键约束\">#</a> 多个字段建立主键约束</h4>\n<pre><code>// 复合主键\ncreate table student(\n    id int,\n    name varchar(255),\n    primary key(id, name)\n);\n\n//错误 一张表不能建立多个主键\n    create table student(\n    id int primary key,\n    name varchar(255) primary key\n);\n</code></pre>\n<h4 id=\"mysql中自然主键\"><a class=\"markdownIt-Anchor\" href=\"#mysql中自然主键\">#</a> Mysql 中自然主键</h4>\n<pre><code>create table student(\n    id int primary key auto_increment,  // 从 1 开始递增\n    name varchar(255)\n);\n</code></pre>\n<h3 id=\"外键约束\"><a class=\"markdownIt-Anchor\" href=\"#外键约束\">#</a> 外键约束</h3>\n<pre><code> foreign key\n\ncreate table t_class(\n    t_id int primary key auto_increment,\n    t_name varchar(50)\n);\n\ncreate table student(\n    id int primary key auto_increment,\n    name varchar(255),\n    cno int,\n    foreign key (cno) references t_class(t_id)\n);\n</code></pre>\n<p>注意：子表中的外键引用父表中的某个字段，被引用的这个字段不一定是主键，但是至少有 unique 约束。（否则，子表不能确定引用的是父表中的那条数据）</p>\n<p><strong>注意：外键可以为 NULL</strong></p>\n<h3 id=\"检查性约束\"><a class=\"markdownIt-Anchor\" href=\"#检查性约束\">#</a> 检查性约束</h3>\n<pre><code>check(Mysql 不支持， Oracle支持)\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/13.%E5%88%86%E9%A1%B5/limit/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/13.%E5%88%86%E9%A1%B5/limit/",
            "title": "Mysql中limit",
            "date_published": "2024-02-18T08:13:44.988Z",
            "content_html": "<h1 id=\"limit\"><a class=\"markdownIt-Anchor\" href=\"#limit\">#</a> limit</h1>\n<h2 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用</h2>\n<pre><code>将查询结果集的一部分取出来，通常用在分页中。\n</code></pre>\n<h2 id=\"语法\"><a class=\"markdownIt-Anchor\" href=\"#语法\">#</a> 语法</h2>\n<pre><code>limit startIndex, length\nstartIndex: 起始下标，从0开始\nlength: 长度\n\n缺省用法：limit length\nlength: 长度\n</code></pre>\n<p>案例：按照薪资降序，取出前五名员工。</p>\n<pre><code>\n缺省用法：\n\nselect\n    ename, sal\nfrom\n    emp\norder by\n    sal desc\nlimit 5;\n\n完整用法：\n\nselect\n    ename, sal\nfrom\n    emp\norder by\n    sal desc\nlimit 5;\n\n</code></pre>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<pre><code>在mysql中，limit是在order by之后执行的。\n</code></pre>\n<h1 id=\"分页\"><a class=\"markdownIt-Anchor\" href=\"#分页\">#</a> 分页</h1>\n<pre><code>limit (pageNum - 1) * pageSize, pageSize;\n</code></pre>\n<h2 id=\"offset\"><a class=\"markdownIt-Anchor\" href=\"#offset\">#</a> offset</h2>\n<pre><code>作用同limit，配合limit使用，注意：limit此时只能有一个参数\n\nlimit pageSize, offset (pageNum - 1) * pageSize;\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/14.DDL/DDL/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/14.DDL/DDL/",
            "title": "DDL",
            "date_published": "2024-02-18T08:13:44.988Z",
            "content_html": "<h1 id=\"ddl-语句\"><a class=\"markdownIt-Anchor\" href=\"#ddl-语句\">#</a> DDL 语句</h1>\n<pre><code>create、drop、alter\n</code></pre>\n<h2 id=\"create-建表\"><a class=\"markdownIt-Anchor\" href=\"#create-建表\">#</a> create 建表</h2>\n<pre><code>语法格式：\ncreate table 表名 (\n    字段名 数据类型,\n    字段名 数据类型,\n    ...\n    字段名 数据类型 //切记！！！   最后一句没有标点符号\n);\n</code></pre>\n<h3 id=\"快速创建表\"><a class=\"markdownIt-Anchor\" href=\"#快速创建表\">#</a> 快速创建表</h3>\n<pre><code>create table emp2 as select * from emp;\n原理：\n    将一个查询结果当作一张表新建\n    可以快速创建一张表，同时数据也存在。\n\ncreate table emp2 as select * from emp where ename = 'SMITH';\n注意：查询语句可以添加条件等。\n</code></pre>\n<h2 id=\"drop-删表\"><a class=\"markdownIt-Anchor\" href=\"#drop-删表\">#</a> drop 删表</h2>\n<pre><code>语法格式：\ndrop table 表名;    //当表不存在时，会报错\ndrop table if exists 表名;  // 当表存在的话，删除\n</code></pre>\n<h2 id=\"alter-对表结构修改\"><a class=\"markdownIt-Anchor\" href=\"#alter-对表结构修改\">#</a> alter 对表结构修改</h2>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql子查询",
            "date_published": "2024-02-18T08:13:44.979Z",
            "content_html": "<h1 id=\"子查询\"><a class=\"markdownIt-Anchor\" href=\"#子查询\">#</a> 子查询</h1>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<pre><code>select语句中嵌套select语句，被嵌套的select语句被称为子查询。\n</code></pre>\n<h2 id=\"子查询可以出现的位置\"><a class=\"markdownIt-Anchor\" href=\"#子查询可以出现的位置\">#</a> 子查询可以出现的位置</h2>\n<pre><code>select\n    ..(select子).\nfrom\n    ..(select子).\nwhere\n    ..(select子).\n</code></pre>\n<h2 id=\"where子句中的子查询\"><a class=\"markdownIt-Anchor\" href=\"#where子句中的子查询\">#</a> where 子句中的子查询</h2>\n<p>案例：找出比最低工资高的员工的姓名和薪资。</p>\n<pre><code>\nselect \n    ename, sal\nfrom\n    emp\nwhere\n    sal &gt; (select min(sal) from emp);\n\n</code></pre>\n<h2 id=\"from-子查询\"><a class=\"markdownIt-Anchor\" href=\"#from-子查询\">#</a> from 子查询</h2>\n<pre><code>from后边的子查询，可以当作一张临时的表。\n</code></pre>\n<p>案例：找出每个岗位的平均工资的薪资等级</p>\n<pre><code>\nselect\n    t.*, sg.grade\nfrom\n    (select job, avg(sal) as avgsal from emp group job) t\njoin\n    salgrade\non\n    t.avgsal between sg.losal and hisal;\n\n</code></pre>\n<h2 id=\"select-子查询\"><a class=\"markdownIt-Anchor\" href=\"#select-子查询\">#</a> select 子查询</h2>\n<p>案例：找出每个员工的部门名称，要求显示员工姓名，部门名称。</p>\n<pre><code>\nselect\n    e.ename, (select d.ename from dept e where e.deptno = d.deptno) as dname\nfrom\n    emp e;\n\n</code></pre>\n<h3 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h3>\n<pre><code>在select语句中的子查询，这个子查询语句只能一次返回一条结果，多于一条，就报错了。\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/3.%E5%A4%96%E8%BF%9E%E6%8E%A5/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/3.%E5%A4%96%E8%BF%9E%E6%8E%A5/",
            "title": "Mysql外连接",
            "date_published": "2024-02-18T08:13:44.979Z",
            "content_html": "<h1 id=\"外连接\"><a class=\"markdownIt-Anchor\" href=\"#外连接\">#</a> 外连接</h1>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<pre><code>外连接当中，两张表关联查询产生主次关系。\n左连接和右连接可以相互切换。（\n    1. 任何一个左连接都有一个右连接的写法。\n    2. 任何一个右连接都有一个左连接的写法。\n    ）\n</code></pre>\n<h2 id=\"右外连接\"><a class=\"markdownIt-Anchor\" href=\"#右外连接\">#</a> 右外连接</h2>\n<p>right 代表，将右边的表看作主表，主要是将这张主表的内容全部查出来，捎带着关联查询左边的表</p>\n<pre><code>\n                                          outer可以省略\nselect e.ename, d.ename from emp e right [outer] join dept d on e.deptno = e.deptno;\n\n</code></pre>\n<h2 id=\"左外连接\"><a class=\"markdownIt-Anchor\" href=\"#左外连接\">#</a> 左外连接</h2>\n<p>left 代表，将左边的表看作主表，和右外连接相反。</p>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<pre><code>外连接的查询结果条数一定是 &gt;= 内连接的查询结果条数\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/4.%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/4.%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql多表连接查询",
            "date_published": "2024-02-18T08:13:44.979Z",
            "content_html": "<h1 id=\"多表连接查询\"><a class=\"markdownIt-Anchor\" href=\"#多表连接查询\">#</a> 多表连接查询</h1>\n<pre><code>语法：\nselect\n    ...\nfrom\n    a\njoin                    // 内连接\n    b\non\n    a表和b表的连接条件\njoin                    // 内连接\n    c\non\n    a表和c表的连接条件\nright join              // 外连接\n    d\non\n    a和d的连接条件\n</code></pre>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<p><strong>一条 SQL 中内连接和外连接可以混合，都可以出现！</strong></p>\n<p>案例：找出每个员工的部门名称，以及工资等级，要求显示员工名，部门名，薪资，薪资等级。</p>\n<pre><code>\nselect \n    e.ename, d.ename, e.sal, sg.grade \nfrom \n    emp e \njoin \n    dept d \non \n    e.deptno = d.deptno \njoin \n    salgrade sg \non \n    e.sal between sg.losal and hisal;\n\n</code></pre>\n<p>案例：找出每个员工的部门名称，以及工资等级，要求显示员工名，领导名，部门名，薪资，薪资等级。</p>\n<pre><code>\nselect \n    e.ename, d.ename, e.sal, sg.grade \nfrom \n    emp e \njoin \n    dept d \non \n    e.deptno = d.deptno \njoin \n    salgrade sg \non \n    e.sal between sg.losal and hisal\nleft outer join\n    emp l\non\n    e.mgr = l.empno;\n\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/6.union/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/6.union/",
            "title": "Mysql中union",
            "date_published": "2024-02-18T08:13:44.979Z",
            "content_html": "<h1 id=\"union\"><a class=\"markdownIt-Anchor\" href=\"#union\">#</a> union</h1>\n<h2 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用</h2>\n<pre><code>合并查询结果集\n</code></pre>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<pre><code>union的效率更高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。\n但是union可以减少匹配次数。\n在减少匹配次数的情况下，还可以完成两个结果的拼接。\n\n例如：a 连接 b 连接 c\na: 10条记录\nb: 10条记录\nc: 10条记录\n匹配次数为 : 10*10*10 = 1000\n\n如果改为union\na 连接 b ： 10*10 = 100\na 连接 c ： 10*10 = 100\n100 + 100 = 200次（union把乘法变成了加法运算）\n</code></pre>\n<p>案例：查询工作岗位是 ‘MANAGER’ 和 ‘SALESMAN’ 的员工</p>\n<pre><code>\n第一种方法：or\n第二种方法：in\n第三种方法：union\nselect ename from emp where job = 'MANAGER'\nunion\nselect ename from emp where job = 'SALESMAN';\n\n</code></pre>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意：</h2>\n<p>在使用 union 需要注意：<br>\n1.  union 在结果集合并的时候，要求两个结果列数相同。<br>\n2.  MYSQL 中，对应列的数据类型可以不相同，Oracle 里会报错（会要求对应列的数据类型相同）。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/",
            "title": "Mysql中Distinct去重",
            "date_published": "2024-02-18T08:13:44.971Z",
            "content_html": "<h1 id=\"distinct-去重\"><a class=\"markdownIt-Anchor\" href=\"#distinct-去重\">#</a> Distinct 去重</h1>\n<p>把查询结果去除重复记录</p>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<ol>\n<li>distinct 只能出现在所有字段的最前方。<br>\nselect name, distinct job from emp;// 错误<br>\n select distinct name, job from emp;// 正确<br>\n这样表示对 name 和 job 组合起来进行去重。</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql连接查询",
            "date_published": "2024-02-18T08:13:44.971Z",
            "content_html": "<h1 id=\"什么是连接查询\"><a class=\"markdownIt-Anchor\" href=\"#什么是连接查询\">#</a> 什么是连接查询</h1>\n<pre><code>从一张表中单独查询，称为单表查询。\nemp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，称为连接查询。\n</code></pre>\n<h1 id=\"连接查询分类\"><a class=\"markdownIt-Anchor\" href=\"#连接查询分类\">#</a> 连接查询分类</h1>\n<pre><code>根据语法的年代分类：\n    1.  SQL92：1992年出现的语法。\n    2.  SQL99：1999年出现的语法。\n\n根据表连接的方式分类：\n    1. 内连接\n       1. 等值连接\n       2. 非等值连接\n       3. 自连接\n    2. 外连接\n       1. 左外连接（左连接）\n       2. 右外连接（右连接）\n    3. 全连接\n</code></pre>\n<h1 id=\"笛卡尔积现象\"><a class=\"markdownIt-Anchor\" href=\"#笛卡尔积现象\">#</a> 笛卡尔积现象</h1>\n<pre><code>当两张表进行连接查询，没有任何条件限制的时候，最终的查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。（一个数学现象）\n</code></pre>\n<pre><code>\n     select up.id uId, qd.id qId from user_profile up, question_detail qd;\n\n    +-----+-----+\n    | uId | qId |\n    +-----+-----+\n    |   7 |   1 |\n    |   6 |   1 |\n    |   5 |   1 |\n    |   4 |   1 |\n    |   3 |   1 |\n    |   2 |   1 |\n    |   1 |   1 |\n    |   7 |   2 |\n    ...\n     112 rows in set (0.00 sec)\n\n</code></pre>\n<h2 id=\"避免笛卡尔积现象\"><a class=\"markdownIt-Anchor\" href=\"#避免笛卡尔积现象\">#</a> 避免笛卡尔积现象</h2>\n<pre><code>增加表连接时的条件。\n</code></pre>\n<pre><code>\n    select up.id uId, qpd.id qId from user_profile up,  question_practice_detail qpd where up.device_id = qpd.device_id;\n\n    +-----+-----+\n    | uId | qId |\n    +-----+-----+\n    |   1 |   1 |\n    |   2 |   2 |\n    |   2 |   3 |\n    |   3 |   4 |\n    |   4 |   5 |\n    |   4 |   6 |\n    |   4 |   7 |\n    |   2 |   8 |\n    |   2 |   9 |\n    |   3 |  10 |\n    |   4 |  11 |\n    |   4 |  12 |\n    |   4 |  13 |\n    |   2 |  14 |\n    |   2 |  15 |\n    |   3 |  16 |\n    +-----+-----+\n    16 rows in set (0.00 sec)\n\n</code></pre>\n<pre><code>重点：最终查询结果是16条，但是在匹配中，匹配的次数没有减少，仍然是112次。只不过进行了筛除，匹配的次数并没有减少！！！\n</code></pre>\n<p>注意：通过观察笛卡尔积现场得出，表的连接次数越多（连接的表越多）程序执行效率越低，应避免表的连接次数过多。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/2.%E5%86%85%E8%BF%9E%E6%8E%A5/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/2.%E5%86%85%E8%BF%9E%E6%8E%A5/",
            "title": "Mysql内连接",
            "date_published": "2024-02-18T08:13:44.971Z",
            "content_html": "<h1 id=\"内连接\"><a class=\"markdownIt-Anchor\" href=\"#内连接\">#</a> 内连接</h1>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<pre><code>完全能够匹配上这个条件的数据查询出来。\nA，B两张表连接查询，AB两张表没有主次关系，是平等的。\n</code></pre>\n<h2 id=\"等值连接\"><a class=\"markdownIt-Anchor\" href=\"#等值连接\">#</a> 等值连接</h2>\n<pre><code>\nSQL92语法：\n\nselect up.id uId, qpd.id qId from user_profile up, question_practice_detail qpd where up.device_id = qpd.device_id;\n\nSQL99语法：\n                                                  [inner] 单词可以省略\nselect up.id uId, qpd.id qId from user_profile up [inner] join question_practice_detail qpd on up.device_id = qpd.device_id;\n\n</code></pre>\n<p>SQL92 语法缺点：结构不清晰，表的连接条件和后期进一步的筛选条件，都放到了 where 后边。</p>\n<p>SQL99 语法有点：表连接的条件是独立的，连接之后如果还需要进一步筛选，可以继续添加 where 条件。</p>\n<h2 id=\"非等值连接\"><a class=\"markdownIt-Anchor\" href=\"#非等值连接\">#</a> 非等值连接</h2>\n<pre><code>条件不是一个等量关系，称为非等值连接\n</code></pre>\n<pre><code>\n案例：找出每个员工的薪资等级，要求显示员工名，薪资，薪资等级\n\n    select \n        e.ename, e.sal, s.grade \n    from\n        emp e\n    inner join \n        salgrade s\n    on \n        e.sal between s.losal and s.hisal;\n\n</code></pre>\n<h2 id=\"自连接\"><a class=\"markdownIt-Anchor\" href=\"#自连接\">#</a> 自连接</h2>\n<pre><code>一张表看作两张表\n</code></pre>\n<pre><code>\n案例：查询员工的上级领导，要求显示员工名和对应的领导名\n    select \n        a.ename as '员工名', b.ename as '领导名'\n    from\n        emp a \n    inner join\n        emp b\n    on\n        a.mgr = b.empno;\n\n\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/",
            "title": "数据库概念",
            "date_published": "2024-02-18T08:13:44.962Z",
            "content_html": "<h1 id=\"数据库\"><a class=\"markdownIt-Anchor\" href=\"#数据库\">#</a> 数据库</h1>\n<h2 id=\"关系型数据库是如何工作的\"><a class=\"markdownIt-Anchor\" href=\"#关系型数据库是如何工作的\">#</a> 关系型数据库是如何工作的</h2>\n<h3 id=\"从数据结构说起\"><a class=\"markdownIt-Anchor\" href=\"#从数据结构说起\">#</a> 从数据结构说起</h3>\n<h4 id=\"时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度\">#</a> 时间复杂度</h4>\n<p>​\t对于数据库而言，重要的不是数据量，而是当数据量增加时运算如何增加。</p>\n<p>​\t时间复杂度用来检验某个算法处理一定量的数据要花费多长时间，时间复杂度不会给出确切的运算次数，但是给出的是一种观念。 <img data-src=\"https://pdai.tech/images/db/sb-sql-learn-1.png\" alt=\"img\"></p>\n<h4 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\">#</a> 归并排序</h4>\n<h4 id=\"二叉搜索树\"><a class=\"markdownIt-Anchor\" href=\"#二叉搜索树\">#</a> 二叉搜索树</h4>\n<p>​\t二叉搜索树只需要 Log (N) 次运算，而如果你直接使用阵列则需要 N 次运算。</p>\n<h4 id=\"b树索引\"><a class=\"markdownIt-Anchor\" href=\"#b树索引\">#</a> B + 树索引</h4>\n<h4 id=\"哈希表\"><a class=\"markdownIt-Anchor\" href=\"#哈希表\">#</a> 哈希表</h4>\n<p>​\t为什么不使用阵列？</p>\n<ul>\n<li>如果有了更好的哈希函数，在哈希表里搜索的时间复杂度就是 O (1)。</li>\n<li>一个哈希表可以只装载一半到内存，剩下的哈希捅可以留在硬盘上。</li>\n<li>用列阵的话，你需要一个连续的内存空间，如果你加载一张大表，很难分配足够的连续的内存空间。</li>\n</ul>\n<h2 id=\"关系型数据库设计理论\"><a class=\"markdownIt-Anchor\" href=\"#关系型数据库设计理论\">#</a> 关系型数据库设计理论</h2>\n<h3 id=\"重要术语\"><a class=\"markdownIt-Anchor\" href=\"#重要术语\">#</a> 重要术语</h3>\n<ul>\n<li>属性：列的名字。</li>\n<li>依赖：列属性间存在的某种联系。</li>\n<li>元组：每一个行（每一条数据）。</li>\n<li>表：由多个属性，以及众多元组组成。</li>\n<li>模式：这里我们指逻辑结构。</li>\n<li>域：数据类型。</li>\n<li>键：由关系的一个或多个属性组成，任意两个键相同的元组，所有属性都相同。需要保证表示键的属性最少。一个关系可以存在好几种键，一般从这些候选键中，选出一个作为主键（primary key）。</li>\n<li>候选键：由关系的一个或多个属性组成，候选键都具备键的特性，都有资格成为主键。</li>\n<li>超键：包含键的属性集合，无需保证属性集的最小化。每个键也是超键。可以认为是超键的超集。</li>\n<li>外键：如果某一个关系 A 中的一个（组）属性是另一个关系 B 的键，则该（组）属性在 A 中成为外键。</li>\n<li>主属性：所有候选键所包含的属性都是主属性。</li>\n<li>投影：选取特定的列，如将关系学生信息投影为学号、姓名，即得到上表中仅包含学号、姓名的列。</li>\n<li>选择：按照一定条件选取特定元组，如选择上表中分数 &gt; 80 的元组。</li>\n<li>笛卡尔积（交叉连接）：第一个关系每一行分别与第二个关系的每一行组合。</li>\n<li>自然连接：第一个关系中每一行与第二个关系的每一行进行匹配，如果得到有交叉部分则合并，若无交叉部分则舍弃。</li>\n<li>连接：即加上约束条件的笛卡尔积，先得到笛卡尔积，然后根据约束条件删除不满足的元组。</li>\n<li>外连接：执行自然连接后，将舍弃的部分也加入，并且匹配失败处的属性用 Null 代替。</li>\n<li>除法运算：关系 R 除以关系 S 的结果为 T，则 T 包含所有在 R 但不在 S 的属性，且 T 的元组与 S 的元组的所有组合在 R 中。</li>\n</ul>\n<h2 id=\"数据库系统核心知识点\"><a class=\"markdownIt-Anchor\" href=\"#数据库系统核心知识点\">#</a> 数据库系统核心知识点</h2>\n<h3 id=\"事务\"><a class=\"markdownIt-Anchor\" href=\"#事务\">#</a> 事务</h3>\n<h4 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h4>\n<p>​\t事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以用 Rollback 进行回滚。 <img data-src=\"https://pdai.tech/images/pics/185b9c49-4c13-4241-a848-fbff85c03a64.png\" alt=\"image\"></p>\n<h4 id=\"acid\"><a class=\"markdownIt-Anchor\" href=\"#acid\">#</a> ACID</h4>\n<ul>\n<li><strong>原子性 (Atomicity)</strong>：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>\n<li><strong>一致性 (Consistency)</strong>：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>\n<li><strong>隔离性 (lsolation)</strong>：一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>\n<li><strong>持久性 (Durability)</strong>：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份数据库进行数据恢复。</li>\n</ul>\n<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系:</p>\n<ul>\n<li>只有满足一致性，事务的执行结果才是正确的。</li>\n<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>\n<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>\n<li>事务满足持久化是为了能应对数据库崩溃的情况。 <img data-src=\"https://pdai.tech/images/pics/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png\" alt=\"image\"></li>\n</ul>\n<h4 id=\"autocommit\"><a class=\"markdownIt-Anchor\" href=\"#autocommit\">#</a> AUTOCOMMIT</h4>\n<p>​\tmysql 默认采用自动提交模式。如果不显示使用 start transaction 语句来开始一个事务，那么每个查询都会被当作一个事务自动提交。</p>\n<h3 id=\"并发一致性问题\"><a class=\"markdownIt-Anchor\" href=\"#并发一致性问题\">#</a> 并发一致性问题</h3>\n<p>​\t在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>\n<h4 id=\"丢失修改\"><a class=\"markdownIt-Anchor\" href=\"#丢失修改\">#</a> 丢失修改</h4>\n<p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>\n<h4 id=\"读脏数据\"><a class=\"markdownIt-Anchor\" href=\"#读脏数据\">#</a> 读脏数据</h4>\n<p>T1 修改了一个数据，T2 随后读取了这个数据。如果 T1 撤销了修改，那么 T2 读取的是脏数据。</p>\n<h4 id=\"不可重复读\"><a class=\"markdownIt-Anchor\" href=\"#不可重复读\">#</a> 不可重复读</h4>\n<p>T2 读取了一个数据，T1 对该数据做了修改。如果 T2 再次读取了这个数据，此时读取的数据和第一次读取的数据结果不同。</p>\n<h4 id=\"幻影读\"><a class=\"markdownIt-Anchor\" href=\"#幻影读\">#</a> 幻影读</h4>\n<p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。</p>\n<p><strong>产生并发不一致问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己操作，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</strong></p>\n<h3 id=\"封锁\"><a class=\"markdownIt-Anchor\" href=\"#封锁\">#</a> 封锁</h3>\n<h4 id=\"封锁粒度\"><a class=\"markdownIt-Anchor\" href=\"#封锁粒度\">#</a> 封锁粒度</h4>\n<p>Mysql 中提供了两种封锁粒度：行级锁以及表级锁。</p>\n<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的粒度越小，发生锁争用的可能性就越小，系统的并发程度就越高。</p>\n<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销越大。</p>\n<p><strong>在选择锁粒度时，需要在锁开销和并发程度之间做一个权衡</strong></p>\n<h4 id=\"封锁类型\"><a class=\"markdownIt-Anchor\" href=\"#封锁类型\">#</a> 封锁类型</h4>\n<pre><code>##### 读写锁\n</code></pre>\n<ul>\n<li>\n<p>排它锁（Exclusive）：简写为 X 锁，又称写锁。</p>\n</li>\n<li>\n<p>共享锁（Shared）：简写为 S 锁，又称读锁。</p>\n<p>有一下两个规定：</p>\n<ul>\n<li>​\t一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间，其他事务不能对 A 加任何锁。</li>\n<li>​    一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取，但不能进行更新操作。加锁期间其他事务只能对 A 加 S 锁，但不能加 X 锁。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"意向锁\"><a class=\"markdownIt-Anchor\" href=\"#意向锁\">#</a> 意向锁</h5>\n<p>​\t使用意向锁可以更容易地支持多粒度封锁。</p>\n<p>​\t存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其他事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>\n<p>​\t意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中某个数据行上加上 X 锁或 S 锁。有一下两个规定：</p>\n<ul>\n<li>\n<p>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁。</p>\n</li>\n<li>\n<p>一个事务在获取某个数据行对象的 X 锁之前，必须先获取表的 X 锁。</p>\n<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其他事务正在使用这个表或者表中的某一行的锁，因此事务 T 加锁失败。</p>\n<p>各种锁的兼容关系如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">-</th>\n<th style=\"text-align:center\">X</th>\n<th style=\"text-align:center\">IX</th>\n<th style=\"text-align:center\">S</th>\n<th style=\"text-align:center\">IS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">X</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IX</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IS</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n</tbody>\n</table>\n<p>解释如下：</p>\n<ul>\n<li>\n<p>​\t任意 IS/IX 锁之间都是兼容的，因为他们只是表示想要对表加锁，而不是正真的加锁。</p>\n</li>\n<li>\n<p>​    S 锁只与 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其他事务可以已经获得对表或者对表中行的 S 锁。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"封锁协议\"><a class=\"markdownIt-Anchor\" href=\"#封锁协议\">#</a> 封锁协议</h3>\n<h4 id=\"三级锁协议\"><a class=\"markdownIt-Anchor\" href=\"#三级锁协议\">#</a> 三级锁协议</h4>\n<h5 id=\"一级锁协议\"><a class=\"markdownIt-Anchor\" href=\"#一级锁协议\">#</a> 一级锁协议</h5>\n<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束猜释放锁。</p>\n<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>\n<h5 id=\"二级锁协议\"><a class=\"markdownIt-Anchor\" href=\"#二级锁协议\">#</a> 二级锁协议</h5>\n<p>在一级的基础上，要求读取数据 A 时，必须加上 S 锁，读取完马上释放 S 锁。</p>\n<p>可以解决数据脏读问题。因为一个事务在对数据 A 进行修改，根据一级协议，必须加 X 锁，那么就不能再加 S 锁了，也就不会读入数据了。</p>\n<h5 id=\"三级封锁协议\"><a class=\"markdownIt-Anchor\" href=\"#三级封锁协议\">#</a> 三级封锁协议</h5>\n<p>在二级的基础上，要求读取数据 A 时必须加上 S 锁，直到事务结束才释放 S 锁。</p>\n<p>可以解决不可重复度问题，因为读 A 时，其他事务不能加 X 锁，从而避免了在读数据期间数据发生改变。</p>\n<h4 id=\"两段锁协议\"><a class=\"markdownIt-Anchor\" href=\"#两段锁协议\">#</a> 两段锁协议</h4>\n<p>​\t加锁和解锁分两个阶段进行。</p>\n<p>​\t可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>\n<p>​\t<strong>事务遵循两段锁协议是保证可串行化调度的充分条件</strong></p>\n<h3 id=\"mysql-隐式与显式锁定\"><a class=\"markdownIt-Anchor\" href=\"#mysql-隐式与显式锁定\">#</a> Mysql 隐式与显式锁定</h3>\n<p>Mysql 的 InnoDB 存储引擎采用的是两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有锁都是在同一时刻被释放，这被称为隐式锁定。</p>\n<p>InnoDB 也可以使用特定的语句进行显示锁定。</p>\n<pre><code class=\"language-mysql\">select ...... LOCK In SHARE MODE;\nselect ...... FOR UPDATE;\n</code></pre>\n<h3 id=\"隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#隔离级别\">#</a> 隔离级别</h3>\n<h4 id=\"未提交读read-uncommited\"><a class=\"markdownIt-Anchor\" href=\"#未提交读read-uncommited\">#</a> 未提交读（READ UNCOMMITED)</h4>\n<p>事务中的修改，即使没有提交，对其他事务也是可见的。</p>\n<h4 id=\"提交读read-commited\"><a class=\"markdownIt-Anchor\" href=\"#提交读read-commited\">#</a> 提交读（READ COMMITED)</h4>\n<p>一个事务只能读取已经提交的事务所作的修改。换个话说，一个事务所做的修改，在提交之前，对其他事务都是不可见的。</p>\n<h4 id=\"可重复读repeatable-read\"><a class=\"markdownIt-Anchor\" href=\"#可重复读repeatable-read\">#</a> 可重复读（REPEATABLE READ)</h4>\n<p>保证在同一个事务中多次读取同样的数据结果是一样的。</p>\n<h4 id=\"可串行化serializable\"><a class=\"markdownIt-Anchor\" href=\"#可串行化serializable\">#</a> 可串行化（SERIALIZABLE)</h4>\n<p>强制事务串行执行。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻影读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">未提交读</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">提交读</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可重复读</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可串行化</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"多版本并发控制\"><a class=\"markdownIt-Anchor\" href=\"#多版本并发控制\">#</a> 多版本并发控制</h3>\n<p>多版本并发控制 (Multi-Version Concurrency Control, MVCC) 是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>\n<h3 id=\"版本号\"><a class=\"markdownIt-Anchor\" href=\"#版本号\">#</a> 版本号</h3>\n<ul>\n<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>\n<li>事务版本号：事务开始时的系统版本号。</li>\n</ul>\n<h3 id=\"隐藏的列\"><a class=\"markdownIt-Anchor\" href=\"#隐藏的列\">#</a> 隐藏的列</h3>\n<p>MVCC 在每行记录后边都保存着两个隐藏的列，用来存储两个版本号。</p>\n<ul>\n<li>创建版本号：指示创建一个数据行的快照时的系统版本号。</li>\n<li>删除版本号如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示快照已经把欸删除了。</li>\n</ul>\n<h3 id=\"undo-日志\"><a class=\"markdownIt-Anchor\" href=\"#undo-日志\">#</a> Undo 日志</h3>\n<p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行 (Record) 的所有快照连接起来。</p>\n<p><img data-src=\"https://pdai.tech/images/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg\" alt=\"image\"></p>\n<h3 id=\"实现过程\"><a class=\"markdownIt-Anchor\" href=\"#实现过程\">#</a> 实现过程</h3>\n<p>以下实现过程针对可重复读隔离级别。</p>\n<p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p>\n<h4 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> <a href=\"#_1-select\">#</a> 1. SELECT</h4>\n<p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>\n<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>\n<h4 id=\"-2\"><a class=\"markdownIt-Anchor\" href=\"#-2\">#</a> <a href=\"#_2-insert\">#</a> 2. INSERT</h4>\n<p>将当前系统版本号作为数据行快照的创建版本号。</p>\n<h4 id=\"-3\"><a class=\"markdownIt-Anchor\" href=\"#-3\">#</a> <a href=\"#_3-delete\">#</a> 3. DELETE</h4>\n<p>将当前系统版本号作为数据行快照的删除版本号。</p>\n<h4 id=\"-4\"><a class=\"markdownIt-Anchor\" href=\"#-4\">#</a> <a href=\"#_4-update\">#</a> 4. UPDATE</h4>\n<p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>\n<h3 id=\"-5\"><a class=\"markdownIt-Anchor\" href=\"#-5\">#</a> <a href=\"#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB\">#</a> 快照读与当前读</h3>\n<h4 id=\"-6\"><a class=\"markdownIt-Anchor\" href=\"#-6\">#</a> <a href=\"#_1-%E5%BF%AB%E7%85%A7%E8%AF%BB\">#</a> 1. 快照读</h4>\n<p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"-7\"><a class=\"markdownIt-Anchor\" href=\"#-7\">#</a> <a href=\"#_2-%E5%BD%93%E5%89%8D%E8%AF%BB\">#</a> 2. 当前读</h4>\n<p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> ? <span class=\"token keyword\">lock</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">share</span> <span class=\"token keyword\">mode</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> ? <span class=\"token keyword\">for</span> <span class=\"token keyword\">update</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">insert</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">update</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"六-next-key-locks\"><a class=\"markdownIt-Anchor\" href=\"#六-next-key-locks\">#</a> 六、Next-Key Locks</h3>\n<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>\n<p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读 (REPEATABLE READ) 隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>\n<h4 id=\"-8\"><a class=\"markdownIt-Anchor\" href=\"#-8\">#</a> <a href=\"#record-locks\">#</a> Record Locks</h4>\n<p>锁定一个记录上的索引，而不是记录本身。</p>\n<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>\n<h4 id=\"-9\"><a class=\"markdownIt-Anchor\" href=\"#-9\">#</a> <a href=\"#gap-locks\">#</a> Gap Locks</h4>\n<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> c <span class=\"token keyword\">FROM</span> t <span class=\"token keyword\">WHERE</span> c <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">10</span> <span class=\"token operator\">and</span> <span class=\"token number\">20</span> <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"-10\"><a class=\"markdownIt-Anchor\" href=\"#-10\">#</a> <a href=\"#next-key-locks\">#</a> Next-Key Locks</h4>\n<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。</p>\n",
            "tags": [
                "Sql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/10.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/10.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/",
            "title": "Mysql执行顺序",
            "date_published": "2024-02-18T08:13:44.962Z",
            "content_html": "<h1 id=\"执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#执行顺序\">#</a> 执行顺序</h1>\n<pre><code>select\n    ...\nfrom \n    ...\nwhere\n    ...\ngroup by\n    ...\nhaving\n    ...\norder by\n    ...\n\n执行顺序：\n1.  from\n2.  where\n3.  group by\n4.  having\n5.  select\n6.  order by\n</code></pre>\n<p>从某张表查询数据，<br>\n先经过 where 条件筛选出有价值的数据，<br>\n对这些数据进行分组，<br>\n分组后可以使用 having 继续筛选数据<br>\n select 查询出来<br>\n最后排序输出</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/",
            "title": "Mysql概述",
            "date_published": "2024-02-18T08:13:44.962Z",
            "content_html": "<p>1. 什么是数据库？什么是数据库管理系统？什么是 SQL？他们之间的关系是什么？</p>\n<p>​\t数据库：</p>\n<p>​\t\t英文单词 DataBase，简称 DB。按照一定格式存储数据的一些文件的组合。</p>\n<p>​\t\t顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</p>\n<p>​\t数据库管理系统：</p>\n<p>​\t\tDataBaseManagement，简称 DBMS。</p>\n<p>​\t\t数据库管理系统是专门用来管理数据库中的数据，数据库管理系统可以对数据库当中的数据进行增删改查。</p>\n<p>​\t常见的数据库管理系统：</p>\n<p>​\t\tMysql，Oracle，MS，SqlServer，DB2，sybase 等。。。。。。</p>\n<p>​\tSQL:</p>\n<p>​\t\t结构化查询语言。程序员需要学习 SQL 语句，程序员通过编写 SQL 语句，然后 DBMS 负责执行 SQL 语句，最终来完成数据库中数据的增删改查操作。</p>\n<p>​\t\tSQL 是一套标准，主要学习的就是 SQL 语句。这个 SQL 在 mysql 中可以使用，同时在 Oracle 中也可以使用，在 DB2 中也可以使用。</p>\n<p>​\t三者之间的关系：</p>\n<p>​\t\tDBMS–&gt; 执行–&gt;SQL–&gt; 操作–&gt;DB</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Maven/%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0%E6%A0%87%E7%AD%BE/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Maven/%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0%E6%A0%87%E7%AD%BE/",
            "title": "常用元素标签",
            "date_published": "2024-02-18T08:13:44.954Z",
            "content_html": "<h1 id=\"pomxml常用元素介绍\"><a class=\"markdownIt-Anchor\" href=\"#pomxml常用元素介绍\">#</a> pom.xml 常用元素介绍</h1>\n<ul>\n<li>project 包含 pom 一些约束的信息</li>\n<li>modelVersion 指定当前 pom 的版本</li>\n<li>groupId（主项目标示，定义当前 maven 属于哪个项目，- 反写公司网址 + 项目名）、</li>\n<li>artifactId（实际项目模块标识，项目名 + 模块名）、</li>\n<li>version（当前项目版本号，第一个 0 标识大版本号，第 - 二个 0 标示分支版本号，第三个 0 标识小版本号，0.0.1，- snapshot 快照，alpha 内部测试，beta 公测，release 稳 - 定，GA 正式发布）</li>\n<li>name 项目描述名</li>\n<li>url 项目地址</li>\n<li>description 项目描述</li>\n<li>developers 开发人员列表</li>\n<li>licenses 许可证</li>\n<li>organization：组织</li>\n<li>dependencies：依赖列表</li>\n<li>dependency：依赖项目 里面放置坐标</li>\n<li>scope：包的依赖范围 test</li>\n<li>optional ：设置依赖是否可选</li>\n<li>exclusions：排除依赖传递列表</li>\n<li>dependencyManagement 依赖的管理</li>\n<li>build：为构建行为提供支持</li>\n<li>plugins：插件列表</li>\n<li>parent：子模块对父模块的继承</li>\n<li>modules：聚合多个 maven 项目</li>\n</ul>\n",
            "tags": [
                "maven"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Maven/scope%E6%A0%87%E7%AD%BE/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Maven/scope%E6%A0%87%E7%AD%BE/",
            "title": "scope标签的作用",
            "date_published": "2024-02-18T08:13:44.954Z",
            "content_html": "<h1 id=\"scope的作用\"><a class=\"markdownIt-Anchor\" href=\"#scope的作用\">#</a> Scope 的作用</h1>\n<p>概述：</p>\n<blockquote>\n<p>Maven 中使用 scope 来指定当前包的依赖范围和依赖的传递性。常见的可选值有: complie、provide、runtime、test、system 等</p>\n</blockquote>\n<pre><code class=\"language-maven\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n            &lt;version&gt;3.2.1.RELEASE&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<h2 id=\"scope取值\"><a class=\"markdownIt-Anchor\" href=\"#scope取值\">#</a> scope 取值</h2>\n<ul>\n<li>complie\n<ul>\n<li>范围：all</li>\n<li>依赖传递：是</li>\n<li>例子：spring-core</li>\n<li>详解：complie 为默认的依赖有效范围。如果没有明确指定依赖有效范围的花，则默认采用该值。在编译、运行、测试时均有效</li>\n</ul>\n</li>\n<li>provided\n<ul>\n<li>范围：complie、test</li>\n<li>依赖传递：否</li>\n<li>例子：servlet-api</li>\n<li>详解：provided 在编译、测试时有效，但是在运行时无效。例如 servlet-api 依赖，在部署到 tomcat 服务器中，容器已经提供了，就不再需要 maven 重复引入了</li>\n</ul>\n</li>\n<li>runtime\n<ul>\n<li>范围：runtime、test</li>\n<li>依赖传递：是</li>\n<li>例子：JDBC 驱动</li>\n<li>详解：runtime 在运行、测试时有效，但是在编译时无效。例如 JDBC 的驱动实现</li>\n</ul>\n</li>\n<li>test\n<ul>\n<li>范围：test</li>\n<li>依赖传递：否</li>\n<li>例子：JUnit</li>\n<li>详解：只在测试时有效，例如 Junit</li>\n</ul>\n</li>\n<li>system\n<ul>\n<li>范围：complie、test</li>\n<li>依赖传递：是</li>\n<li>例子：</li>\n<li>详解：system 在编译、测试时有效，但是在运行时无效。与 provided 的区别是，使用 system 范围依赖时，必须通过 systemPath 元素显示指定依赖文件的路径。此依赖时通过本机绑定的，不可移植使用，因此要谨慎使用。systemPath 元素可以引用环境变量。例如：<pre><code class=\"language-maven\">        &lt;dependency&gt;\n            &lt;groupId&gt;javax.sql&lt;/groupId&gt;\n            &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt;\n            &lt;version&gt;2.0&lt;/version&gt;\n            &lt;scope&gt;system&lt;/scope&gt;\n            &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;\n        &lt;/dependency&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>在编译或者是运行时有效的范围依赖，在打包时会一起打包</p>\n",
            "tags": [
                "maven"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/",
            "title": "Mysql实用技巧",
            "date_published": "2024-02-18T08:13:44.954Z",
            "content_html": "<h2 id=\"在sql中的应用\"><a class=\"markdownIt-Anchor\" href=\"#在sql中的应用\">#</a> @ 在 sql 中的应用</h2>\n<p>@ 是用户变量， @@ 是系统变量</p>\n<pre><code>select @a;\n</code></pre>\n<p>@变量名：定义一个用户变量</p>\n<p>= 对该用户变量进行赋值<br>\n用户变量的赋值有两种方式：</p>\n<ol>\n<li>直接使用 =</li>\n<li>使用 :=<br>\n 区别在于：使用 set 命令对用户变量进行赋值时，两种方式都适用，<br>\n使用 select 语句时，只能使用 ‘:=’ 方式，因为 select 语句中， '=' 被看作时比较操作符<br>\n (@i := @i + 1)</li>\n</ol>\n<h3 id=\"常量-的用法\"><a class=\"markdownIt-Anchor\" href=\"#常量-的用法\">#</a> 常量 @ 的用法</h3>\n<ol>\n<li>\n<p>赋值操作<br>\n select @i := 0 a, @c := 1 b, @b := @i + @c f;<br>\n<img data-src=\"/image/%E5%90%8E%E7%AB%AF/Mysql/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240126185135.png\" alt=\"赋值操作\"></p>\n</li>\n<li>\n<p>作为临时表使用<br>\n select *, (select @i := 0 s1) z1 from admin,(select @i := 0 s2) z2;<br>\n<img data-src=\"/image/%E5%90%8E%E7%AB%AF/Mysql/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240126185503.png\" alt=\"作为临时表使用\"></p>\n</li>\n<li>\n<p>数据累计计算<br>\n select *, (@i := @i + 1) as i from user,(select @i := 0) t;<br>\n<img data-src=\"/image/%E5%90%8E%E7%AB%AF/Mysql/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240126185916.png\" alt=\"数据累计计算\"><br>\n每行的行号通过 @i 展示了出来</p>\n</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%B0%B1/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%B0%B1/",
            "title": "图谱",
            "date_published": "2024-02-18T08:13:44.946Z",
            "content_html": "<h1 id=\"知识体系\"><a class=\"markdownIt-Anchor\" href=\"#知识体系\">#</a> 知识体系</h1>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/java_basic.png\" alt=\"Java基础知识体系\"></p>\n<h1 id=\"qa\"><a class=\"markdownIt-Anchor\" href=\"#qa\">#</a> Q&amp;A</h1>\n<h3 id=\"java中应该使用什么数据类型来代表价格\"><a class=\"markdownIt-Anchor\" href=\"#java中应该使用什么数据类型来代表价格\">#</a> Java 中应该使用什么数据类型来代表价格</h3>\n<p>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的 double 类型。</p>\n<h3 id=\"怎么将byte转换为string\"><a class=\"markdownIt-Anchor\" href=\"#怎么将byte转换为string\">#</a> 怎么将 byte 转换为 String</h3>\n<p>可以使用 String 接收 byte [] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同</p>\n<h3 id=\"java中怎样将bytes转换为long类型\"><a class=\"markdownIt-Anchor\" href=\"#java中怎样将bytes转换为long类型\">#</a> Java 中怎样将 Bytes 转换为 long 类型</h3>\n<p>String 接收 bytes 的构造器转成 String，再 Long.parseLong</p>\n<h3 id=\"可以将int强制转换为byte类型的变量吗如果该值大于byte类型的范围将会出现什么现象\"><a class=\"markdownIt-Anchor\" href=\"#可以将int强制转换为byte类型的变量吗如果该值大于byte类型的范围将会出现什么现象\">#</a> 可以将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象</h3>\n<p>可以做强制转换，但是 java 中 int 是 32 位的，而 byte 是 8 位的，所以如果强制转换是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 - 128 到 127</p>\n<h3 id=\"存在两个类b继承ac继承b我们能将b转换位c么\"><a class=\"markdownIt-Anchor\" href=\"#存在两个类b继承ac继承b我们能将b转换位c么\">#</a> 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换位 C 么</h3>\n<p>可以，向下转型，但是不建议使用，容易出现类型转换异常</p>\n<h3 id=\"那个类包含clone方法是cloneable还是object\"><a class=\"markdownIt-Anchor\" href=\"#那个类包含clone方法是cloneable还是object\">#</a> 那个类包含 Clone 方法？是 Cloneable 还是 Object</h3>\n<p>java.lang.Cloneable 是一个标识性接口，不包含任何方法，clone 方法在 Object 类中定义，并且需要知道 clone () 方法是一个本地方法，这意味着它是由 C 或 c++ 或其他本地语言实现的</p>\n<h3 id=\"java中-操作符是线程安全的吗\"><a class=\"markdownIt-Anchor\" href=\"#java中-操作符是线程安全的吗\">#</a> Java 中 ++ 操作符是线程安全的吗？</h3>\n<p>不是线程安全的操作，它设计到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交叉，还会存在竞态条件 (读取 - 修改 - 写入)</p>\n<h3 id=\"a-a-b-和-a-b的区别\"><a class=\"markdownIt-Anchor\" href=\"#a-a-b-和-a-b的区别\">#</a> a = a + b 和 a += b 的区别</h3>\n<p>+= 隐士的将加的操作结果类型强制转换位持有结果的类型，如果两个整形相加，如 byte、short、或者 int，首先会将它们提升到 int 类型，然后再执行加法的操作</p>\n<pre><code class=\"language-Java\">byte a = 127;\nbyte b = 127;\nb = a+b; // error: cannot conver from int to byte\nb += a; // ok\n</code></pre>\n<p>因为 a+b 的操作会将 a、b 提升位 int 类型，所有将 int 类型的值赋给 byte 就会编译报错</p>\n<h3 id=\"我能在不进行强制转换的情况下将一个double值赋给long类型的变量吗\"><a class=\"markdownIt-Anchor\" href=\"#我能在不进行强制转换的情况下将一个double值赋给long类型的变量吗\">#</a> 我能在不进行强制转换的情况下，将一个 double 值赋给 long 类型的变量吗？</h3>\n<p>不行，double 类型的精度比 long 更广，所以必须进行强制转换</p>\n<h3 id=\"301-03-将会返回true还是false\"><a class=\"markdownIt-Anchor\" href=\"#301-03-将会返回true还是false\">#</a> 3*0.1 == 0.3 将会返回 true 还是 false？</h3>\n<p>false，因为有些浮点数不能完全精确的表示出来</p>\n<pre><code class=\"language-Java\">        System.out.println( 3*0.1);\n        System.out.println( 3*0.1 == 0.3);\n\n        结果：\n        0.30000000000000004\n        false\n</code></pre>\n<h3 id=\"int和integer那个会更占内存\"><a class=\"markdownIt-Anchor\" href=\"#int和integer那个会更占内存\">#</a> int 和 Integer 那个会更占内存？</h3>\n<p>Integer 对象会占用内存多一些，Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始数据类型，所以占用的空间更少</p>\n<h3 id=\"为什么java中string是不可变的immutable\"><a class=\"markdownIt-Anchor\" href=\"#为什么java中string是不可变的immutable\">#</a> 为什么 Java 中 String 是不可变的 (immutable)?</h3>\n<p>Java 中的 String 不可变是因为 Java 的设计者认为字符串的使用非常频繁，将字符设置位不可变可以允许多个客户端之间共享相同的字符串</p>\n<h3 id=\"能在switch中只用string吗\"><a class=\"markdownIt-Anchor\" href=\"#能在switch中只用string吗\">#</a> 能在 switch 中只用 String 吗</h3>\n<p>从 Java7 开始，可以在 switch case 中使用字符串，但是这仅仅是一个语法糖，内部实现是在 switch 中使用字符串的 hash code</p>\n<h3 id=\"java中的构造器链是什么\"><a class=\"markdownIt-Anchor\" href=\"#java中的构造器链是什么\">#</a> Java 中的构造器链是什么？</h3>\n<p>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现</p>\n<h3 id=\"枚举类\"><a class=\"markdownIt-Anchor\" href=\"#枚举类\">#</a> 枚举类</h3>\n<p>Java1.5 出现，每个枚举类值都需要调用一次构造函数</p>\n<h3 id=\"什么是不可变对象immutable-objectjava中怎么创建一个不可变对象\"><a class=\"markdownIt-Anchor\" href=\"#什么是不可变对象immutable-objectjava中怎么创建一个不可变对象\">#</a> 什么是不可变对象 (immutable object)？Java 中怎么创建一个不可变对象？</h3>\n<p>不可变对象指对象一旦被创建，状态不能再改变，任何修改都会创建一个新对象，如 String、Integer 及其他包装类。</p>\n<p>如何再 Java 中写出 immutable 的类？</p>\n<ol>\n<li>immutable 对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象</li>\n<li>immutable 类的所有属性都应该是 final 的</li>\n<li>对象必须被正确的创建，比如：对象引用在对象创建的过程中不能泄露 (leak)</li>\n<li>对象应该是 final 的，一次来限制子类继承父类，以免子类改变了父类的 immutable 特性</li>\n<li>如果类中包含 mutable 类对象，那么返回给客户端的时候，返回该对象的一个拷贝对象，而不是该对象本身 (该条可以归纳位第一条的一个特例)</li>\n</ol>\n<h3 id=\"我们能创建一个包含可变对象的不可变对象吗\"><a class=\"markdownIt-Anchor\" href=\"#我们能创建一个包含可变对象的不可变对象吗\">#</a> 我们能创建一个包含可变对象的不可变对象吗？</h3>\n<p>可以，但是需要注意，不能共享可变对象的引用，如果需要变化时，就返回原对象的一个拷贝，最常见的例子就是对象中包含一个日期对象的引用</p>\n<h3 id=\"有没有可能两个不相等的对象有相同的hashcode\"><a class=\"markdownIt-Anchor\" href=\"#有没有可能两个不相等的对象有相同的hashcode\">#</a> 有没有可能两个不相等的对象有相同的 hashcode？</h3>\n<p>有可能，两个不相等的对象可能有相同的 hashcode，这就是为什么在 hashMap 中会有冲突，相等 hashcode 值的规定只是说两个对象相等，必须有相同的 hashcode 值，但是没有关于不相等对象的任何规定</p>\n<h3 id=\"两个相同对象会有不同的hashcode吗\"><a class=\"markdownIt-Anchor\" href=\"#两个相同对象会有不同的hashcode吗\">#</a> 两个相同对象会有不同的 hashcode 吗？</h3>\n<p>不能，根据 hashcode 规定，这是不可能的</p>\n<h3 id=\"可以在hashcode方法中使用随机数字吗\"><a class=\"markdownIt-Anchor\" href=\"#可以在hashcode方法中使用随机数字吗\">#</a> 可以在 hashcode 方法中使用随机数字吗？</h3>\n<p>不能，根据 hashcode 规定，对象的 hashcode 值必须时相同的</p>\n<h3 id=\"java中comparator-与-comparable有什么不同\"><a class=\"markdownIt-Anchor\" href=\"#java中comparator-与-comparable有什么不同\">#</a> Java 中，Comparator 与 Comparable 有什么不同？</h3>\n<p>Comparable 接口用于定义对象的自然顺序，而 Comparator 通常用于用户自定义顺序，Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序</p>\n<h3 id=\"为什么在重写equals方法的时候需要重写hashcode方法\"><a class=\"markdownIt-Anchor\" href=\"#为什么在重写equals方法的时候需要重写hashcode方法\">#</a> 为什么在重写 equals 方法的时候需要重写 hashcode 方法？</h3>\n<p>因为有强制的规范指定需要同时重写 hashcode 与 equals 方法，许多容器类，如 HashMap、HashSet 都依赖与 hashcode 与 equals 的规定</p>\n<h3 id=\"ab-和-aequtalsb-有什么区别\"><a class=\"markdownIt-Anchor\" href=\"#ab-和-aequtalsb-有什么区别\">#</a> a==b 和 a.equtals (b) 有什么区别？</h3>\n<p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向堆中同一个对象才会返回 true，而 a.equals (b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性比较。例如 String 类重写 equals 方法，所以可以用于不同对象，但是包含的字母相同的比较</p>\n<h3 id=\"ahashcode有什么用aequalsb-有什么关系\"><a class=\"markdownIt-Anchor\" href=\"#ahashcode有什么用aequalsb-有什么关系\">#</a> a.hashcode () 有什么用，a.equals (b) 有什么关系？</h3>\n<p>hashCode () 方法是相应对象整形的 hash 值，它常用于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap 等等。它与 equals () 方法关系特别亲密。根据 Java 规范，两个使用 equals () 方法来判断相等的对象，必须具有相同的 hashCode。</p>\n<ol>\n<li>\n<p>hashCode 的作用<br>\n List 和 Set 如何保证 Set 不重复呢？通过迭代使用 equals () 方法来判断，数量小还可以接收，数据量太大怎么解决？引入 HashCode，实际上 hashCode 扮演的角色就是寻址，大大减少查询匹配次数。</p>\n<p>先判断对象的 hashCode 值是否相等，如果不相等，则说明两个对象不相等，如果相等再使用 equals () 方法进一步判断对象是否相等，只有当 hashCode 值相等，equals () 方法返回 true 时，确认两个对象是相等的。</p>\n</li>\n<li>\n<p>hashCode 重要吗<br>\n对于数组、List 集合就是一个累赘，而对于 HahsMap、HashSet、HashTable 就很重要了</p>\n</li>\n<li>\n<p>equals 方法遵循的原则</p>\n<ul>\n<li>对称性：若 x.equals (y) 为 true，则 y.equals (x)</li>\n<li>自反性：x.equals (x) 必须 true</li>\n<li>传递性：若 x.equals (y) 为 true，y.equals (z) 为 true，则 x.equals (z) 必为 true</li>\n<li>一致性：只要 x，y 内容不变，无论调用多少次结果都不变</li>\n<li>其他：x.equals (null) 永远为 false，x.equals (和 x 数据类型不同) 始终为 false</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"final-finalize-finally的不同之处\"><a class=\"markdownIt-Anchor\" href=\"#final-finalize-finally的不同之处\">#</a> final、finalize、finally 的不同之处</h3>\n<ul>\n<li>final 是一个修饰符，可以修饰变量，方法，和类。如果 final 修饰变量，意味着变量的值在初始化后不能被改变。</li>\n<li>Java 技术允许使用 finaliza () 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是有垃圾收集器在确定这个对象没有引用时对这个对象调用的，但是什么时候执行 finaliza 没有保证</li>\n<li>finally 是一个关键字，与 try 和 catch 一起用于异常的处理，finally 块一定会被执行，无论在 try 中是否发生异常</li>\n</ul>\n<h3 id=\"java中的编译期常量是什么使用它又有什么风险\"><a class=\"markdownIt-Anchor\" href=\"#java中的编译期常量是什么使用它又有什么风险\">#</a> Java 中的编译期常量是什么？使用它又有什么风险？</h3>\n<p>变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>\n<h3 id=\"静态内部类与顶级类有什么区别\"><a class=\"markdownIt-Anchor\" href=\"#静态内部类与顶级类有什么区别\">#</a> 静态内部类与顶级类有什么区别？</h3>\n<p>一个公共的顶级类的源文件与类名相同，而嵌套静态类没有这个要求，一个嵌套类位于顶级类的内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是顶级类，Entry 是一个嵌套静态类</p>\n<h3 id=\"java中serializable与externalizable的区别\"><a class=\"markdownIt-Anchor\" href=\"#java中serializable与externalizable的区别\">#</a> Java 中，Serializable 与 Externalizable 的区别？</h3>\n<p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高，脆弱且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制</p>\n<p><strong>声明为 static 和 transient 类型的数据不能被序列化，反序列化需要一个无参构造函数</strong></p>\n<h3 id=\"接口是什么为什么要使用接口而不是直接只用具体类\"><a class=\"markdownIt-Anchor\" href=\"#接口是什么为什么要使用接口而不是直接只用具体类\">#</a> 接口是什么？为什么要使用接口而不是直接只用具体类？</h3>\n<p>接口用于定义 API，它定义了类必须遵守的规则，同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口不允许普通方法，以此来保证抽象，但是 Java8 中你可以在接口中声明静态方法和默认普通方法。</p>\n<h3 id=\"java中抽象类与接口之间有什么不同\"><a class=\"markdownIt-Anchor\" href=\"#java中抽象类与接口之间有什么不同\">#</a> Java 中，抽象类与接口之间有什么不同？</h3>\n<p>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口，抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制</p>\n<h3 id=\"接口与抽象类\"><a class=\"markdownIt-Anchor\" href=\"#接口与抽象类\">#</a> 接口与抽象类</h3>\n<ul>\n<li>一个子类只能继承一个抽象类，但能实现多个接口</li>\n<li>抽象类可以有构造方法，接口没有构造方法</li>\n<li>抽象类可以有普通成员变量，接口没有普通成员变量</li>\n<li>抽象类和接口都可有静态成员变量，抽象类中静态成员变量访问类型任意，接口只能 public static final (默认)</li>\n<li>抽象类可以没有抽象方法，抽象类可以有普通方法；接口在 JDK8 之前都是抽象方法，在 JDK8 可以有 default 方法，在 JDK9 中允许有私有普通方法</li>\n<li>抽象类可以有静态方法；接口在 JDK8 之前不能有静态方法，在 JDK8 中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li>\n<li>抽象类中的方法可以是 public、protected; 接口方法在 JDK8 之前只有 public abstract，在 JDK8 可以有 default 方法，在 JDK9 中允许有 private 方法</li>\n</ul>\n<h3 id=\"抽象类和最终类\"><a class=\"markdownIt-Anchor\" href=\"#抽象类和最终类\">#</a> 抽象类和最终类</h3>\n<p>抽象类可以没有抽象方法，最终类可以没有最终方法<br>\n最终类不能被继承，最终方法不能被重写</p>\n<h3 id=\"异常\"><a class=\"markdownIt-Anchor\" href=\"#异常\">#</a> 异常</h3>\n<p>相关的关键字：throw、throws、try…catch、finally</p>\n<ul>\n<li>throws 用在方法标签上，以抛出的异常可以被调用者处理</li>\n<li>throw 方法内部通过 throw 抛出异常</li>\n<li>try 用于检测包住的语句块，若有异常，catch 子句捕获并执行 catch 块</li>\n</ul>\n<h3 id=\"关于finally\"><a class=\"markdownIt-Anchor\" href=\"#关于finally\">#</a> 关于 finally</h3>\n<ul>\n<li>finally 不管有没有异常都要处理</li>\n<li>当 try 和 catch 中有 return 时，finally 仍会执行，finally 比 return 先执行</li>\n<li>不管有没有异常抛出，finally 在 return 返回前执行</li>\n<li>finally 是在 return 后面的表达式运算后执行的 (此时并没有返回运算后的值，二十先把要返回的值保存起来，不管 finally 中的代码怎么样，返回值都不会改变，仍然是之前保存的值)，所以函返回值是在 finally 执行前确定的</li>\n</ul>\n<p>注意：finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值<br>\n finally 不执行的几种情况：程序提前终止了，如调用了 System.exit，病毒，断电</p>\n<h3 id=\"super出现在父类的子类中有三种存在方式\"><a class=\"markdownIt-Anchor\" href=\"#super出现在父类的子类中有三种存在方式\">#</a> super 出现在父类的子类中，有三种存在方式</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N1cGVyLnh4eA==\">super.xxx</span> 调用父类的中的 xxx 变量或引用</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N1cGVyLnh4eA==\">super.xxx</span> () 调用父类中的方法</li>\n<li>super () 调用父类构造函数</li>\n</ul>\n<p>注意：super 只能代其直接父类</p>\n<h3 id=\"this-super-在构造方法中的区别\"><a class=\"markdownIt-Anchor\" href=\"#this-super-在构造方法中的区别\">#</a> this () &amp; super () 在构造方法中的区别</h3>\n<ul>\n<li>调用 super () 必须卸载子类构造方法的第一行，否则编译不通过</li>\n<li>super 从子类调用父类构造，this 在同一类中调用其他构造器均需要放在第一行</li>\n<li>尽管可以用 this 调用一个构造器，去不能调用 2 个</li>\n<li>this 和 super 不能出现在同一个构造器中，否则编译不通过</li>\n<li>this ()、super () 都指的对象，不可以在 static 环境中使用</li>\n<li>本质 this 指向本对象的指针，super 是一个关键字</li>\n</ul>\n<h3 id=\"构造内部类和静态内部类对象\"><a class=\"markdownIt-Anchor\" href=\"#构造内部类和静态内部类对象\">#</a> 构造内部类和静态内部类对象</h3>\n<pre><code class=\"language-Java\">public class Enclosingone &#123;\n\tpublic class Insideone &#123;&#125;\n\tpublic static class Insideone&#123;&#125;\n&#125;\n\npublic class Test &#123;\n\tpublic static void main(String[] args) &#123;\n\t// 构造内部类对象需要外部类的引用\n\tEnclosingone.Insideone obj1 = new Enclosingone().new Insideone();\n\t// 构造静态内部类的对象\n\tEnclosingone.Insideone obj2 = new Enclosingone.Insideone();\n\t&#125;\n&#125;\n</code></pre>\n<p>静态内部类不需要有外部类的引用，但非静态内部类需要持有对外部类的引用。非静态类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员</p>\n<h3 id=\"java位移运算符\"><a class=\"markdownIt-Anchor\" href=\"#java位移运算符\">#</a> Java 位移运算符</h3>\n<p>Java 中有三种位移运算符</p>\n<ul>\n<li>&lt;&lt;左移运算符，x&lt;&lt;1 相当于 x 乘以 2 (不溢出的情况下)，地位补 0</li>\n<li>\n<blockquote>\n<blockquote>\n<p>右移运算符，x&gt;&gt;1 相当于 x 除以 2，正数高位补 0，负数高位补 1</p>\n</blockquote>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>无符号右移，忽略符号位，空位都以 0 补齐</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"形参实参\"><a class=\"markdownIt-Anchor\" href=\"#形参实参\">#</a> 形参 &amp; 实参</h3>\n<p>形式参数可被视为 local variable, 形参和局部变量一样不能离开方法，只有在方法中使用，不会在方法外可见。形式参数只能用 final 修饰符，其他任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用 final 修饰，只有特殊情况下，那就是：方法内部类。一个方法内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是 final。形参的值在调用时根据调用者更改。实参则用自身的值更改形参的值 (指针、引用皆在此列)，也就是说真正被传递的是实参。</p>\n<h3 id=\"局部变量为什么要初始化\"><a class=\"markdownIt-Anchor\" href=\"#局部变量为什么要初始化\">#</a> 局部变量为什么要初始化</h3>\n<p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者在使用前给变量赋值。</p>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/",
            "title": "泛型机制详解",
            "date_published": "2024-02-18T08:13:44.946Z",
            "content_html": "<p>Java 泛型是从 jdk1.5 开始加入的，Java 泛型的实现采取了 “伪泛型” 的策略，即 Java 在语法上支持泛型，但是在编译阶段会进行所谓的 “类型擦除”，将所有的泛型表示 (尖括号中的内容) 都替换为具体的类型 (其对应的原生态类型)，就像完全没有泛型一样。</p>\n<p>引入泛型的意义在于：</p>\n<ul>\n<li>适用于多种数据类型执行相同的代码 (代码复用)</li>\n</ul>\n<pre><code class=\"language-Java\">private static int add(int a, int b) &#123;\n    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));\n    return a + b;\n&#125;\n\nprivate static float add(float a, float b) &#123;\n    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));\n    return a + b;\n&#125;\n\nprivate static double add(double a, double b) &#123;\n    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));\n    return a + b;\n&#125;\n</code></pre>\n<p>如果没有泛型，要实现不同类型的方法，每种类型都需要重载一个 add 方法，通过泛型，我们可以复用为一个方法：</p>\n<pre><code class=\"language-Java\">private static &lt;T extends Number&gt; double add(T a, T b) &#123;\n    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue()));\n    return a.doubleValue() + b.doubleValue();\n&#125;\n</code></pre>\n<ul>\n<li>泛型中的类型在使用时指定，不需要强制类型转换 (类型安全，编译器会检查类型)</li>\n</ul>\n<h2 id=\"泛型的基本使用\"><a class=\"markdownIt-Anchor\" href=\"#泛型的基本使用\">#</a> 泛型的基本使用</h2>\n<h3 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h3>\n<ul>\n<li>从一个简单的泛型类看起：</li>\n</ul>\n<pre><code class=\"language-Java\">class Point&lt;T&gt;&#123;         // 此处可以随便写标识符号，T是type的简称  \n    private T var ;     // var的类型由T指定，即：由外部指定  \n    public T getVar()&#123;  // 返回值的类型由外部决定  \n        return var ;  \n    &#125;  \n    public void setVar(T var)&#123;  // 设置的类型也由外部决定  \n        this.var = var ;  \n    &#125;  \n&#125;  \npublic class GenericsDemo06&#123;  \n    public static void main(String args[])&#123;  \n        Point&lt;String&gt; p = new Point&lt;String&gt;() ;     // 里面的var类型为String类型  \n        p.setVar(&quot;it&quot;) ;                            // 设置字符串  \n        System.out.println(p.getVar().length()) ;   // 取得字符串的长度  \n    &#125;  \n&#125;\n</code></pre>\n<ul>\n<li>多元泛型</li>\n</ul>\n<pre><code class=\"language-Java\">class Notepad&lt;K,V&gt;&#123;       // 此处指定了两个泛型类型  \n    private K key ;     // 此变量的类型由外部决定  \n    private V value ;   // 此变量的类型由外部决定  \n    public K getKey()&#123;  \n        return this.key ;  \n    &#125;  \n    public V getValue()&#123;  \n        return this.value ;  \n    &#125;  \n    public void setKey(K key)&#123;  \n        this.key = key ;  \n    &#125;  \n    public void setValue(V value)&#123;  \n        this.value = value ;  \n    &#125;  \n&#125; \npublic class GenericsDemo09&#123;  \n    public static void main(String args[])&#123;  \n        Notepad&lt;String,Integer&gt; t = null ;        // 定义两个泛型类型的对象  \n        t = new Notepad&lt;String,Integer&gt;() ;       // 里面的key为String，value为Integer  \n        t.setKey(&quot;汤姆&quot;) ;        // 设置第一个内容  \n        t.setValue(20) ;            // 设置第二个内容  \n        System.out.print(&quot;姓名；&quot; + t.getKey()) ;      // 取得信息  \n        System.out.print(&quot;，年龄；&quot; + t.getValue()) ;       // 取得信息  \n    &#125;  \n&#125;\n</code></pre>\n<h3 id=\"泛型接口\"><a class=\"markdownIt-Anchor\" href=\"#泛型接口\">#</a> 泛型接口</h3>\n<ul>\n<li>简单的泛型接口</li>\n</ul>\n<pre><code class=\"language-Java\">interface Info&lt;T&gt;&#123;        // 在接口上定义泛型  \n    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  \n&#125;  \nclass InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123;   // 定义泛型接口的子类  \n    private T var ;             // 定义属性  \n    public InfoImpl(T var)&#123;     // 通过构造方法设置属性内容  \n        this.setVar(var) ;    \n    &#125;  \n    public void setVar(T var)&#123;  \n        this.var = var ;  \n    &#125;  \n    public T getVar()&#123;  \n        return this.var ;  \n    &#125;  \n&#125; \npublic class GenericsDemo24&#123;  \n    public static void main(String arsg[])&#123;  \n        Info&lt;String&gt; i = null;        // 声明接口对象  \n        i = new InfoImpl&lt;String&gt;(&quot;汤姆&quot;) ;  // 通过子类实例化对象  \n        System.out.println(&quot;内容：&quot; + i.getVar()) ;  \n    &#125;  \n&#125;\n</code></pre>\n<h3 id=\"泛型方法\"><a class=\"markdownIt-Anchor\" href=\"#泛型方法\">#</a> 泛型方法</h3>\n<p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p>\n<ul>\n<li>定义泛型方法的语法格式</li>\n</ul>\n<pre><code class=\"language-Java\">public class Sace &#123;\n\n    // &lt;T&gt; 声明此方法持有一个类型T，也可以理解为声明此方法为泛型方法\n    // T 指明该方法返回对象为T类型\n    // Class&lt;T&gt; 指明泛型的具体类型\n    public &lt;T&gt; T getObject(Class&lt;T&gt; c) throws InstantiationException, IllegalAccessException &#123;\n        T t = c.newInstance();\n        return t;\n    &#125;\n\n    public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123;\n        Sace sace = new Sace();\n        Class&lt;Date&gt; aClass = Date.class;\n        Date object = sace.getObject(aClass);\n        System.out.println(object);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"泛型的上下限\"><a class=\"markdownIt-Anchor\" href=\"#泛型的上下限\">#</a> 泛型的上下限</h3>\n<p>以下代码会报错</p>\n<pre><code class=\"language-Java\">class A&#123;&#125;\nclass B extends A &#123;&#125;\n\n// 如下两个方法不会报错\npublic static void funA(A a) &#123;\n    // ...          \n&#125;\npublic static void funB(B b) &#123;\n    funA(b);\n    // ...             \n&#125;\n\n// 如下funD方法会报错\npublic static void funC(List&lt;A&gt; listA) &#123;\n    // ...          \n&#125;\npublic static void funD(List&lt;B&gt; listB) &#123;\n    funC(listB); // Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;)\n    // ...             \n&#125;\n</code></pre>\n<p>为了解决泛型中隐含的转换问题，Java 泛型加入了类型参数的上下边界机制。&lt;? extends A&gt; 表示该类型参数可以是 A (上边界) 或者 A 的子类类型。编译时擦除到类型 A，即用 A 类型代替类型参数。这种方法可以解决开始遇到的问题。</p>\n<pre><code class=\"language-Java\">public static void funC(List&lt;? extends A&gt; listA) &#123;\n    // ...          \n&#125;\npublic static void funD(List&lt;B&gt; listB) &#123;\n    funC(listB); // OK\n    // ...             \n&#125;\n</code></pre>\n<ul>\n<li>泛型上下限的引入<br>\n在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，比如：类型实参只准传入某种类型的夫类型或某种类型的子类</li>\n</ul>\n<p>上限</p>\n<pre><code class=\"language-Java\">public class Info&lt;T extends Number&gt; &#123;\n    T val;\n\n    public T getVal() &#123;\n        return val;\n    &#125;\n\n    public void setVal(T val) &#123;\n        this.val = val;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Info info = new Info&lt;Double&gt;();\n        Info info2 = new Info&lt;Integer&gt;();\n        info.val = 10;\n        info2.val = 10f;\n        System.out.println(info.val);\n        System.out.println(info2.val);\n    &#125;\n&#125;\n</code></pre>\n<p>下限</p>\n<pre><code class=\"language-Java\">public class Info&lt;T&gt; &#123;\n    T val;\n\n    public T getVal() &#123;\n        return val;\n    &#125;\n\n    public void setVal(T val) &#123;\n        this.val = val;\n    &#125;\n\n    public static void fun(Info&lt;? super String&gt; temp) &#123;    // 只能接收String或Object类型的泛型，String类的父类只有Object类\n        System.out.print(temp + &quot;, &quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Info&lt;String&gt; info = new Info&lt;String&gt;();\n        Info&lt;Object&gt; info2 = new Info&lt;Object&gt;();\n        Info&lt;Integer&gt; info3 = new Info&lt;Integer&gt;();\n        fun(info);\n        fun(info2);\n        fun(info3); // info3不允许作为fun的形参，info3是Integer泛型对象，需要一个String的父类，包括String类\n    &#125;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>\n<?> 无限制通配符\n</li>\n<li>\n<? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类\n</li>\n<li>\n<? super E> super 关键字声明了类型的下界，表示了参数化的类型可能是指定类型，或者是次类型的父类</li>\n</ol>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "title": "面向对象",
            "date_published": "2024-02-18T08:13:44.946Z",
            "content_html": "<h1 id=\"java基础-面向对象\"><a class=\"markdownIt-Anchor\" href=\"#java基础-面向对象\">#</a> Java 基础 - 面向对象</h1>\n<h2 id=\"三大特性\"><a class=\"markdownIt-Anchor\" href=\"#三大特性\">#</a> 三大特性</h2>\n<p><strong>封装</strong></p>\n<p>利用抽象数据类型将<em>数据</em>和<em>基于数据的操作</em>封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生关系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>\n<p>优点：</p>\n<ul>\n<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>\n<li>减轻维护的负担：可以更容易地被程序员所理解，并且在调试的时候可以不影响其他模块</li>\n<li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能</li>\n<li>提供软件的可重用性</li>\n<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>\n</ul>\n<p><strong>继承</strong></p>\n<p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>\n<p>继承应该遵守里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>\n<p>Cat 可以当作 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象 (<em>父类引用指向子类的实现</em>) 称为 <strong>向上转型</strong>。</p>\n<blockquote>\n<p>Animal animal = new Cat();</p>\n</blockquote>\n<p><strong>多态</strong></p>\n<p>多态分为编译时多态和运行时多态：</p>\n<ul>\n<li>编译时多态主要指方法的重载</li>\n<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定<br>\n运行时多态有三个条件\n<ul>\n<li>继承</li>\n<li>覆盖 (重写)</li>\n<li>向上转型</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类\"><a class=\"markdownIt-Anchor\" href=\"#类\">#</a> 类</h2>\n<h3 id=\"泛化关系generalization\"><a class=\"markdownIt-Anchor\" href=\"#泛化关系generalization\">#</a> 泛化关系 (Generalization)</h3>\n<p>用于描述继承关系，在 Java 中使用 extends 关键字</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png\" alt=\"泛型关系\"></p>\n<pre><code>\nclass Vehical\nclass Car\nclass Truck\n\nVehical &lt;| -- Car\nVehical &lt;| -- Truck\n\n</code></pre>\n<h3 id=\"实现关系realization\"><a class=\"markdownIt-Anchor\" href=\"#实现关系realization\">#</a> 实现关系 (Realization)</h3>\n<p>用来实现一个接口，在 Java 中使用 implements 关键字</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILK8IatCoQn.png\" alt=\"实现关系\"></p>\n<pre><code>\ninterface MoveBehavior\nclass Fly\nclass Run\n\nMoveBehavior &lt;| -- Fly\nMoveBehivior &lt;| -- Run\n\n</code></pre>\n<h3 id=\"聚合关系aggregation\"><a class=\"markdownIt-Anchor\" href=\"#聚合关系aggregation\">#</a> 聚合关系 (Aggregation)</h3>\n<p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了但部分还是会存在</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png\" alt=\"实现关系\"></p>\n<pre><code>\nclass Computer\nclass Keyboard\nclass Mouse\nclass Screen\n\nComputer o -- Keyboard\nComputer o -- Mouse\nComputer o -- Screen\n\n</code></pre>\n<h3 id=\"组合关系composition\"><a class=\"markdownIt-Anchor\" href=\"#组合关系composition\">#</a> 组合关系 (Composition)</h3>\n<p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了，部分也就不存在了</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png\" alt=\"实现关系\"></p>\n<pre><code>\nclass Company\nclass DepartmentA\nclass DepartmentB\n\nCompany * -- DepartmentA\nCompany * -- DepartmentB\n\n</code></pre>\n<h3 id=\"关联关系association\"><a class=\"markdownIt-Anchor\" href=\"#关联关系association\">#</a> 关联关系 (Association)</h3>\n<p>表示不同对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此可以用 1 对 1、多对 1、多对多这种关联关系来表示</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILLmB2xEJyv.png\" alt=\"实现关系\"></p>\n<pre><code>\nclass School\nclass Student\n\nSchool &quot;1&quot; - &quot;n&quot; Student\n\n</code></pre>\n<h3 id=\"依赖关系dependency\"><a class=\"markdownIt-Anchor\" href=\"#依赖关系dependency\">#</a> 依赖关系 (Dependency)</h3>\n<p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>\n<ul>\n<li>A 类是 B 类中的 (某种方法的) 局部变量</li>\n<li>A 类是 B 类方法当中的一个参数</li>\n<li>A 类向 B 类发送消息，从而影响 B 类发生变化</li>\n</ul>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/LOun2W9134NxVugmbJPp15d4LalxC4O.png\" alt=\"实现关系\"></p>\n<pre><code>\nclass Vehicle &#123;\n    move(MoveBehavior)\n&#125;\n\ninterface MoveBehavior &#123;\n    move()\n&#125;\n\nnote &quot;MoveBehavior.move()&quot; as N\n\nVehicle ..&gt; MoveBehavior\n\nVehicle .. N\n\n</code></pre>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E7%9F%A5%E8%AF%86%E7%82%B9/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E7%9F%A5%E8%AF%86%E7%82%B9/",
            "title": "知识点",
            "date_published": "2024-02-18T08:13:44.946Z",
            "content_html": "<h1 id=\"java基础-知识点\"><a class=\"markdownIt-Anchor\" href=\"#java基础-知识点\">#</a> Java 基础 - 知识点</h1>\n<h2 id=\"数据类型\"><a class=\"markdownIt-Anchor\" href=\"#数据类型\">#</a> 数据类型</h2>\n<p>八个基本类型：</p>\n<ul>\n<li>boolean/1</li>\n<li>byte/8</li>\n<li>char/16</li>\n<li>short/16</li>\n<li>int/32</li>\n<li>float/32</li>\n<li>double/64</li>\n<li>long/64</li>\n</ul>\n<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>\n<pre><code class=\"language-Java\">\nInteger x = 2; // 装箱\nint y = x; // 拆箱\n\n</code></pre>\n<h2 id=\"缓存池\"><a class=\"markdownIt-Anchor\" href=\"#缓存池\">#</a> 缓存池</h2>\n<p>new Integer (123) 与 Integer.valueOf (123) 的区别在于：</p>\n<ul>\n<li>new Integer (123) 每次都会创建一个新对象</li>\n<li>Integer.valueOf (123) 会使用缓存池中的对象，多次调用会获得同一个对象的引用</li>\n</ul>\n<pre><code class=\"language-Java\">\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y); // false\nInteger j = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(j == k); // true\n\n</code></pre>\n<p>valueOf 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就返回缓存池中的内容</p>\n<pre><code class=\"language-Java\">\npublic static Integer valueOf(int i) &#123;\n    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n         return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n&#125;\n\n</code></pre>\n<p>在 Java8 中，Integer 的缓存池大小默认为 -128 ~ 127</p>\n<p>编译器会在缓存池范围内的基本类型自动装箱过程中调用 valueOf () 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象</p>\n<pre><code class=\"language-Java\">\nInteger m = 123;\nInteger n = 123;\nSystem.out.println(m == n); // true\n\n</code></pre>\n<p>基本类型对应缓存池如下：</p>\n<ul>\n<li>boolean values true and false</li>\n<li>all byte values</li>\n<li>short values between -128 and 127</li>\n<li>int values between -128 and 127</li>\n<li>char in the range \\u0000 to \\u007F</li>\n</ul>\n<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p>\n<p>如果在缓存池之外：</p>\n<pre><code class=\"language-Java\">\nInteger m = 323;\nInteger n = 323;\nSystem.out.println(m == n); // false\n\n</code></pre>\n<h2 id=\"string\"><a class=\"markdownIt-Anchor\" href=\"#string\">#</a> String</h2>\n<h3 id=\"概览\"><a class=\"markdownIt-Anchor\" href=\"#概览\">#</a> 概览</h3>\n<p>String 被声明为 final，因此它是不可继承的</p>\n<p>内部使用 char 存储数据，该数组被声明为 final，这意味着 value 数组初始化之后，就不能再引用其他数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变</p>\n<pre><code class=\"language-Java\">\npublic final class String\n    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;\n    /** The value is used for character storage. */\n    private final char value[];\n\n</code></pre>\n<h3 id=\"不可变的好处\"><a class=\"markdownIt-Anchor\" href=\"#不可变的好处\">#</a> 不可变的好处</h3>\n<ol>\n<li>可以使用 hash 值<br>\n因为 String hash 值经常被使用，例如 String 用作 HashMap 的 Key，不可变的特性使得 HashMap 的值也不可变，因此只需要做一次计算就够了</li>\n<li>String pool 的需要<br>\n如果一个 String 对象以及被创建过了，那么就会从 String pool 中取得引用。只有 String 是不可变的，才能使用 String pool</li>\n</ol>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/f76067a5-7d5f-4135-9549-8199c77d8f1c.jpg\" alt=\"String 缓存池\"></p>\n<ol start=\"3\">\n<li>安全性<br>\n String 经常被作为参数，String 的不可变性保证参数不可变</li>\n<li>线性安全<br>\n String 不可变天生具备线性安全特性，可以在多个线程中安全使用</li>\n</ol>\n<h3 id=\"string-stringbuffer-stringbuilder\"><a class=\"markdownIt-Anchor\" href=\"#string-stringbuffer-stringbuilder\">#</a> String、StringBuffer、StringBuilder</h3>\n<ol>\n<li>\n<p>可变性</p>\n<ul>\n<li>String 不可变</li>\n<li>StringBuffer 和 StringBuilder 可变</li>\n</ul>\n</li>\n<li>\n<p>线程安全</p>\n<ul>\n<li>String 不可变，因此是线程安全的</li>\n<li>StringBuffer 是线程安全的，因为内部是使用 synchronized 进行同步</li>\n<li>StringBuilder 不是线程安全的</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"stringintern\"><a class=\"markdownIt-Anchor\" href=\"#stringintern\">#</a> String.intern()</h3>\n<p>使用 String.intern () 可以保证相同内容的字符串变量引用同一个内存对象</p>\n<p>s1 和 s2 采用 new String () 的方式创建了两个不同的对象，而 s3 是通过 s1.intern () 方式获取一个对象的引用。intern 首先把 s1 的引用对象方式 String pool (字符串常量池) 中，然后返回这个对象的引用，因此 s3 和 s4 引用的是同一个字符串常量池中的对象，所以 s3 == s4</p>\n<pre><code class=\"language-Java\">\n    String s1 = new String(&quot;aaa&quot;);\n    String s2 = new String(&quot;aaa&quot;);\n    System.out.println(s1 == s2);\n    String s3 = s1.intern();\n    System.out.println(s3 == s1);\n    String s4 = s1.intern();\n    System.out.println(s3 == s4);\n\n</code></pre>\n<p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p>\n<pre><code class=\"language-Java\">\nString s4 = &quot;bbb&quot;;\nString s5 = &quot;bbb&quot;;\nSystem.out.println(s4 == s5);  // true\n\n</code></pre>\n<p><strong>HotSpot 中的字符串常量池保存在哪里？永久代？方法区还是堆区？</strong></p>\n<ol>\n<li>运行时常量池 (Runntime Constant Pool) 是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机以后，就会创建对应的运行时常量是；而字符串常量池是这个过程中常量字符串存放的位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及原空间是实际的存放位置</li>\n<li>不同虚拟机对虚拟机的规范 (比如方法区) 是不一样的，只有 HotSpot 才有永久代的概念</li>\n<li>HotSpot 也是发展的，由于一些问题的存在 HotSpot 考虑主键去永久代，对于不同版本的 JDK，实际的存储位置是有差异的，具体如下</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">JDK 版本</th>\n<th>是否有永久代，字符串常量池放在哪里？</th>\n<th>方法区逻辑上规范，由哪些实际的部分实现的？</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">jdk1.6 及之前</td>\n<td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td>\n<td>这个时期方法区在 HotSpot 中是由永久代来实现的，以至于这个时期说方法区就是指永久代</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">jdk1.7</td>\n<td>有永久代，但已经逐步 “去永久代”，字符串常量池、静态变量移除，保存在堆中；</td>\n<td>这个时期方法区在 HotSpot 中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">jdk1.8 及之后</td>\n<td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td>\n<td>这个时期方法区在 HotSpot 中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"运算\"><a class=\"markdownIt-Anchor\" href=\"#运算\">#</a> 运算</h2>\n<h3 id=\"参数传递\"><a class=\"markdownIt-Anchor\" href=\"#参数传递\">#</a> 参数传递</h3>\n<p>Java 的参数是以值得形式传入方法中，而不是引用传递</p>\n<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法是，本质上是将对象的地址以值得形式传递到形参中，因此在方法中改变指针引用对象，那么这两个指针此时指向得是完全不同得对象，一方对象得改变，对另一方没什么影响</p>\n<pre><code class=\"language-Java\">\npublic class Dog &#123;\n    String name;\n\n    Dog(String name) &#123;\n        this.name = name;\n    &#125;\n\n    String getName() &#123;\n        return this.name;\n    &#125;\n\n    void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    String getObjectAddress() &#123;\n        return super.toString();\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\npublic class PassByValueExample &#123;\n    public static void main(String[] args) &#123;\n        Dog dog = new Dog(&quot;A&quot;);\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        func(dog);\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        System.out.println(dog.getName());          // A\n    &#125;\n\n    private static void func(Dog dog) &#123;\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        dog = new Dog(&quot;B&quot;);\n        System.out.println(dog.getObjectAddress()); // Dog@74a14482\n        System.out.println(dog.getName());          // B\n    &#125;\n&#125;\n\n</code></pre>\n<p>但是如果在方法中改变对象得字段值，会改变原对象的该字段值，因为改变的是同一个地址指向的内容</p>\n<pre><code class=\"language-Java\">\nclass PassByValueExample &#123;\n    public static void main(String[] args) &#123;\n        Dog dog = new Dog(&quot;A&quot;);\n        func(dog);\n        System.out.println(dog.getName());          // B\n    &#125;\n\n    private static void func(Dog dog) &#123;\n        dog.setName(&quot;B&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"float-与-double\"><a class=\"markdownIt-Anchor\" href=\"#float-与-double\">#</a> float 与 double</h2>\n<p>1.1 字面属于 double 类型，不能直接将 1.1 赋值给 float 变量，因为这是向下转型。Java 不能隐士执行向下转型，因为这样会使精度变低</p>\n<pre><code class=\"language-Java\">\n// float f = 1.1; // 会报错\n\n</code></pre>\n<p>1.1f 字面量才是 float 类型</p>\n<pre><code class=\"language-Java\">\nfloat f = 1.1f;\n\n</code></pre>\n<h2 id=\"隐式类型转换\"><a class=\"markdownIt-Anchor\" href=\"#隐式类型转换\">#</a> 隐式类型转换</h2>\n<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式的将 int 类型转为 short 类型</p>\n<pre><code class=\"language-Java\">\nshort s1 = 1;\n// s1 = s1 + 1; // s1 + 1 被隐式的转换为int类型，因为int类型不能隐式转换为short，因此报错\n\n</code></pre>\n<p>但是使用 += 运算符可以执行隐式类型转换</p>\n<pre><code class=\"language-Java\">\nshort s1 = 1;\ns1 += 1;\n\n</code></pre>\n<p>上面的语句相当于 s1 + 1 的计算结果进行了向下转型</p>\n<pre><code class=\"language-Java\">\ns1 = (short) (s1 + 1);\n\n</code></pre>\n<h2 id=\"switch\"><a class=\"markdownIt-Anchor\" href=\"#switch\">#</a> switch</h2>\n<p>从 java7 开始，可以在 switch 条件判断语句中使用 String 对象</p>\n<pre><code class=\"language-Java\">\n   String str = &quot;ccc&quot;;\n   switch (str) &#123;\n       case &quot;aaa&quot;: &#123;\n           System.out.println(&quot;aaa&quot;);\n           break;\n       &#125;\n       case &quot;bbb&quot;: &#123;\n           System.out.println(&quot;bbb&quot;);\n           break;\n       &#125;\n       default:\n           System.out.println(&quot;没有啊&quot;);\n   &#125;\n\n</code></pre>\n<p><strong>注意：switch-case 语句中，break 尤为重要，如果不加 break 作为结束标志，switch 会从匹配到的第一个值之后，无视后来的所有 case 和 default 关键字，执行到结束</strong></p>\n<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值进行等值判断，如果值过于复杂，那么还是用 if 合适</p>\n<p>jdk8 中，switch 支持 char, byte, short, int, Character, Byte, Short, Integer, String, or an enum</p>\n<h2 id=\"继承\"><a class=\"markdownIt-Anchor\" href=\"#继承\">#</a> 继承</h2>\n<h3 id=\"访问权限\"><a class=\"markdownIt-Anchor\" href=\"#访问权限\">#</a> 访问权限</h3>\n<p>java 中有三个访问权限修饰符:private、protected 以及 public，如果不加访问修饰符，表示包级可见</p>\n<p>可以对类或类中的成员 (字段以及方法) 添加修饰符</p>\n<ul>\n<li>类可见表示其他类可以用这个类创建实例对象</li>\n<li>成员可见表示其他类可以用这个类的实例对象访问到该成员</li>\n</ul>\n<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>\n<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的内部实现清晰的隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息的隐藏或者封装。因此访问权限应当尽可能的使每个类或者成员不被外界访问。</p>\n<blockquote>\n<p>如果字类重写了父类的方法，那么子类中该方法的访问权限不允许低于父类的访问级别，这是为了确保使用父类的地方都可以使用字类实例，也就确保满足里氏替换原则</p>\n</blockquote>\n<h3 id=\"抽象类与接口\"><a class=\"markdownIt-Anchor\" href=\"#抽象类与接口\">#</a> 抽象类与接口</h3>\n<ol>\n<li>\n<p>抽象类</p>\n<p>抽象类和抽象方法都是用 abstract 关键字进行声明，抽象类一般会包含抽象方法，抽象方法一定在抽象类中 (换句话说，有抽象方法的类，一定是抽象类)</p>\n<p>抽象类和普通类最大的区别就是，抽象类不能实例化，需要继承抽象类才能实例化子类</p>\n</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic abstract class AbstractClassExample &#123;\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() &#123;\n        System.out.println(&quot;func2&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\npublic class AbstractExtendClassExample extends AbstractClassExample &#123;\n    @Override\n    public void func1() &#123;\n        System.out.println(&quot;func1&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\n// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated\nAbstractClassExample ac2 = new AbstractExtendClassExample();\nac2.func1();\n\n</code></pre>\n<ol>\n<li>\n<p>接口</p>\n<p>接口是抽象类的延申，在 Java8 之前，它可以看成一个完全抽象的类，也就是说他不能有任何的方法实现</p>\n<p>在 java8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口维护成本太高了，在 Java8 之前，如果一个接口想要添加新方法，那么就要修改所有实现了该接口的类</p>\n<p>接口的成员 (字段 + 方法) 默认都是 public，并且不允许自定义为 private 或者 protected</p>\n<p>接口的字段默认都是 static 和 final 的</p>\n</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic interface InterfaceExample &#123;\n    void func1();\n\n    default void func2()&#123;\n        System.out.println(&quot;func2&quot;);\n    &#125;\n\n    int x = 123;\n    // int y;               // Variable 'y' might not have been initialized\n    public int z = 0;       // Modifier 'public' is redundant for interface fields\n    // private int k = 0;   // Modifier 'private' not allowed here\n    // protected int l = 0; // Modifier 'protected' not allowed here\n    // private void fun3(); // Modifier 'private' not allowed here\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\npublic class InterfaceImplementExample implements InterfaceExample &#123;\n    @Override\n    public void func1() &#123;\n        System.out.println(&quot;func1&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\n// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated\nInterfaceExample ie2 = new InterfaceImplementExample();\nie2.func1();\nSystem.out.println(InterfaceExample.x);\n\n</code></pre>\n<ol>\n<li>比较</li>\n</ol>\n<ul>\n<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里氏替换原则，即字类对象必须能够替换掉所有父类对象。而接口更像一个 Like-A 关系，他只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系</li>\n<li>从使用上来看，一个类可以实现多个接口，但不能继承多个类</li>\n<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制</li>\n<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限</li>\n</ul>\n<ol start=\"4\">\n<li>使用选择</li>\n</ol>\n<p>使用接口：</p>\n<ul>\n<li>需要让不相关的类都实现一个方法例如不相关的类都可以实现 Compareable 接口中的 compareTo () 方法</li>\n<li>需要使用多重继承</li>\n</ul>\n<p>使用抽象类</p>\n<ul>\n<li>需要在几个相关的类中共享代码</li>\n<li>需要能控制继承的成员访问权限，而不是都为 public</li>\n<li>需要继承非静态字段和非常量字段</li>\n</ul>\n<p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活的为一个类添加行为，并且从 Java8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变得很低</p>\n<h3 id=\"super\"><a class=\"markdownIt-Anchor\" href=\"#super\">#</a> super</h3>\n<ul>\n<li>访问父类的构造函数，可以使用 super () 函数访问父类的构造函数，从而委托父类完成一些初始化工作</li>\n<li>访问父类的成员，如果子类重写了父类中的某个方法的实现，可以通过 super 关键字来引用父类的方法实现</li>\n</ul>\n<pre><code class=\"language-Java\">\npublic class SuperExample &#123;\n    protected int x;\n    protected int y;\n\n    public SuperExample(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n\n    public void func() &#123;\n        System.out.println(&quot;SuperExample.func()&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\npublic class SuperExtendExample extends SuperExample &#123;\n    private int z;\n\n    public SuperExtendExample(int x, int y, int z) &#123;\n        super(x, y);\n        this.z = z;\n    &#125;\n\n    @Override\n    public void func() &#123;\n        super.func();\n        System.out.println(&quot;SuperExtendExample.func()&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\nSuperExample e = new SuperExtendExample(1, 2, 3);\ne.func();\n\n// SuperExample.func()\n// SuperExtendExample.func()\n\n</code></pre>\n<h3 id=\"重写与重载\"><a class=\"markdownIt-Anchor\" href=\"#重写与重载\">#</a> 重写与重载</h3>\n<ol>\n<li>\n<p>重写 (Override)<br>\n 存在于继承体系中，指字类实现了一个与父类在方法声明上完全相同的方法<br>\n为了满足里氏替换原则，重写有以下两个限制</p>\n<ul>\n<li>字类方法的访问权限必须大于等于父类方法</li>\n<li>字类方法的返回类型必须是父类方法的放回类型或为其子类型</li>\n</ul>\n</li>\n<li>\n<p>重载 (Overload)<br>\n 存在于同一个类中，指一个方法已经存在的方法名称上相同，但是<strong>参数类型</strong>、<strong>个数</strong>、<strong>顺序</strong>至少有一个不同<br>\n注意： 返回值不同，其他都相同不算是重载 (所以这种非重载方法会报错)</p>\n</li>\n</ol>\n<h2 id=\"object通用方法\"><a class=\"markdownIt-Anchor\" href=\"#object通用方法\">#</a> Object 通用方法</h2>\n<h3 id=\"概览-2\"><a class=\"markdownIt-Anchor\" href=\"#概览-2\">#</a> 概览</h3>\n<pre><code class=\"language-Java\">\npublic final native Class&lt;?&gt; getClass()\n\npublic native int hashCode()\n\npublic boolean equals(Object obj)\n\nprotected native Object clone() throws CloneNotSupportedException\n\npublic String toString()\n\npublic final native void notify()\n\npublic final native void notifyAll()\n\npublic final native void wait(long timeout) throws InterruptedException\n\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\npublic final void wait() throws InterruptedException\n\nprotected void finalize() throws Throwable &#123;&#125;\n\n</code></pre>\n<h3 id=\"equals\"><a class=\"markdownIt-Anchor\" href=\"#equals\">#</a> equals()</h3>\n<h4 id=\"等价关系\"><a class=\"markdownIt-Anchor\" href=\"#等价关系\">#</a> 等价关系</h4>\n<ol>\n<li>自反性</li>\n</ol>\n<pre><code class=\"language-Java\">\nx.equals(x); // true\n\n</code></pre>\n<ol start=\"2\">\n<li>对称性</li>\n</ol>\n<pre><code class=\"language-Java\">\nx.equals(y) == y.equals(x); // true\n\n</code></pre>\n<ol start=\"3\">\n<li>传递性</li>\n</ol>\n<pre><code class=\"language-Java\">\nif(x.equals(y) &amp;&amp; y.equals(z))\n     x.equals(z); // true\n\n</code></pre>\n<ol start=\"4\">\n<li>一致性<br>\n多次调用 equals 方法的结果不变</li>\n</ol>\n<pre><code class=\"language-Java\">\nx.equals(y) == x.equals(y); // true\n\n</code></pre>\n<ol start=\"5\">\n<li>与 NULL 的比较<br>\n对于任何不是 NULL 的对象 x 调用 x.equals (null) 结果都为 false</li>\n</ol>\n<pre><code class=\"language-Java\">\nx.equals(null); // false\n\n</code></pre>\n<h4 id=\"equals与\"><a class=\"markdownIt-Anchor\" href=\"#equals与\">#</a> equals 与 ==</h4>\n<ul>\n<li>对于基本类型，== 判断连个值是否相等，基本类型没有 equals</li>\n<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals 判断引用对象的对象是否等价</li>\n</ul>\n<pre><code class=\"language-Java\">\nInteger x = new Integer(1);\nInteger y = new Integer(1);\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x == y);      // false\n\n</code></pre>\n<h4 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h4>\n<ul>\n<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>\n<li>检查是否是同一个类型，如果不是，直接返回 false；</li>\n<li>将 Object 对象进行转型；</li>\n<li>判断每个关键域是否相等。</li>\n</ul>\n<pre><code class=\"language-Java\">\npublic class EqualExample &#123;\n    private int x;\n    private int y;\n    private int z;\n\n    public EqualExample(int x, int y, int z) &#123;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    &#125;\n\n    @Override\n    public boolean equals(Object o) &#123;\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        EqualExample that = (EqualExample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    &#125;\n&#125;\n\n</code></pre>\n<h3 id=\"hashcode\"><a class=\"markdownIt-Anchor\" href=\"#hashcode\">#</a> hashCode()</h3>\n<p>hashCode 返回散列值，而 Equals 是用来判断两个对象是否等价。等价的两个对象的散列值一定相同，但散列值相同的两个对象不一定等价</p>\n<p>在重写 equals 方法的同时应当也重写 hashCode 方法，保证等价的两个对象散列值也相等</p>\n<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode () 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>\n<pre><code class=\"language-Java\">\nEqualExample e1 = new EqualExample(1, 1, 1);\nEqualExample e2 = new EqualExample(1, 1, 1);\nSystem.out.println(e1.equals(e2)); // true\nHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();\nset.add(e1);\nset.add(e2);\nSystem.out.println(set.size());   // 2\n\n</code></pre>\n<h3 id=\"tostring\"><a class=\"markdownIt-Anchor\" href=\"#tostring\">#</a> toString()</h3>\n<p>默认返回 ToStringExample@455617c 这种形式，其中 @后面的数值为散列码的无符号十六进制表示</p>\n<h3 id=\"clone\"><a class=\"markdownIt-Anchor\" href=\"#clone\">#</a> clone()</h3>\n<ol>\n<li>cloneable</li>\n</ol>\n<p>clone () 是 Object 的 protected 方法，他不是 public，一个类不去显示的重写 clone，其他类就不能直接去调用该类实例的 clone 方法</p>\n<p>重写 clone</p>\n<pre><code class=\"language-Java\">\npublic class CloneExample &#123;\n    private int a;\n    private int b;\n\n    @Override\n    protected CloneExample clone() throws CloneNotSupportedException &#123;\n        return (CloneExample)super.clone();\n    &#125;\n&#125;\n\n</code></pre>\n<p>但是此时调用该 clone 方法，还是会报错</p>\n<blockquote>\n<p>java.lang.CloneNotSupportedException: CloneExample</p>\n</blockquote>\n<p>尽管 clone 并不是 Cloneable 接口的方法，但 Cloneable 规定，如果一个类没有实现 Cloneable 接口又调用了 clone 方法，就会报 CloneNotSupportedException</p>\n<h4 id=\"浅拷贝\"><a class=\"markdownIt-Anchor\" href=\"#浅拷贝\">#</a> 浅拷贝</h4>\n<p>拷贝对象和原始对象的引用类型引用同一个对象</p>\n<pre><code class=\"language-Java\">\npublic class ShallowCloneExample implements Cloneable &#123;\n    private int[] arr;\n\n    public ShallowCloneExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n\n    @Override\n    protected ShallowCloneExample clone() throws CloneNotSupportedException &#123;\n        return (ShallowCloneExample) super.clone();\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\nShallowCloneExample e1 = new ShallowCloneExample();\nShallowCloneExample e2 = null;\ntry &#123;\n    e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 222\n\n</code></pre>\n<h4 id=\"深拷贝\"><a class=\"markdownIt-Anchor\" href=\"#深拷贝\">#</a> 深拷贝</h4>\n<p>拷贝对象和原始对象的引用类型引用不同对象</p>\n<pre><code class=\"language-Java\">\npublic class DeepCloneExample implements Cloneable &#123;\n    private int[] arr;\n\n    public DeepCloneExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n\n    @Override\n    protected DeepCloneExample clone() throws CloneNotSupportedException &#123;\n        DeepCloneExample result = (DeepCloneExample) super.clone();\n        result.arr = new int[arr.length];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            result.arr[i] = arr[i];\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\nDeepCloneExample e1 = new DeepCloneExample();\nDeepCloneExample e2 = null;\ntry &#123;\n    e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n</code></pre>\n<h2 id=\"关键字\"><a class=\"markdownIt-Anchor\" href=\"#关键字\">#</a> 关键字</h2>\n<h3 id=\"final\"><a class=\"markdownIt-Anchor\" href=\"#final\">#</a> final</h3>\n<ol>\n<li>\n<p>数据<br>\n声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能改变的常量</p>\n<ul>\n<li>对于基本类型，final 使数据值不变</li>\n<li>对于引用类型，final 使引用不变，也就不能引用其他对象，但是引用的对象本身使可以修改的</li>\n</ul>\n</li>\n<li>\n<p>方法<br>\n声明方法不能被字类重写<br>\n Private 方法隐式的被指定为 final，如果子类中定义的方法基类中的一个 private 方法名相同，此时子类的方法不是重写方法，而是在子类中定义了一个新方法</p>\n</li>\n<li>\n<p>类<br>\n声明该类不允许被继承</p>\n</li>\n</ol>\n<h3 id=\"static\"><a class=\"markdownIt-Anchor\" href=\"#static\">#</a> static</h3>\n<ol>\n<li>静态变量\n<ul>\n<li>静态变量：又称为类变量，也就是说这个变量是属于类的，类所有的额实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份</li>\n<li>实例变量：没创建一个实例，就会产生一个实例变量，它与该实例同生共死</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class A &#123;\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(String[] args) &#123;\n        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context\n        int yy = A.y;\n        A a = new A();\n        int x = a.x;\n        int y = A.y;\n    &#125;\n&#125;\n\n</code></pre>\n<ol start=\"2\">\n<li>静态方法<br>\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法 (abstract)。</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic abstract class A &#123;\n    public static void func1()&#123;\n    &#125;\n    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'\n&#125;\n\n</code></pre>\n<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 supper 关键字</p>\n<pre><code class=\"language-Java\">\npublic class Demo11 &#123;\n\n    private int a = 10;\n    private static int b = 20;\n\n    public static void main(String[] args) &#123;\n        // int aa = a; // Non-static field 'a' cannot be referenced from a static context\n        // this.fun(); // this' cannot be referenced from a static context\n        int bb = b;\n    &#125;\n\n    public void fun()&#123;\n        System.out.println(&quot;Demo11.fun&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<ol start=\"3\">\n<li>静态语句块</li>\n</ol>\n<p>静态语句块在类初始化时运行一次</p>\n<pre><code class=\"language-Java\">\npublic class A &#123;\n    static &#123;\n        System.out.println(&quot;123&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        A a1 = new A();\n        A a2 = new A();\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Html\">\n123\n\n</code></pre>\n<ol start=\"4\">\n<li>非静态内部类</li>\n</ol>\n<p>非静态内部类依赖于外部类的实例，而静态内部类不需要</p>\n<pre><code class=\"language-Java\">\npublic class OuterClass &#123;\n\n    class InnerClass &#123;\n\n    &#125;\n\n    static class StaticInnerClass&#123;\n\n    &#125;\n\n    public static void main(String[] args) &#123;\n        OuterClass outerClass = new OuterClass();\n        // InnerClass innerClass = new InnerClass(); // OuterClass.this' cannot be referenced from a static context\n        InnerClass innerClass = outerClass.new InnerClass();\n        StaticInnerClass staticInnerClass = new StaticInnerClass();\n    &#125;\n&#125;\n\n</code></pre>\n<p><strong>注意：静态内部类不能访问外部类的非静态变量和方法</strong></p>\n<ol start=\"5\">\n<li>静态导包</li>\n</ol>\n<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低</p>\n<pre><code class=\"language-Java\">\nimport static com.xxx.ClassName.*\n\n</code></pre>\n<ol start=\"6\">\n<li>初始化顺序</li>\n</ol>\n<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序，取决于它们在代码中的顺序</p>\n<pre><code class=\"language-Java\">\npublic class StaticDemo12 &#123;\n\n    private static String str = &quot;static str变量&quot;;\n\n    static &#123;\n        System.out.println(&quot;static 块&quot;);\n    &#125;\n\n    public String field = &quot;实例变量&quot;;\n\n\n    public StaticDemo12() &#123;\n        System.out.println(&quot;StaticDemo12.StaticDemo12&quot;);\n    &#125;\n\n    &#123;\n        System.out.println(&quot;普通语句块&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        StaticDemo12 staticDemo12 = new StaticDemo12();\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Html\">\nstatic 块\n普通语句块\nStaticDemo12.StaticDemo12\n\n</code></pre>\n<p>存在继承的情况下，初始化的顺序如下：</p>\n<ul>\n<li>父类 (静态变量、静态语句块)</li>\n<li>子类 (静态变量、静态语句块)</li>\n<li>父类 (实例变量、普通语句块)</li>\n<li>父类 (构造函数)</li>\n<li>子类 (实例变量、普通语句块)</li>\n<li>子类 (构造函数)</li>\n</ul>\n<h2 id=\"反射\"><a class=\"markdownIt-Anchor\" href=\"#反射\">#</a> 反射</h2>\n<p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的.class 文件，该文件内容保存着 Class 对象</p>\n<p>类加载相当于 Class 对象的加载，类在第一次使用时在动态加载到 JVM 中，可以使用 Class.forName (“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>\n<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的.class 不存在也可以加载进来</p>\n<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含以下三个类</p>\n<ul>\n<li>Field：可以使用 get () 和 set () 方法读取和修改 Field 对象关联的字段</li>\n<li>Method：可以使用 invoke () 方法调用与 Method 对象关联的方法</li>\n<li>Constructor：可以用 Constructor 创建新的对象</li>\n</ul>\n<h2 id=\"异常\"><a class=\"markdownIt-Anchor\" href=\"#异常\">#</a> 异常</h2>\n<p>Thorwable 可以用来表示任何可以作为异常抛出的类，分为两种：Error 和 Exception。其中 Error 表示 JVM 无法处理的错误，Exception 分为两种：</p>\n<ul>\n<li>受检异常：需要用 try…catch 语句捕获并进行处理，并且可以从一场中恢复</li>\n<li>非受检异常：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复</li>\n</ul>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/PPjwP.png\" alt=\"异常\"></p>\n<h2 id=\"泛型\"><a class=\"markdownIt-Anchor\" href=\"#泛型\">#</a> 泛型</h2>\n<pre><code class=\"language-Java\">\npublic class Box&lt;T&gt; &#123;\n    // T stands for &quot;Type&quot;\n    private T t;\n    public void set(T t) &#123; this.t = t; &#125;\n    public T get() &#123; return t; &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"注解\"><a class=\"markdownIt-Anchor\" href=\"#注解\">#</a> 注解</h2>\n<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
            "title": "函数式编程",
            "date_published": "2024-02-18T08:13:44.938Z",
            "content_html": "<h1 id=\"函数式编程\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程\">#</a> 函数式编程</h1>\n<p>一种 语法优雅、简洁健壮、高并发、易于测试和调试 的编程方式，这就是函数式编程 (FP) 的意义所在。</p>\n<blockquote>\n<p>OO (Object oriented, 面向对象) 是抽象数据<br>\n FP (Function programming, 函数式编程) 是抽象行为</p>\n</blockquote>\n<p>两个关键概念:</p>\n<blockquote>\n<ul>\n<li>函数是第一等公民</li>\n<li>函数要满足以下约束\n<ul>\n<li>函数的返回值仅取决于传递给函数的输入参数</li>\n<li>函数的执行没有副作用</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"函数是一等公民\"><a class=\"markdownIt-Anchor\" href=\"#函数是一等公民\">#</a> 函数是一等公民</h3>\n<blockquote>\n<p>在函数式编程范式中，函数是语言的第一等公民。这意味着可以创建函数的 “实例”，对函数实例的变量引用，就像对字符串、Map 或者任何其他对象的引用一样。函数也可以作为参数传递给其他函数。</p>\n</blockquote>\n<blockquote>\n<p>在 Java 中，函数显然不是第一等公民，类 (Class) 才是。所以 Java 才引用 Lambda 表达式，这个语法糖从表现层让 Java 拥有了函数，让函数可以作为变量的引用、方法的参数等等。（为什么说是从表现层呢？因为实际上，在编译的时候，Java 编译器还是会把 Lambda 表达式编译成类。</p>\n</blockquote>\n<hr>\n<h3 id=\"纯函数\"><a class=\"markdownIt-Anchor\" href=\"#纯函数\">#</a> 纯函数</h3>\n<p>函数式编程中，有个纯函数 (Pure Function) 的概念，如果一个函数满足以下条件，才是纯函数：</p>\n<ul>\n<li>该函数的执行没有副作用</li>\n<li>函数的返回值仅取决于传递给函数的输入参数</li>\n</ul>\n<pre><code class=\"language-Java\">public class ObjectWithPureFunction&#123;\n    public int sum(int a, int b)&#123;\n        return a+b;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"非纯函数\"><a class=\"markdownIt-Anchor\" href=\"#非纯函数\">#</a> 非纯函数</h3>\n<p>上面的 sum 方法的返回值仅取决于其输入参数，而且 sum 是没有副作用的，它不会在任何地方修改函数之外的任何状态 (变量)</p>\n<p>相反，这个一个非纯函数的例子:</p>\n<pre><code class=\"language-Java\">public class ObjectWithNonPureFunction&#123;\n    private int value = 0;\n\n    public int add(int nextValue) &#123;\n        this.value += nextValue;\n        return this.value;\n    &#125;\n&#125;\n</code></pre>\n<p>add 方法使用成员变量 value 来计算返回值，并且它还修改了 value 成员变量，这代表它有副作用，这两个条件都导致 add 方法不是一个纯函数</p>\n<hr>\n<h2 id=\"函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口\">#</a> 函数式接口</h2>\n<p>所谓函数式接口，实际上就是接口里面有且只能有一个抽象方法的接口。</p>\n<p>函数式接口也称为 单一抽象方法 (SAM) 接口</p>\n<h3 id=\"函数式接口的特点\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口的特点\">#</a> 函数式接口的特点</h3>\n<ul>\n<li>接口有且仅有一个抽象方法，如接口 Comparator</li>\n<li>允许出现 java.lang.Object 中的 public 方法，如 equals</li>\n<li>允许定义静态非抽象方法</li>\n<li>允许定义默认 default 非抽象方法 (default 方法式 java8 开始出现的)</li>\n<li>FunctionInterface 注解不是必须的，如果一个接口符合 “函数式接口” 的定义，那么不加该注解也没有影响</li>\n</ul>\n<blockquote>\n<p>甚至可以说：函数式接口是专门为 lambda 表达式准备的，lambda 表达式是只实现接口中唯一抽象方法的匿名实现类</p>\n</blockquote>\n<h3 id=\"default关键字\"><a class=\"markdownIt-Anchor\" href=\"#default关键字\">#</a> default 关键字</h3>\n<p>在 java8 之前</p>\n<ul>\n<li>接口是不能有方法的实现，所有的方法必须是抽象方法</li>\n<li>实现接口就必须实现接口里面的所有方法</li>\n</ul>\n<blockquote>\n<p>这样导致：当一个接口有很多实现类的时候，修改这个接口，就必须修改所有的实现类。</p>\n</blockquote>\n<p>不过在 java8 中这个问题得到解决，这就是 default 方法</p>\n<ul>\n<li>default 方法可以有自己的默认实现，即有方法体</li>\n<li>接口实现类可以不去实现 default 方法，并且可以使用 default 方法</li>\n</ul>\n<h3 id=\"jdk中函数式接口的举例\"><a class=\"markdownIt-Anchor\" href=\"#jdk中函数式接口的举例\">#</a> JDK 中函数式接口的举例</h3>\n<ul>\n<li>java.lang.Runnable,</li>\n<li>java.util.Comparator,</li>\n<li>java.util.concurrent.Callable</li>\n<li>java.util.function 包下的接口，如 Consumer、Predicate、Supplier 等</li>\n</ul>\n<blockquote>\n<p>编译器会根据 Lambda 表达式的参数和返回值类型推断出其实现的抽象方法，进而推断出其实现的接口，如果一个接口有多个抽象方法，显然是没有办法用 Lambda 表达式实现该接口的</p>\n</blockquote>\n<h3 id=\"functioninterface-注解\"><a class=\"markdownIt-Anchor\" href=\"#functioninterface-注解\">#</a> @FunctionInterface 注解</h3>\n<p><strong>标注接口是一个函数式接口的注解</strong></p>\n<pre><code class=\"language-Java\">@FunctionalInterface // 标明接口为函数式接口\npublic interface MyInterface &#123;\n    public void run(); //抽象方法\n&#125;\n</code></pre>\n<p>一旦使用了该注解标注接口，Java 的编译器会强制检查该接口是否满足函数式接口的要求：“确实仅有一个抽象方法”，否则将会报错</p>\n<p>需要注意的是，及时不适用该注解，只要有一个接口满足函数式接口的要求，那它仍然是一个函数式接口，使用起来都一样。该注解只起到标记接口指示编译器对其进行检查的作用</p>\n<h3 id=\"java内置的函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#java内置的函数式接口\">#</a> Java 内置的函数式接口</h3>\n<p><strong>Function</strong></p>\n<p>Function 接口（全限定名：java.util.function.Function）是 Java 中最核心的函数式接口。 Function 接口表示一个接受单个参数并返回单个值的函数（方法）</p>\n<p><strong>Predicate</strong></p>\n<p>Predicate 接口 （全限定名：java.util.function.Predicate）表示一个接收单个参数，并返回布尔值 true 或 false 的函数</p>\n<p><strong>Supplier</strong></p>\n<p>Supplier 接口（java.util.function.Supplier），表示提供某种值的函数</p>\n<p><strong>Consume</strong></p>\n<p>Consumer 接口（java.util.function.Consume）表示一个函数，该函数接收一个参数，但是不返回任何值</p>\n<p><strong>Optional</strong></p>\n<p>Optional 接口并不是一个函数式接口，它常在 Stream 操作中出现，作为操作的返回值类型。</p>\n<p>Optional 接口是预防 NullPointerException 的好工具，它是一个简单的容器，其值可以是 null 或非 null。比如一个可能返回一个非空结果的方法，方法在有些情况下返回值，有些情况不满足返回条件返回空值，这种情况下使用 Optional 接口作为返回类型，比直接无值时返回 Null 要更安全</p>\n<hr>\n<h2 id=\"lambda表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda表达式\">#</a> Lambda 表达式</h2>\n<h3 id=\"双冒号语法\"><a class=\"markdownIt-Anchor\" href=\"#双冒号语法\">#</a> 双冒号语法</h3>\n<p>其实双冒号就是 lambda 表达式的简写。被用作方法的引用。使用 lambda 表达式会创建匿名方法，但是有时候会需要一个 lambda 表达式只调用一个已经存在的方法，在此才有了方法的引用</p>\n<ol>\n<li>静态方法的引用 (static method)</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Demo &#123;\n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//静态方法语法\tClassName::methodName\n\t\tlist.forEach(Demo::print);\n\t&#125;\n\t\n\tpublic static void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>对象实例方法的引用</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Demo &#123;\n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//静态方法语法\tClassName::methodName\n\t\tlist.forEach(new Demo()::print);\n\t&#125;\n\t\n\tpublic void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>对象的超类方法引用</li>\n</ol>\n<pre><code class=\"language-Java\">public class Example extends BaseExample&#123;\n \n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//对象的超类方法语法： super::methodName \n\t\tlist.forEach(super::print);\n\t&#125;\n&#125;\n \nclass BaseExample &#123;\n\tpublic void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>类构造器引用</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Example &#123;\n \n\t@Test\n\tpublic void test() &#123;\n\t\tInterfaceExample com =  Example::new;\n\t\tExample bean = com.create();\n        Example bean = com.create(&quot;STRING&quot;);\n\t\tSystem.out.println(bean);\n\t&#125;\n&#125;\n \ninterface InterfaceExample&#123;\n    //不带参数\n\tExample create();\n    //带参数\n    Example create(String str);\n&#125;\n</code></pre>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/Stream%E6%B5%81/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/Stream%E6%B5%81/",
            "title": "Stream流式编程",
            "date_published": "2024-02-18T08:13:44.938Z",
            "content_html": "<h1 id=\"stream流式编程\"><a class=\"markdownIt-Anchor\" href=\"#stream流式编程\">#</a> Stream 流式编程</h1>\n<h2 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类</h2>\n<p><img data-src=\"/image/Java/13170952_625693608975b29303.webp\" alt=\"分类图片\"></p>\n<p><strong>中间操作</strong>可分为：</p>\n<blockquote>\n<ul>\n<li>无状态：指元素的处理不受之前元素的影响</li>\n<li>有状态：指该操作只有拿到所有元素之后才能继续下去</li>\n</ul>\n</blockquote>\n<p><strong>终结操作</strong>可分为：</p>\n<blockquote>\n<ul>\n<li>非短路操作：指必须处理所有元素才能得到最终结果</li>\n<li>短路操作：指遇到某些符合条件的元素就可以得到最终结果</li>\n</ul>\n</blockquote>\n<p>具体操作如图所示：</p>\n<p><img data-src=\"/image/Java/20201218181011714.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"stream-api使用\"><a class=\"markdownIt-Anchor\" href=\"#stream-api使用\">#</a> Stream API 使用</h2>\n<h3 id=\"流的构成\"><a class=\"markdownIt-Anchor\" href=\"#流的构成\">#</a> 流的构成</h3>\n<blockquote>\n<p>使用流的时候，通常包括三个步骤：</p>\n<ol>\n<li>获取一个数据源</li>\n<li>数据转换<br>\n执行操作获取想要的结果，每次转换原有的 Stream 对象不变，返回一个新的 Stream 对象，这就允许对其操作可以像链条一样排列</li>\n</ol>\n</blockquote>\n<h3 id=\"流的创建\"><a class=\"markdownIt-Anchor\" href=\"#流的创建\">#</a> 流的创建</h3>\n<ul>\n<li>\n<p>通过 java.util.Collection.stream () 方法用集合创建流</p>\n<pre><code class=\"language-Java\">\n  List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;stream&quot;);\n  //创建顺序流\n  Stream&lt;String&gt; stream = list.stream();\n  //创建并行流\n  Stream&lt;String&gt; parallelStream = list.parallelStream();\n\n</code></pre>\n</li>\n<li>\n<p>使用 java.util.Arrays.stream (T [] array) 方法用数组创建流</p>\n<pre><code class=\"language-Java\">\n  String[] array = &#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;&#125;;\n  Stream&lt;String&gt; arrayStream = Arrays.stream(array);\n\n</code></pre>\n</li>\n<li>\n<p>Stream 的静态方法：of ()、iterate ()、generate ()</p>\n<pre><code class=\"language-Java\">\n  Stream&lt;Integer&gt; stream1 = Stream.of(1, 2, 3, 4, 5, 6);\n  \n  Stream&lt;Integer&gt; stream2 = Stream.iterate(0, (x) -&gt; x + 2).limit(3);\n  \n  Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(3);\n\n</code></pre>\n</li>\n<li>\n<p>stream 和 parallelStream 的简单区分</p>\n</li>\n</ul>\n<blockquote>\n<p>stream 是顺序流，由主线程按顺序对流执行操作，而 parallelStream 是并行流，内部以多线程并行执行的方式对流进行操作，需要注意使用并行流的前提是流中的数据处理没有顺序要求（会乱序，即使用了 forEachOrdered）</p>\n</blockquote>\n<hr>\n<h3 id=\"一-stream中间操作\"><a class=\"markdownIt-Anchor\" href=\"#一-stream中间操作\">#</a> 一、Stream 中间操作</h3>\n<pre><code>Stream流中间操作是指在流链当中，可以对数据进行处理操作，包括filter过滤、map映射转换、flatMap合并、distinct去重、sorted排序等操作，这些操作都会返回一个新的Stream流对象，可以通过链式调用多个中间操作进行复杂的数据处理。\n\n需要注意的是，中间操作需要具有终止操作才会触发。\n</code></pre>\n<h4 id=\"无状态stateless操作\"><a class=\"markdownIt-Anchor\" href=\"#无状态stateless操作\">#</a> 无状态 (Stateless) 操作</h4>\n<h5 id=\"filter过滤出符合条件的元素\"><a class=\"markdownIt-Anchor\" href=\"#filter过滤出符合条件的元素\">#</a> filter: 过滤出符合条件的元素</h5>\n<blockquote>\n<p>filter () 方法常用于实现数据过滤，即可以对集合、数组等数据源筛选出符合指定条件的元素，并返回一个新的流</p>\n</blockquote>\n<pre><code class=\"language-Java\">// 将数组转换为一个字符串列表\nList&lt;String&gt; numbers = Arrays.asList&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13358520000&quot;);\n// 通过stream()方法创建一个流，接着使用filter方法过滤出前缀为&quot;133&quot;的元素，最终通过collect()方法将结果收集到一个新的列表中\nList&lt;String&gt; filterNumbers = numbers.stream().filter(s -&gt; s.startWith(&quot;133&quot;)).collect(Collectors.toList());\nSystem.out.println(filterNumbers);\n\n打印结果：[13378520000, 13358520000]\n</code></pre>\n<hr>\n<h5 id=\"map映射转换元素\"><a class=\"markdownIt-Anchor\" href=\"#map映射转换元素\">#</a> map: 映射转换元素</h5>\n<blockquote>\n<p>map 方法用于对流中的每个元素进行映射操作，将其转换为另一个元素或者提取其中的信息，并返回一个新的流</p>\n</blockquote>\n<p>1.2.1 转换元素</p>\n<blockquote>\n<p>获取每个手机号的前七位子字符串</p>\n</blockquote>\n<pre><code class=\"language-Java\">List&lt;String&gt; numbers = Arrays.asList(&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13558520000&quot;);\n//通过stream()方法创建一个流，使用map()方法将每个字符串转换为截取前7位的字符，最后使用collect()方法将结果收集到一个新列表中\nList&lt;String&gt; filterdNumbers = numbers.stream().map(s -&gt; s.substring(0,7)).collect(Collectors.toList());\nSystem.out.println(filterdNumbers);\n\n\n打印结果：[1337852, 1327852, 1317852, 1355852]\n\n</code></pre>\n<hr>\n<p>1.2.2 提取元素信息</p>\n<blockquote>\n<p>获取每个对象的手机号</p>\n</blockquote>\n<pre><code class=\"language-Java\">List&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,&quot;13378520000&quot;),\n        new People(&quot;李二&quot;,&quot;13278520000&quot;),\n        new People(&quot;张四&quot;,&quot;13178520000&quot;)\n);\n//通过stream()方法创建一个流，使用map()方法提取每个用户的手机号，最后使用collect()方法将结果收集到一个新列表中\nList&lt;String&gt; tel = peopleList.stream().map(People::getTel).collect(Collectors.toList());\nSystem.out.println(tel);\n\n\n打印结果：[13378520000, 13278520000, 13178520000]\n</code></pre>\n<hr>\n<h5 id=\"flatmap将多个流合并为一个流\"><a class=\"markdownIt-Anchor\" href=\"#flatmap将多个流合并为一个流\">#</a> flatMap: 将多个流合并为一个流</h5>\n<p>1.3.1 实现多对多的映射</p>\n<blockquote>\n<p>将 A 组数据和 B 组数据一次进行相加</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;Integer&gt; listA = Arrays.asList(1,2,3);\nList&lt;Integer&gt; listB = Arrays.asList(4, 5, 6);\nList&lt;Integer&gt; list = listA.stream().flatMap(a -&gt; listB.stream().map(b -&gt; a +b)).collect(Collectors.toList());\nSystem.out.println(list);\n\n\n打印结果:  [5, 6, 7, 6, 7, 8, 7, 8, 9]\n</code></pre>\n<hr>\n<p>1.3.2 将多个列表合并成一个列表</p>\n<pre><code class=\"language-Java\">\nList&lt;List&lt;String&gt;&gt; listOfLists = Arrays.asList(\n        Arrays.asList(&quot;13378520000&quot;, &quot;13278520000&quot;),\n        Arrays.asList(&quot;13178520000&quot;, &quot;13558520000&quot;),\n        Arrays.asList(&quot;15138510000&quot;, &quot;15228310000&quot;)\n);\nList&lt;String&gt; flatMapList = listOfLists.stream().flatMap(Collection::stream).collect(Collectors.toList());\nSystem.out.println(flatMapList);\n\n\n打印结果：[13378520000, 13278520000, 13178520000, 13558520000, 15138510000, 15228310000]\n\n</code></pre>\n<hr>\n<h5 id=\"peek查看每个元素的信息但不改变流中元素的状态\"><a class=\"markdownIt-Anchor\" href=\"#peek查看每个元素的信息但不改变流中元素的状态\">#</a> peek: 查看每个元素的信息，但不改变流中元素的状态</h5>\n<pre><code class=\"language-Java\">\nList&lt;String&gt; telList = Arrays.asList(&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13558520000&quot;);\ntelList.stream().peek(t -&gt; System.out.println(t))\n        .map(t -&gt; t.substring(0,3))\n        .peek(t -&gt; System.out.println(t))\n        .collect(Collectors.toList());\n\n</code></pre>\n<hr>\n<p><strong>重点:</strong> peek VS map</p>\n<blockquote>\n<p>peek 操作一般用于 不想改变流中元素本身的类型或者只想元素的内部状态改变时<br>\n map 则用于改变流中元素本身，即从元素中派生出另一种类型的操作</p>\n</blockquote>\n<hr>\n<h5 id=\"maptoint-maptolong-maptodouble-flatmaptodouble-flatmaptoint-flatmaptolong\"><a class=\"markdownIt-Anchor\" href=\"#maptoint-maptolong-maptodouble-flatmaptodouble-flatmaptoint-flatmaptolong\">#</a> mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong</h5>\n<blockquote>\n<p>以上操作是 map 和 flatMap 的特别版，也就是针对特定的数据类型进行映射处理</p>\n<p>其对应方法如下：</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nIntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);\n \nLongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper); \n \nDoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);\n \nIntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);\n \nLongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);\n \nDoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);\n\n</code></pre>\n<hr>\n<h4 id=\"有状态stateful操作\"><a class=\"markdownIt-Anchor\" href=\"#有状态stateful操作\">#</a> 有状态 (Stateful) 操作</h4>\n<h5 id=\"distinct去除重复的元素\"><a class=\"markdownIt-Anchor\" href=\"#distinct去除重复的元素\">#</a> distinct: 去除重复的元素</h5>\n<blockquote>\n<p>distinct () 方法可以用来去除流中的重复元素，生成无重复的列表<br>\n需要注意的是：distinct 用于针对流元素去重操作时，需要确定流中的元素实现了 equals () 和 hasCode () 方法</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;String&gt; numbers = Arrays.asList(&quot;13378520000&quot;, &quot;15138510000&quot;,&quot;13178520000&quot;, &quot;15138510000&quot;);\nList&lt;String&gt; disNumbers = numbers.stream().distinct().collect(Collectors.toList());\nSystem.out.println(disNumbers);\t\t\n\n\n打印结果：[13378520000, 15138510000, 13178520000]\n\n</code></pre>\n<hr>\n<h5 id=\"15-sorted排序元素\"><a class=\"markdownIt-Anchor\" href=\"#15-sorted排序元素\">#</a> 1.5 sorted: 排序元素</h5>\n<blockquote>\n<p>sorted 方法用于对流中元素进行排序</p>\n</blockquote>\n<p>1.5.1 升序排序</p>\n<pre><code class=\"language-Java\">\nList&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,20),\n        new People(&quot;李二&quot;,30),\n        new People(&quot;张四&quot;,31)\n);\nList&lt;People&gt; newpeopleList=peopleList.stream().sorted(Comparator.comparing(People::getAge)).collect(Collectors.toList());\n//打印结果\nnewpeopleList.stream().forEach(System.out::println);\n\n\n打印结果：\nPeople&#123;name='王二', age=20&#125;\nPeople&#123;name='李二', age=30&#125;\nPeople&#123;name='张四', age=31&#125;\n\n</code></pre>\n<p>1.5.2 降序排序</p>\n<blockquote>\n<p>通过 reversed () 方法进行逆序排序</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,20),\n        new People(&quot;李二&quot;,30),\n        new People(&quot;张四&quot;,31)\n);\nList&lt;People&gt; newpeopleList = peopleList.stream().sorted(Comparator.comparing(People::getAge).reversed()).collect(Collectors.toList());\n//打印结果\nnewpeopleList.stream().forEach(System.out::println);\n\n打印结果：\nPeople&#123;name='张四', age=31&#125;\nPeople&#123;name='李二', age=30&#125;\nPeople&#123;name='王二', age=20&#125;\n\n</code></pre>\n<hr>\n<h5 id=\"17-limit和skip截取流中的部分元素\"><a class=\"markdownIt-Anchor\" href=\"#17-limit和skip截取流中的部分元素\">#</a> 1.7 limit 和 skip: 截取流中的部分元素</h5>\n<blockquote>\n<p>limit 返回一个包含前 n 个元素的新流<br>\n skip 返回一个丢弃前 n 个元素后剩余元素组成的新流</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nint[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;\nSystem.out.print(&quot;取数组前5个元素:&quot;);\nArrays.stream(arr).limit(5).forEach(n -&gt; System.out.print(n + &quot; &quot;)); // 输出结果为：1 2 3 4 5\n\nSystem.out.print(&quot;跳过前3个元素，取剩余数组元素:&quot;);\nArrays.stream(arr).skip(3).forEach(n -&gt; System.out.print(n + &quot; &quot;)); // 输出结果为：4 5 6 7 8 9 10\n\n</code></pre>\n<hr>\n<h3 id=\"终结操作terminal-operation\"><a class=\"markdownIt-Anchor\" href=\"#终结操作terminal-operation\">#</a> 终结操作 (Terminal Operation)</h3>\n<h4 id=\"短路short-circuiting操作\"><a class=\"markdownIt-Anchor\" href=\"#短路short-circuiting操作\">#</a> 短路 (Short-circuiting) 操作</h4>\n<ul>\n<li>anyMatch: Stream 中只要有一个元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean anyMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>allMatch: Stream 中全部元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean allMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>noneMatch: Stream 中没有一个元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean noneMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>findFirst: 用于返回满足条件的第一个元素 (凡是该元素是封装在 Optional 类中)</li>\n</ul>\n<blockquote>\n<p>Optional<T> findFirst();</p>\n</blockquote>\n<ul>\n<li>findAny: 返回流中的任意元素 (但是该元素也是封装在 Optional 类中)</li>\n</ul>\n<blockquote>\n<p>Optional<T> findAny();</p>\n</blockquote>\n<hr>\n<h4 id=\"非短路操作\"><a class=\"markdownIt-Anchor\" href=\"#非短路操作\">#</a> 非短路操作</h4>\n<h5 id=\"foreach\"><a class=\"markdownIt-Anchor\" href=\"#foreach\">#</a> forEach()</h5>\n<p>该方法接收一个 lambda 表达式，然后在 Stream 的每一个元素上执行该表达式</p>\n<blockquote>\n<p>void forEach(Consumer&lt;? super T&gt; action);</p>\n</blockquote>\n<hr>\n<h5 id=\"foreachordered\"><a class=\"markdownIt-Anchor\" href=\"#foreachordered\">#</a> forEachOrdered()</h5>\n<p>该方法接收一个 Lambda 表达式，然后按顺序在 Stream 中的每一个元素上执行该表达式</p>\n<blockquote>\n<p>void forEachOrdered(Consumer&lt;? super T&gt; action);</p>\n</blockquote>\n<p>该功能其实和 forEach 是很相似的，也是循环操作！那唯一的区别，就在于 forEachOrdered 是可以保证循环时元素是按原来的顺序逐个循环的！</p>\n<hr>\n<h5 id=\"toarray\"><a class=\"markdownIt-Anchor\" href=\"#toarray\">#</a> toArray()</h5>\n<p>返回包含此流元素的数组，当有参数时，</p>\n<blockquote>\n<p>Object [] toArray();</p>\n</blockquote>\n<blockquote>\n<p><A> A[] toArray(IntFunction&lt;A[]&gt; generator);</p>\n</blockquote>\n<p>举例：</p>\n<pre><code class=\"language-Java\">\n\nList&lt;String&gt; strList = Arrays.asList( &quot;Jhonny&quot;, &quot;David&quot;, &quot;Jack&quot;, &quot;Duke&quot;, &quot;Jill&quot;,&quot;Dany&quot;,&quot;Julia&quot;,&quot;Jenish&quot;,&quot;Divya&quot;);\n \nObject [] strAryNoArg = strList.stream().toArray();\nString [] strAry = strList.stream().toArray(String[]::new);\n\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/Java%E9%94%81/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/Java%E9%94%81/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.938Z",
            "content_html": "<h2 id=\"java并发-java中所有的锁\"><a class=\"markdownIt-Anchor\" href=\"#java并发-java中所有的锁\">#</a> Java 并发 - Java 中所有的锁</h2>\n<p>Java 中往往按照是否含有某一特性来定义锁，通过特性将锁进行分组归类。</p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-lock-1.png\" alt=\"img\"></p>\n<h3 id=\"乐观锁vs悲观锁\"><a class=\"markdownIt-Anchor\" href=\"#乐观锁vs悲观锁\">#</a> 乐观锁 VS 悲观锁</h3>\n<h4 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h4>\n<p>​\t悲观锁：在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java 中，synchronized 关键字和 Lock 的实现类都是悲观锁。</p>\n<p>​\t乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只有在更新数据的时候回去判断之前有没有其它线程更新了这个数据。如果没有被更新，则将自己家的数据写入，如果已经被更新，则根据不同的实现方式去执行不同的操作（例如报错或者自动重试）。乐观锁是 Java 中通过无锁编程来实现的，最常采用的是 CAS 算法，Java 原子类中的递增操作就是通过 CAS 自旋实现的。</p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-lock-2.png\" alt=\"img\"></p>\n<h4 id=\"使用场景\"><a class=\"markdownIt-Anchor\" href=\"#使用场景\">#</a> 使用场景</h4>\n<ul>\n<li><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。</li>\n<li><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//------------------------- 悲观锁的调用方式 -------------------------</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// synchronized</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token comment\">// 操作同步资源</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// ReentrantLock</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">ReentrantLock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 需要保证多个线程使用的是同一个锁</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">modifyPublicResources</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tlock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token comment\">// 操作同步资源</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tlock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">//------------------------- 乐观锁的调用方式 -------------------------</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">AtomicInteger</span> atomicInteger <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 需要保证多个线程使用的是同一个 AtomicInteger</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>atomicInteger<span class=\"token punctuation\">.</span><span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 执行自增 1</span></pre></td></tr></table></figure><h3 id=\"自旋锁vs适应性自旋锁\"><a class=\"markdownIt-Anchor\" href=\"#自旋锁vs适应性自旋锁\">#</a> 自旋锁 VS 适应性自旋锁</h3>\n<p>​\t阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>​\t在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>​\t而为了让当前线程 “稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-lock-4.png\" alt=\"img\"></p>\n<p>​\t自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是 10 次，可以使用 - XX:PreBlockSpin 来更改）没有成功获得锁，就应当挂起线程。</p>\n<p>​\t自旋锁的实现原理同样也是 CAS，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>\n<h3 id=\"无锁vs偏向锁vs轻量级锁vs重量级锁\"><a class=\"markdownIt-Anchor\" href=\"#无锁vs偏向锁vs轻量级锁vs重量级锁\">#</a> 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3>\n<p>​\t这四种锁是指锁的状态，专门针对 synchronized 的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p>\n<p>​\t总结而言： 偏向锁通过对比 Mark Word 解决加锁问题，避免执行 CAS 操作。而轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-lock-6.png\" alt=\"img\"></p>\n<h3 id=\"公平锁vs非公平锁\"><a class=\"markdownIt-Anchor\" href=\"#公平锁vs非公平锁\">#</a> 公平锁 VS 非公平锁</h3>\n<p>​\t公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大。</p>\n<p>​\t非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>\n<h3 id=\"可重入锁vs非可重入锁\"><a class=\"markdownIt-Anchor\" href=\"#可重入锁vs非可重入锁\">#</a> 可重入锁 VS 非可重入锁</h3>\n<p>​\t可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提是锁对象得时同一个对象或者 class），不会因为之前已经获取过还没有释放而阻塞。Java 中 ReentrantLock 和 synchronized 都是可重入锁，可重入锁的一个优点时可一定程度避免死锁。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"方法1执行...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">doOthers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doOthers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"方法2执行...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"独享锁排他锁vs共享锁\"><a class=\"markdownIt-Anchor\" href=\"#独享锁排他锁vs共享锁\">#</a> 独享锁（排他锁）VS 共享锁</h3>\n<h4 id=\"概念-2\"><a class=\"markdownIt-Anchor\" href=\"#概念-2\">#</a> 概念</h4>\n<p>​\t独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程 T 对数据 A 加上排它锁后，则其他线程不能对 A 加任何类型的锁。获得排他锁的线程即能读数据又能修改数据。JDK 中的 synchronized 和 JUC 中的 Lock 的实现类就是互斥锁（排他锁）。</p>\n<p>​\t共享锁是指该锁可被多个线程所持有。如果线程 T 对线程 A 加上共享锁后，则其他线程只能对 A 再加共享锁，不能加排他锁。获得共享锁的线程只能读数据，不能修改数据。</p>\n<p>​\t** 独享锁和共享锁也是通过 AQS 来实现的。** 通过实现不同方法，来实现独享或者共享。</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.938Z",
            "content_html": "<h2 id=\"并发-理论基础\"><a class=\"markdownIt-Anchor\" href=\"#并发-理论基础\">#</a> 并发 - 理论基础</h2>\n<hr>\n<h3 id=\"为什么需要多线程\"><a class=\"markdownIt-Anchor\" href=\"#为什么需要多线程\">#</a> 为什么需要多线程？</h3>\n<h4 id=\"cpu内存io设备速度有差异为了平衡三者速度差异\"><a class=\"markdownIt-Anchor\" href=\"#cpu内存io设备速度有差异为了平衡三者速度差异\">#</a> CPU，内存，I/O 设备速度有差异，为了平衡三者速度差异。</h4>\n<ol>\n<li>CPU 增加了缓存，以均衡与内存速度的差异。导致 “可见性 “ 问题</li>\n<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异。导致 ” 原子性 “ 问题。</li>\n<li>编译程序优化指令执行次序，使得缓存能够得到更加合理的利用。导致 ” 有序性 “ 问题。</li>\n</ol>\n<h4 id=\"线程不安全实例\"><a class=\"markdownIt-Anchor\" href=\"#线程不安全实例\">#</a> 线程不安全实例</h4>\n<p>多个线程对同一个共享数据进行访问而不采取同步操作的话，操作的结果是不一致的。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadUnsafeExample</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        cnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">return</span> cnt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> threadSize <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token class-name\">ThreadUnsafeExample</span> example <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadUnsafeExample</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token class-name\">CountDownLatch</span> countDownLatch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CountDownLatch</span><span class=\"token punctuation\">(</span>threadSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> threadSize<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            example<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">countDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>example<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><pre><code>857\t// 结果总是小于1000\n</code></pre>\n<h4 id=\"并发问题的根源\"><a class=\"markdownIt-Anchor\" href=\"#并发问题的根源\">#</a> 并发问题的根源</h4>\n<ol>\n<li>\n<p>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到。</p>\n<pre><code>//线程1执行的代码\nint i = 0;\ni = 10;\n \n//线程2执行的代码\nj = i;\n假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n</code></pre>\n</li>\n<li>\n<p>原子性：即一个操作或者多个操作要么全部执行并且执行过程不会被任何因素打断，要么就都不执行。</p>\n<pre><code>int i = 1;\n\n// 线程1执行\ni += 1;\n\n// 线程2执行\ni += 1;\n由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。# 有序性: 重排序引起\n</code></pre>\n</li>\n<li>\n<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>\n<hr>\n</li>\n</ol>\n<h3 id=\"java是怎么解决并发问题的jmmjava内存模型\"><a class=\"markdownIt-Anchor\" href=\"#java是怎么解决并发问题的jmmjava内存模型\">#</a> JAVA 是怎么解决并发问题的：JMM（JAVA 内存模型）</h3>\n<h4 id=\"第一-维度\"><a class=\"markdownIt-Anchor\" href=\"#第一-维度\">#</a> 第一 维度</h4>\n<p>JMM 本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法，具体包括：</p>\n<p>​\t1. volatile、synchronized 和 final 三个关键字</p>\n<p>​\t2. Happens-Before 规则</p>\n<h4 id=\"第二维度\"><a class=\"markdownIt-Anchor\" href=\"#第二维度\">#</a> 第二维度</h4>\n<pre><code>1. 原子性：Java内存模型中，只保证基本的读取和赋值是原子性操作，要实现更大范围的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，从而保证了原子性。\n1. 可见性：Java提供了一个volatile关键字来保证可见性。当一个共享变量被volatile关键字修饰时，它会保证修改的值立即被更新到主存中，当其他线程需要读取时，它会去内存中读取新值。另外，通过synchronized和Lock也能保证可见性，在释放锁之前会将对变量的修改刷新到主存当中，因此也可以保证可见性。\n1. 有序性：在Java中，可以通过volatile关键字保证有序性，另外可以通过synchronized和Lock来保证有序性。当然JMM是通过 ”Happens-Before“ 规则来保证有序性的。\n</code></pre>\n<h5 id=\"happens-before原则\"><a class=\"markdownIt-Anchor\" href=\"#happens-before原则\">#</a> Happens-Before 原则</h5>\n<pre><code>1. 单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。\n1. 管程锁定规则：一个unlock操作先行发生与后面对同一个锁的lock操作。\n1. volatile变量规则：对一个volatile变量的写操作，先行发生与后面对这个变量的读操作。\n1. 线程启动规则：Thread对象的start()方法调用先行发生于此线程的每一个动作。\n1. 线程加入规则：Thread对象的结束先行发生于join()方法返回。\n1. 线程中断规则：对线程interrupt()方法的调用先行发生与被中断线程的代码检测到到中断事件的发生，可以通过interrupted()方法检测到是否又中断发生。\n1. 对象终结规则：一个对象的初始化完成先行发生与它的finalize()方法的开始。\n1. 传递性：如果操作A先行发生与操作B，操作B先行发生与操作C，那么操作A先行发生与操作C。\n</code></pre>\n<h4 id=\"线程安全\"><a class=\"markdownIt-Anchor\" href=\"#线程安全\">#</a> 线程安全？</h4>\n<p>将共享数据按照安全程度的强弱顺序分为一下五类：不可变、绝对线程安全、相对线程安全、线程兼容、线程对立。</p>\n<h4 id=\"线程安全的实现方法\"><a class=\"markdownIt-Anchor\" href=\"#线程安全的实现方法\">#</a> 线程安全的实现方法</h4>\n<ol>\n<li>\n<p>互斥同步：synchronized 和 ReentrantLock</p>\n<p>​\t互斥同步最主要的问题就是线程的阻塞和唤醒所带来的性能问题，因此这种同步也叫阻塞同步。</p>\n<p>​\t互斥同步属于一种悲观的并发策略，无论共享数据是否真的会出现竞争，它都要进行加锁。</p>\n</li>\n<li>\n<p>非阻塞同步：基于冲突检测的乐观并发策略，先进行操作，如果没有竞争，那就操作成功，否则才去补偿措施（不断重试，直到成功为止），这种策略不需要阻塞线程，因此这种同步操作也被称为非阻塞同步。</p>\n<p>​\t乐观锁需要操作和冲突检测这两个步骤具备原子性，这里不能使用互斥同步来保证了，而是靠硬件来完成。硬件支持的原子性操作最典型的是：<strong>比较并交换（Compare-and-Swap，CAS)。CAS 指令需要又三个操作数，分别是内存地址 V，旧的预期值 A 和新值 B，当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</strong></p>\n<p>​\tJUC 包中的整数原子类 AtomicInteger，其中的 compareAndSet () 和 getAndIncrement () 等方法都使用了 Unsafe 类的 CAS 操作。</p>\n<p>​\t<strong>ABA 问题：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</strong></p>\n<p>​\tJ.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>\n</li>\n<li>\n<p>无同步方案</p>\n<p>​\t要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，它自然无须任何同步措施去保证正确性。</p>\n<h5 id=\"栈封闭\"><a class=\"markdownIt-Anchor\" href=\"#栈封闭\">#</a> 栈封闭</h5>\n<p>​\t多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的</p>\n<h5 id=\"线程本地存储thread-local-storage\"><a class=\"markdownIt-Anchor\" href=\"#线程本地存储thread-local-storage\">#</a> 线程本地存储 (Thread Local Storage)</h5>\n<h5 id=\"可重入代码reentrant-code\"><a class=\"markdownIt-Anchor\" href=\"#可重入代码reentrant-code\">#</a> 可重入代码 (Reentrant Code)</h5>\n<p>​\t这种代码也叫纯代码 (Pure Code), 可以在代码执行的任何时刻中断它，转而去执行另一段代码，而在控制权返回后，原来的程序不会出现任何错误。</p>\n<p>特点:</p>\n<p>​\t不依赖存储在堆上的数据和公共的系统资源。</p>\n<p>​\t用到的状态量都由参数中传入。</p>\n<p>​\t不调用非可重入方法等。</p>\n</li>\n</ol>\n<h2 id=\"并发-线程基础\"><a class=\"markdownIt-Anchor\" href=\"#并发-线程基础\">#</a> 并发 - 线程基础</h2>\n<h3 id=\"线程状态转换\"><a class=\"markdownIt-Anchor\" href=\"#线程状态转换\">#</a> 线程状态转换</h3>\n<p><img data-src=\"https://pdai.tech/images/pics/ace830df-9919-48ca-91b5-60b193f593d2.png\" alt=\"image\"></p>\n<ol>\n<li>新建（NEW）：创建后尚未启动。</li>\n<li>可运行（Runnable）：可能正在运行，也可能正在等待 CPU 时间片。包含了操作系统线程状态的 Running 和 Ready。</li>\n<li>阻塞（Blocking）：等待获取一个排它锁，如果其它线程释放了锁就会结束此状态。</li>\n<li>无限期等待（Waiting）：等待其他线程显示地唤醒，否则不会被分配 CPU 时间片。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>进入方法</strong></th>\n<th><strong>退出方法</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">没有设置 Timeout 参数的 Object.wait () 方法</td>\n<td>Object.notify() / Object.notifyAll()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">没有设置 Timeout 参数的 Thread.join () 方法</td>\n<td>被调用的线程执行完毕</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LockSupport.park () 方法</td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"5\">\n<li>\n<p>限期等待（Timed Waiting）：无需等待其他线程显式的唤醒，在一定时间之后会被系统自动唤醒。</p>\n<p>​\t调用 Thread.sleep () 方法使线程进入限期等待状态时，常常用 “使一个线程睡眠” 进行描述。</p>\n<p>​\t调用 Object.wait () 方法使线程进入限期等待或者无限期等待时，常常用 “挂起一个线程” 进行描述。</p>\n<p>​\t睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>\n<p>​\t阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep () 和 Object.wait () 等方法进入。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>进入方法</strong></th>\n<th style=\"text-align:center\"><strong>退出方法</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Thread.sleep () 方法</td>\n<td style=\"text-align:center\">时间结束</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">设置了 Timeout 参数的 Object.wait () 方法</td>\n<td style=\"text-align:center\">时间结束 / Object.notify () / Object.notifyAll ()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">设置了 Timeout 参数的 Thread.join () 方法</td>\n<td style=\"text-align:center\">时间结束 / 被调用的线程执行完毕</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LockSupport.parkNanos () 方法</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LockSupport.parkUntil () 方法</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>死亡（Terminated)</p>\n<p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>\n</li>\n</ol>\n<h3 id=\"线程的使用方式\"><a class=\"markdownIt-Anchor\" href=\"#线程的使用方式\">#</a> 线程的使用方式</h3>\n<pre><code>1. 实现Runnable接口。\n1. 实现Callable接口。\n1. 继承Thread类。\n</code></pre>\n<h4 id=\"实现接口-vs-继承-thread\"><a class=\"markdownIt-Anchor\" href=\"#实现接口-vs-继承-thread\">#</a> 实现接口 VS 继承 Thread</h4>\n<p>实现接口会更好一些，因为:</p>\n<ul>\n<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>\n<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>\n</ul>\n<h3 id=\"基础线程机制\"><a class=\"markdownIt-Anchor\" href=\"#基础线程机制\">#</a> 基础线程机制</h3>\n<h4 id=\"executor\"><a class=\"markdownIt-Anchor\" href=\"#executor\">#</a> Executor</h4>\n<p>​\tExecutor 管理多个异步任务的执行，无须显式的管理线程生命周期。</p>\n<p>主要又三种 Executor:</p>\n<ul>\n<li>CachedThreadPool：一个任务创建一个线程。</li>\n<li>FixedThreadPool：所有任务只能使用固定大小的线程。</li>\n<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>\n</ul>\n<h4 id=\"daemon\"><a class=\"markdownIt-Anchor\" href=\"#daemon\">#</a> Daemon</h4>\n<p>守护线程是程序运行时在后台提供服务的线程，当所有非守护线程结束时，程序也就终止，同时杀死所有守护线程。</p>\n<p>main () 属于非守护线程。</p>\n<p>使用 setEaemon () 方法将一个线程设置为守护线程。</p>\n<h4 id=\"sleep\"><a class=\"markdownIt-Anchor\" href=\"#sleep\">#</a> sleep()</h4>\n<p>休眠当前线程，单位为毫秒。</p>\n<p>sleep () 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main () 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>\n<h4 id=\"yield\"><a class=\"markdownIt-Anchor\" href=\"#yield\">#</a> yield()</h4>\n<p>对静态方法 Thread.yield () 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其他线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>\n<h3 id=\"线程中断\"><a class=\"markdownIt-Anchor\" href=\"#线程中断\">#</a> 线程中断</h3>\n<p>一个线程执行完毕后会自动结束，如果在运行过程中发生异常也会提前结束。</p>\n<h4 id=\"interruptedexception\"><a class=\"markdownIt-Anchor\" href=\"#interruptedexception\">#</a> InterruptedException</h4>\n<p>​\t通过调用一个线程的 interrupt () 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>\n<h4 id=\"interrupted\"><a class=\"markdownIt-Anchor\" href=\"#interrupted\">#</a> interrupted()</h4>\n<p>如果一个线程的 run () 方法执行一个无限循环，并且没有执行 sleep () 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt () 方法就无法使线程提前结束。</p>\n<p>但是调用 interrupt () 方法会设置线程的中断标记，此时调用 interrupted () 方法会返回 true。因此可以在循环体中使用 interrupted () 方法来判断线程是否处于中断状态，从而提前结束线程。</p>\n<h4 id=\"executor-的中断操作\"><a class=\"markdownIt-Anchor\" href=\"#executor-的中断操作\">#</a> Executor 的中断操作</h4>\n<p>​\t调用 Executor 的 shutdown () 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow () 方法，则相当于调用每个线程的 interrupt () 方法。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread run\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdownNow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Main run\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>​\t如果只想中断 Executor 中的一个线程，可以通过使用 submit () 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel (true) 方法就可以中断线程。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> future <span class=\"token operator\">=</span> executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// ..</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>future<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"线程互斥同步\"><a class=\"markdownIt-Anchor\" href=\"#线程互斥同步\">#</a> 线程互斥同步</h3>\n<p>​\tJava 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>\n<h4 id=\"比较\"><a class=\"markdownIt-Anchor\" href=\"#比较\">#</a> 比较</h4>\n<p><strong>1. 锁的实现</strong></p>\n<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>\n<p><strong>2. 性能</strong></p>\n<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>\n<p><strong>3. 等待可中断</strong></p>\n<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>\n<p>ReentrantLock 可中断，而 synchronized 不行。</p>\n<p><strong>4. 公平锁</strong></p>\n<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>\n<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>\n<p><strong>5. 锁绑定多个条件</strong></p>\n<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.938Z",
            "content_html": "<h1 id=\"线程并发关键字详解\"><a class=\"markdownIt-Anchor\" href=\"#线程并发关键字详解\">#</a> 线程并发关键字详解</h1>\n<h2 id=\"synchronized\"><a class=\"markdownIt-Anchor\" href=\"#synchronized\">#</a> synchronized</h2>\n<h4 id=\"使用\"><a class=\"markdownIt-Anchor\" href=\"#使用\">#</a> 使用</h4>\n<ul>\n<li>​\t一把锁只能同时被一个线程获取，没有获取锁的线程只能等待。</li>\n<li>每个实例都对应有自己的一把锁 (this)，不同实例之间互不影响。例外：锁对象时 class 以及 synchronized 修饰的是 static 方法的时候，所有对象巩永固同一把锁。</li>\n<li>synchronized 修饰的方法，无论方法正常执行还是抛出异常，都会释放锁。</li>\n</ul>\n<h4 id=\"对象锁\"><a class=\"markdownIt-Anchor\" href=\"#对象锁\">#</a> 对象锁</h4>\n<p>包括方法锁 (默认锁对象为 this, 当前实例对象) 和同步代码块锁 (自己指定锁对象)</p>\n<ul>\n<li>代码块形式：手动指定锁定对象，也可是是 this, 也可以是自定义的锁</li>\n<li>方法锁形式：synchronized 修饰普通方法，锁对象默认为 this</li>\n</ul>\n<h4 id=\"类锁\"><a class=\"markdownIt-Anchor\" href=\"#类锁\">#</a> 类锁</h4>\n<p>​\t指定 synchronized 修饰静态方法，或者指定锁对象为 Class 对象。</p>\n<ul>\n<li>synchronize 修饰静态方法</li>\n<li>synchronized 指定锁对象为 Class 对象</li>\n</ul>\n<h3 id=\"原理分析\"><a class=\"markdownIt-Anchor\" href=\"#原理分析\">#</a> 原理分析</h3>\n<h4 id=\"加锁和释放锁的原理\"><a class=\"markdownIt-Anchor\" href=\"#加锁和释放锁的原理\">#</a> 加锁和释放锁的原理</h4>\n<p><code>Monitorenter</code>  和 <code>Monitorexit</code>  指令，会让对象在执行，使其锁计数器加 1 或者减 1。每一个对象在同一时间只与一个 monitor (锁) 相关联，而一个 monitor 在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的 Monitor 锁的所有权的时候，monitorenter 指令会发生如下 3 中情况之一：</p>\n<ul>\n<li>monitor 计数器为 0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器 + 1，一旦 + 1，别的线程再想获取，就需要等待</li>\n<li>如果这个 monitor 已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成 2，并且随着重入的次数，会一直累加</li>\n<li>这把锁已经被别的线程获取了，等待锁释放</li>\n</ul>\n<p><code>monitorexit指令</code> ：释放对于 monitor 的所有权，释放过程很简单，就是讲 monitor 的计数器减 1，如果减完以后，计数器不是 0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成 0，则代表当前线程不再拥有该 monitor 的所有权，即释放锁。</p>\n<p>下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：</p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-thread-x-key-schronized-2.png\" alt=\"img\"></p>\n<p>该图可以看出，任意线程对 Object 的访问，首先要获得 Object 的监视器，如果获取失败，该线程就进入同步状态，线程状态变为 BLOCKED，当 Object 的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p>\n<h4 id=\"可重入原理加锁次数计数器\"><a class=\"markdownIt-Anchor\" href=\"#可重入原理加锁次数计数器\">#</a> 可重入原理：加锁次数计数器</h4>\n<ul>\n<li>可重入：当一个子程序正在运行是，执行线程可以再次进入并执行它，仍然获得符合设计预期的结果，则称其为可重入（reentrant 或 re-entrant）。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时，重新进入同一个子程序仍然时安全的。</li>\n<li>可重入锁：又名递归锁，是指同一个线程在外层方法获取锁的时候，再进入线程的内层方法会自动获取锁（前提是锁对象时同一个对象或者同一个 class），不会因为之前已经获取过还没有释放锁而阻塞。</li>\n</ul>\n<p>这就是 Synchronized 的重入性，即在<strong>同一锁程</strong>中，每个对象拥有一个 monitor 计数器，当线程获取该对象锁后，monitor 计数器就会加一，释放锁后就会将 monitor 计数器减一，线程不需要再次获取同一把锁。</p>\n<h4 id=\"保证可见性原理内存模型和happens-before规则\"><a class=\"markdownIt-Anchor\" href=\"#保证可见性原理内存模型和happens-before规则\">#</a> 保证可见性原理：内存模型和 happens-before 规则</h4>\n<p>synchronized 的 happens-before 规则，即监视器锁规则：对同一个监视器的解锁，happens-before 对于该监视器的加锁。</p>\n<p><strong>即，A 线程拿到锁修改了共享变量后，在释放锁之前，会将缓存中修改后的值刷入主存当中，通知其他线程共享变量已被修改。然后 B 线程获取了锁以后，会自动去主存中获取更新后的共享变量值。</strong></p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-thread-x-key-schronized-3.png\" alt=\"img\"></p>\n<p>在图中每一个箭头连接的两个节点就代表之间的 happens-before 关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程 A 释放锁 happens-before 线程 B 加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来 happens-before 关系，通过传递性规则进一步推导的 happens-before 关系。现在我们来重点关注 2 happens-before 5，通过这个关系我们可以得出什么？</p>\n<p>根据 happens-before 的定义中的一条：如果 A happens-before B，则 A 的执行结果对 B 可见，并且 A 的执行顺序先于 B。线程 A 先对共享变量 A 进行加一，由 2 happens-before 5 关系可知线程 A 的执行结果对线程 B 可见即线程 B 所读取到的 a 的值为 1。</p>\n<h3 id=\"jvm中锁的优化\"><a class=\"markdownIt-Anchor\" href=\"#jvm中锁的优化\">#</a> JVM 中锁的优化</h3>\n<p>​\t在 JVM 中 monitorenter 和 monitorexit 字节码依赖于底层的操作系统的 Mutex Lock 来实现的，但是由于使用 Mutex Lock 需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。不过在 jdk1.6 中对锁的实现引用了大量优化。</p>\n<ul>\n<li>锁粗化：也就是减少不必要的紧连在一起的 unlock，lock 操作，将多个连续的锁扩展成一个范围更大的锁。</li>\n<li>锁消除：通过运行 JIT 编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁的保护，通过逃逸分析也可以在线程的 stack 上进行对象空间的分配（同时还可以减少 Heap 上的垃圾收集开销）。</li>\n<li>轻量级锁：</li>\n<li>这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态 (即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在 monitorenter 和 monitorexit 中只需要依靠一条 CAS 原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行 CAS 指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒</li>\n<li>偏向锁：是为了在无锁竞争的情况下避免在锁获取的过程中执行不必要的 CAS 原子指令，因为 CAS 原子指令虽然相对重量级锁开销较小，但还是存在非常可观的本地延迟。</li>\n<li>适应性自旋锁：</li>\n<li>当线程在获取轻量级锁的过程中执行 CAS 操作失败时，在进入与 monitor 相关联的操作系统重量级锁 (mutex semaphore) 前会进入忙等待 (Spinning) 然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该 monitor 关联的 semaphore (即互斥锁) 进入到阻塞状态。</li>\n</ul>\n<h4 id=\"锁的类型\"><a class=\"markdownIt-Anchor\" href=\"#锁的类型\">#</a> 锁的类型</h4>\n<p>jdk1.6 中 synchronized 同步锁，一共存在四种状态：无锁、偏向锁、轻量级锁、重量级锁。它会随着竞争情况逐渐升级，但是不可以降级，目的是为了提供获取锁和释放锁的效率。</p>\n<h4 id=\"自旋锁-自适应自旋锁\"><a class=\"markdownIt-Anchor\" href=\"#自旋锁-自适应自旋锁\">#</a> 自旋锁、自适应自旋锁</h4>\n<h4 id=\"锁消除\"><a class=\"markdownIt-Anchor\" href=\"#锁消除\">#</a> 锁消除</h4>\n<p>​\t锁消除是指虚拟机运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除主要判定依据来源于逃逸分析的数据支持。意思就是：JVM 会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那 JVM 就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p>\n<p>​\t当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在 Java API 中有很多方法都是加了同步的，那么此时 JVM 会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。</p>\n<p>​\t<strong>比如如下操作：在操作 String 类型数据时，由于 String 是一个不可变类，对字符串的连接操作总是通过生成的新的 String 对象来进行的。因此 Javac 编译器会对 String 连接做自动优化。在 JDK 1.5 之前会使用 StringBuffer 对象的连续 append () 操作，在 JDK 1.5 及以后的版本中，会转化为 StringBuidler 对象的连续 append () 操作 (因为 String 是不可变类，是线程安全类，所以编译器会转为 StringBuilder 进行操作，在不会产出线程安全问题的同时，相对于使用 String 类型操作更高效，)。</strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> <span class=\"token function\">test03</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> s2<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> s3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> s2 <span class=\"token operator\">+</span> s3<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"锁粗化\"><a class=\"markdownIt-Anchor\" href=\"#锁粗化\">#</a> 锁粗化</h4>\n<p>​\t原则上，在加同步锁时，尽可能将同步块的作用范围限制到尽量小的范围（在存在锁的同步竞争中，也可以使得等待锁的线程尽早拿到锁）。</p>\n<p>​\t但是如果存在一系列操作都对同一个对象反复加锁和解锁，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p>\n<p>​\t例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> <span class=\"token function\">test04</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> s2<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> s3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">StringBuffer</span> sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> sb<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>​\t这里的连续 append () 操作就属于这种情况，JVM 会检测到这样一连串的操作都是对同一个对象加锁，那么 JVM 会将加锁同步的范围扩展（粗化）到整个一系列操作的外部，使整个一连串的 append () 操作只需要加一次所就可以了。</p>\n<h4 id=\"偏向锁\"><a class=\"markdownIt-Anchor\" href=\"#偏向锁\">#</a> 偏向锁</h4>\n<p>​\t当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录中存储偏向的线程 ID，以后该线程在进入和退出同步块时，不需要进行 CAS 操作来加锁和解锁。只需要简单的测试一下对象头的 <code>Mark Word</code>  里是否存储着当前线程的偏向锁，如果成功，标识已经获取到了锁。</p>\n<h5 id=\"偏向锁的撤销\"><a class=\"markdownIt-Anchor\" href=\"#偏向锁的撤销\">#</a> 偏向锁的撤销</h5>\n<p>​\t偏向锁使用一种等待竞争放锁机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点（就是当前线程没有正在执行的代码）。它会首先暂停拥有偏向锁的线程，让你检查持有偏向锁的线程是否还或者。如果线程不处于活动状态，直接将对象设置为无锁状态。如果线程还或者，JVM 会便利战阵中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-thread-x-key-schronized-9.png\" alt=\"img\"></p>\n<h4 id=\"轻量级锁\"><a class=\"markdownIt-Anchor\" href=\"#轻量级锁\">#</a> 轻量级锁</h4>\n<h4 id=\"重量级锁\"><a class=\"markdownIt-Anchor\" href=\"#重量级锁\">#</a> 重量级锁</h4>\n<h4 id=\"锁的优缺点对比\"><a class=\"markdownIt-Anchor\" href=\"#锁的优缺点对比\">#</a> 锁的优缺点对比</h4>\n<table>\n<thead>\n<tr>\n<th>锁</th>\n<th>优点</th>\n<th>缺点</th>\n<th>使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要 CAS 操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>\n<td>适用于只有一个线程访问同步块的场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程不会阻塞，提高了响应速度</td>\n<td>如线程成始终得不到锁竞争的线程，使用自旋会消耗 CPU 性能</td>\n<td>追求响应时间，同步块执行速度非常快</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不适用自旋，不会消耗 CPU</td>\n<td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>\n<td>追求吞吐量，同步块执行速度较长</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"synchronized与lock\"><a class=\"markdownIt-Anchor\" href=\"#synchronized与lock\">#</a> synchronized 与 Lock</h3>\n<h4 id=\"synchronized的缺陷\"><a class=\"markdownIt-Anchor\" href=\"#synchronized的缺陷\">#</a> synchronized 的缺陷</h4>\n<ul>\n<li><strong>效率低</strong>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁。试图获取锁的时候不能设定超时，不能中断一个正在使用的线程，相对而言，Lock 可以中断和设置超时。</li>\n<li><strong>不够灵活</strong>：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），相对而言，读写锁更加灵活。</li>\n<li><strong>无法知道是否成功获取锁</strong>：相对而言，Lock 可以拿到状态，如果成功获取锁，如果获取锁失败。</li>\n</ul>\n<h4 id=\"lock解决相应问题\"><a class=\"markdownIt-Anchor\" href=\"#lock解决相应问题\">#</a> Lock 解决相应问题</h4>\n<p>Lock 类这里不做过多解释，主要看里面的 4 个方法:</p>\n<ul>\n<li><code>lock()</code> : 加锁</li>\n<li><code>unlock()</code> : 解锁</li>\n<li><code>tryLock()</code> : 尝试获取锁，返回一个 boolean 值</li>\n<li><code>tryLock(long,TimeUtil)</code> : 尝试获取锁，可以设置超时</li>\n</ul>\n<p>Synchronized 只有锁只与一个条件 (是否获取锁) 相关联，不灵活，后来 <code>Condition与Lock的结合</code> 解决了这个问题。</p>\n<p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock 的 lockInterruptibly () 方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后 ReentrantLock 响应这个中断，不再让这个线程继续等待。有了这个机制，使用 ReentrantLock 时就不会像 synchronized 那样产生死锁了。</p>\n<h4 id=\"使用synchronized有哪些需要注意的\"><a class=\"markdownIt-Anchor\" href=\"#使用synchronized有哪些需要注意的\">#</a> 使用 Synchronized 有哪些需要注意的</h4>\n<ul>\n<li>锁对象不能为空，因为锁的信息都保存在对象头里</li>\n<li>作用域不宜过大，影响程序执行速度，控制范围过大，编写代码容易出错。</li>\n<li>避免死锁。</li>\n<li>在能选择的情况下，既不要用 Lock 也不要用 synchronized 关键字，用 java.util.concurrent 包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用 synchronized 关键，因为代码量少，避免出错。</li>\n</ul>\n<h4 id=\"synchronized是公平锁么\"><a class=\"markdownIt-Anchor\" href=\"#synchronized是公平锁么\">#</a> synchronized 是公平锁么</h4>\n<p>​\tsynchronized 实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象</p>\n<h2 id=\"volatile详解\"><a class=\"markdownIt-Anchor\" href=\"#volatile详解\">#</a> volatile 详解</h2>\n<h3 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用</h3>\n<ul>\n<li>防重排序：变量设置为 volatile 的类型，可以防止操作系统或者 JVM 进行重排序。</li>\n<li>实现可见性：当一个线程更改了 volatile 类型变量，会立即刷新该变量值到主存中，其他线程需要使用该变量时，会去主存中重新读取该变量值，以此来避免可见性。</li>\n<li>保证原子性：不能完全保证原子性，只能保证单次的读 / 写具有原子性。</li>\n</ul>\n<h3 id=\"实现原理\"><a class=\"markdownIt-Anchor\" href=\"#实现原理\">#</a> 实现原理</h3>\n<h4 id=\"volatile可见性实现\"><a class=\"markdownIt-Anchor\" href=\"#volatile可见性实现\">#</a> volatile 可见性实现</h4>\n<p>​\tvolatile 变量的内存可见性是基于内存屏障 (Memory Barrier) 实现的。</p>\n<p>​\t内存屏障，又称内存栅栏，是一个 CPU 指令。在程序运行时，为了提高程序运行的性能，编译器和处理器会对指令进行重排序，JVM 为了保证在不用的编译器和 CPU 上有相同的运行结果，通过插入特定类型的内存屏障来禁止 + 特定的编译器和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">Test</span> test <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        test<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><pre><code>......\n  0x0000000002951563: and    $0xffffffffffffff87,%rdi\n  0x0000000002951567: je     0x00000000029515f8\n  0x000000000295156d: test   $0x7,%rdi\n  0x0000000002951574: jne    0x00000000029515bd\n  0x0000000002951576: test   $0x300,%rdi\n  0x000000000295157d: jne    0x000000000295159c\n  0x000000000295157f: and    $0x37f,%rax\n  0x0000000002951586: mov    %rax,%rdi\n  0x0000000002951589: or     %r15,%rdi\n  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令\n  0x0000000002951591: jne    0x0000000002951a15\n  0x0000000002951597: jmpq   0x00000000029515f8\n  0x000000000295159c: mov    0x8(%rdx),%edi\n  0x000000000295159f: shl    $0x3,%rdi\n  0x00000000029515a3: mov    0xa8(%rdi),%rdi\n  0x00000000029515aa: or     %r15,%rdi\n......\n</code></pre>\n<p>​\tlock 前缀的指令在多核处理器下会引发两件事：</p>\n<ul>\n<li>将当处理器缓存行的数据写回到系统内存。</li>\n<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>\n</ul>\n<h2 id=\"final详解\"><a class=\"markdownIt-Anchor\" href=\"#final详解\">#</a> final 详解</h2>\n<h3 id=\"final的基础使用\"><a class=\"markdownIt-Anchor\" href=\"#final的基础使用\">#</a> final 的基础使用</h3>\n<h4 id=\"修饰类\"><a class=\"markdownIt-Anchor\" href=\"#修饰类\">#</a> 修饰类</h4>\n<p>当某个类被修饰为 final 时，就表明你不能继承该类。即这个类是不能有字类的。</p>\n<p><strong>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中，给任何方法添加 final 关键字式没有任何意义的。</strong></p>\n<h5 id=\"如何扩展final类\"><a class=\"markdownIt-Anchor\" href=\"#如何扩展final类\">#</a> 如何扩展 final 类？</h5>\n<p>​\t在设计模式中，最重要的两种关系，一种是继承 / 实现，另一种是组合关系。</p>\n<h4 id=\"修饰方法\"><a class=\"markdownIt-Anchor\" href=\"#修饰方法\">#</a> 修饰方法</h4>\n<ul>\n<li>final 修饰的方法是不可继承的。</li>\n<li>private 方法是隐式的 final。</li>\n<li>final 方法是可以重载的。</li>\n</ul>\n<h4 id=\"修饰参数\"><a class=\"markdownIt-Anchor\" href=\"#修饰参数\">#</a> 修饰参数</h4>\n<p>​\t Java 允许在参数列表中以声明的方式将参数指明为 final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>\n<h4 id=\"修饰变量\"><a class=\"markdownIt-Anchor\" href=\"#修饰变量\">#</a> 修饰变量</h4>\n<ul>\n<li>\n<p>编译期常量、非编译期常量。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 编译期常量</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token class-name\">J</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 非编译期常量</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">Random</span> r <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n<li>\n<p>static final 必须在定义的时候进行赋值。</p>\n</li>\n<li>\n<p>空白 final：声明为 final 类型，但是不给定值，在使用前被赋值。</p>\n</li>\n</ul>\n<p>###　final 域重排序规则</p>\n<pre><code>#### \tfinal为基本类型\n</code></pre>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FinalDemo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 普通域</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">//final 域</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">FinalDemo</span> finalDemo<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">FinalDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1. 写普通域</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2. 写 final 域</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">writer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        finalDemo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FinalDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token class-name\">FinalDemo</span> demo <span class=\"token operator\">=</span> finalDemo<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3. 读对象引用</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> demo<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//4. 读普通域</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> demo<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//5. 读 final 域</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"写final域的重排序规则\"><a class=\"markdownIt-Anchor\" href=\"#写final域的重排序规则\">#</a> 写 final 域的重排序规则</h5>\n<p>​\t禁止对 final 域的写重排序到构造函数之外，这个规则主要包含了两个方面：</p>\n<ul>\n<li>\n<p>JVM 会禁止编译器把 final 域的写重排序到构造函数之外；</p>\n</li>\n<li>\n<p>编译器会在 final 域写之后，构造函数 return 之前，插入一个 storestore 屏障。这个屏障可以禁止处理器把 final 域的写重排序到构造函数之外。</p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-thread-x-key-final-1.png\" alt=\"img\"></p>\n</li>\n</ul>\n<p>由于 a，b 之间没有数据依赖性，普通域 a 可能会被重排序到构造函数之外，线程 B 就有可能读到的是普通变量 a 初始化之前的值（零值），这样就可能出现错误。而 final 域 b，根据重排序规则，会禁止 final 修饰的变量 b 重排序到构造函数之外，从而 b 就能够正确赋值，线程 B 就能读到 final 变量初始化之后的值。</p>\n<p>因此，写 final 域的重排序规则可以确保，在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而不同于就不具有这个保障。</p>\n<h5 id=\"读final域重排序规则\"><a class=\"markdownIt-Anchor\" href=\"#读final域重排序规则\">#</a> 读 final 域重排序规则</h5>\n<p>规则为：在一个线程种，初次读对象引用和初次读对象包含的 final 域，JMM 会禁止这两个操作的重排序（注意，这个规则仅仅是针对处理器），处理器会在读 final 域的前面插入一个 LoadLoad 屏障。 实际上，读对象的引用和读该对象的 final 域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p>\n<p><img data-src=\"https://pdai.tech/images/thread/java-thread-x-key-final-2.png\" alt=\"img\"></p>\n<p>读对象的普通域被重排序到了读对象引用的前面就会出现线程 B 还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而 final 域的读操作就 “限定” 了在读 final 域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p>\n<p>读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读这个包含这个 final 域的对象的引用。</p>\n<h4 id=\"final为引用类型\"><a class=\"markdownIt-Anchor\" href=\"#final为引用类型\">#</a> final 为引用类型</h4>\n<h5 id=\"写重排序规则\"><a class=\"markdownIt-Anchor\" href=\"#写重排序规则\">#</a> 写重排序规则</h5>\n<p>​\t针对引用数据类型，final 域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个 final 修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是 “增加” 也就说前面对 final 基本数据类型的重排序规则在这里还是使用。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FinalReferenceDemo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arrays<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">FinalReferenceDemo</span> finalReferenceDemo<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">FinalReferenceDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        arrays <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//1</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        arrays<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">//2</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">writerOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        finalReferenceDemo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FinalReferenceDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//3</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">writerTwo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        arrays<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//4</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>finalReferenceDemo <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">//5</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> finalReferenceDemo<span class=\"token punctuation\">.</span>arrays<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//6</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><img data-src=\"https://pdai.tech/images/thread/java-thread-x-key-final-3.png\" alt=\"img\"></p>\n<p>由于对 final 域的写禁止重排序到构造方法外，因此 1 和 3 不能被重排序。由于一个 final 域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此 2 和 3 不能重排序。</p>\n<h5 id=\"读重排序规则\"><a class=\"markdownIt-Anchor\" href=\"#读重排序规则\">#</a> 读重排序规则</h5>\n<p>JMM 可以确保线程 C 至少能看到写线程 A 对 final 引用的对象的成员域的写入，即能看下 arrays [0] = 1，而写线程 B 对数组元素的写入可能看到可能看不到。JMM 不保证线程 B 的写入对线程 C 可见，线程 B 和线程 C 之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者 volatile</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Gradle/gradle%E4%BB%8B%E7%BB%8D/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Gradle/gradle%E4%BB%8B%E7%BB%8D/",
            "title": "Gradle介绍",
            "date_published": "2024-02-18T08:13:44.929Z",
            "content_html": "<h1 id=\"目录结构\"><a class=\"markdownIt-Anchor\" href=\"#目录结构\">#</a> 目录结构</h1>\n<p>src/main/java 放置正式代码目录<br>\n src/main/resource 放置正式配置文件目录<br>\n src/main/webapp 放置页面原色，比如 js,css,img,jsp,html 等等</p>\n<p>src/test/java 放置单元测试代码目录<br>\n src/test/resource 放置单元测试配置文件目录</p>\n<h1 id=\"介绍grovvy-编程语言\"><a class=\"markdownIt-Anchor\" href=\"#介绍grovvy-编程语言\">#</a> 介绍 grovvy 编程语言</h1>\n<p><strong>grovvy 基础</strong></p>\n<pre><code class=\"language-Grovvy\">\nprintln(&quot;hello grovvy&quot;);\n\n// grovvy 可以省略末尾的分号\nprinln(&quot;hello grovvy&quot;)\n\n// grovvy 可以省略括号\nprinln &quot;hello grovvy&quot;\n\n</code></pre>\n<p><strong>grovvy 变量</strong></p>\n<pre><code class=\"language-Grovvy\">\ndef i = 18\nprintln i\n\n</code></pre>\n<p><strong>复杂变量类型</strong></p>\n<pre><code class=\"language-Grovvy\">\n// List\ndef list = ['a', 'b']\nlist &lt;&lt; 'c'\nlist &lt;&lt; 10\nprintln list\nprintln list.get(0)\nprintln list.size()\n\n// Map\ndef map = ['key1': 'vlaue1', 'key2': 'value2']\nmap.key3 = 'value3'\nprintln map\nprintln map.get('key2')\n\n</code></pre>\n<p><strong>闭包</strong><br>\n闭包就是一段代码块，在 gradle 中我们主要把闭包当作参数来使用</p>\n<pre><code class=\"language-Grovvy\">\n// 闭包\ndef fun = &#123;\n    println 'hello fun'\n&#125;\n\ndef method1(Closure closure) &#123;\n    closure()\n&#125;\n\nmethod1(fun);\n\n\n// 闭包（带参数）\ndef fun2 = &#123;\n    v -&gt; println &quot;hello $&#123;v&#125;&quot;\n&#125;\n\ndef method2(Closure closure)&#123;\n    closure &quot;小马&quot;\n&#125;\n\nmethod2(fun2)\n\n</code></pre>\n<pre><code class=\"language-Grovvy\">\nplugins &#123;\n    id 'java'\n&#125;\n\ngroup = 'org.example'\nversion = '1.0-SNAPSHOT'\n\n/**\n * 指定所使用的仓库，mavenCenteral()表示使用中央仓库，此刻项目中所需要的jar包都会默认从仓库下载到本地指定目录\n * mavenLocal()\n * mavenCentral()\n * 以上配置表示先从本地仓库寻找依赖，如果没有再从中央仓库下载\n *\n * mavenCentral()\n * 如果只配置中央仓库，表示直接从中央仓库下载，但是如果指定的下载位置已经有了，就不会再次下载\n *\n */\nrepositories &#123;\n    mavenLocal()\n    mavenCentral()\n&#125;\n/**\n * gradel 所有的jar包的坐标都在dependencies属性内放置\n *\n * 每一个jar包的坐标都有三个基本元素组成\n * group name version\n *\n * testCompile 表示该jar包在测试的时候起作用，该属性为jar包的作用域\n *\n * 我们在gradle里面添加坐标的时候，都要添加作用域\n */\ndependencies &#123;\n//    testImplementation platform('org.junit:junit-bom:5.9.1')\n//    testImplementation 'org.junit.jupiter:junit-jupiter'\n    implementation group: 'org.springframework', name: 'spring-context', version: '5.3.29'\n&#125;\n\njar &#123;\n    manifest &#123;\n        attributes 'Main-Class': 'org.example.Main'\n    &#125;\n&#125;\n\ntest &#123;\n    useJUnitPlatform()\n&#125;\n\n</code></pre>\n",
            "tags": [
                "Gradle"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/Apache-poi/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/Apache-poi/",
            "title": "Apache-Poi",
            "date_published": "2024-02-18T08:13:44.929Z",
            "content_html": "<h1 id=\"apache-poi\"><a class=\"markdownIt-Anchor\" href=\"#apache-poi\">#</a> Apache-Poi</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wb2kuYXBhY2hlLm9yZy8=\">官网</span><br>\n<br/> <br/><br>\n<img data-src=\"/image/Java/project-header.png\" alt=\"官网\"></p>\n</blockquote>\n<hr>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h2>\n<h3 id=\"hssf-sxxf-sxssf的区别\"><a class=\"markdownIt-Anchor\" href=\"#hssf-sxxf-sxssf的区别\">#</a> HSSF SXXF SXSSF 的区别</h3>\n<blockquote>\n<ul>\n<li>HSSF:Excel97-2003 版本，扩展名为.xls。一个 sheet 最大行数 65536，最大列数 256。</li>\n<li>XSSF:Excel2007 版本开始，扩展名为.xlsx。一个 sheet 最大行数 1048576，最大列数 16384。</li>\n<li>SXSSF: 是在 XSSF 基础上，POI3.8 版本开始提供的支持低内存占用的操作方式，扩展名为.xlsx。</li>\n</ul>\n<p>HSSF 用于 Excel03 版本：</p>\n<pre><code>  缺点：最多只能处理65536行，否则会报异常，\n\n  优点：过程中写入缓存，不操作磁盘，最后一次性写入磁盘，速度快\n</code></pre>\n<p>XSSF 用于 Excel07 版本：</p>\n<pre><code>  缺点：写数据时速度非常慢，非常耗内存，也会发生内存溢出，如100万条数据\n  优点：可以写较大的数据量，如20万条数据\n</code></pre>\n<p>SXSSF 可以理解为 SXXF 超大量数据升级版：</p>\n<pre><code>  优点：可以写非常大量的数据库，如100万条甚至更多条，写数据速度快，占用更少的内存\n  注意：\n      - 过程中会产生临时文件，需要清理临时文件\n      - 默认由100条记录被保存在内存中，如果超出这数量，则最前面的数据被写入临时文件\n      - 如果想自定义内存中数据的数量，可以使用new SXSSFWorkbook（数量）\n</code></pre>\n</blockquote>\n<h3 id=\"其他常见名称含义\"><a class=\"markdownIt-Anchor\" href=\"#其他常见名称含义\">#</a> 其他常见名称含义</h3>\n<p><em>其他常见名称含义：</em></p>\n<ul>\n<li>XSSF (XML SpreadSheet Format) – Used to reading and writting Open Office XML (XLSX) format files.</li>\n<li>HSSF (Horrible SpreadSheet Format) – Use to read and write Microsoft Excel (XLS) format files.</li>\n<li>HWPF (Horrible Word Processor Format) – to read and write Microsoft Word 97 (DOC) format files.</li>\n<li>HSMF (Horrible Stupid Mail Format) – pure Java implementation for Microsoft Outlook MSG files</li>\n<li>HDGF (Horrible DiaGram Format) – One of the first pure Java implementation for Microsoft Visio binary files.</li>\n<li>HPSF (Horrible Property Set Format) – For reading “Document Summary” information from Microsoft Office files.</li>\n<li>HSLF (Horrible Slide Layout Format) – a pure Java implementation for Microsoft PowerPoint files.</li>\n<li>HPBF (Horrible PuBlisher Format) – Apache’s pure Java implementation for Microsoft Publisher files.</li>\n<li>DDF (Dreadful Drawing Format) – Apache POI package for decoding the Microsoft Office Drawing format.</li>\n</ul>\n<h2 id=\"使用\"><a class=\"markdownIt-Anchor\" href=\"#使用\">#</a> 使用</h2>\n<h3 id=\"步骤一导入依赖\"><a class=\"markdownIt-Anchor\" href=\"#步骤一导入依赖\">#</a> 步骤一：导入依赖</h3>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi&lt;/artifactId&gt;\n    &lt;version&gt;4.1.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;\n    &lt;version&gt;4.1.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/C#/2.%E7%8E%AF%E5%A2%83/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/C#/2.%E7%8E%AF%E5%A2%83/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.921Z",
            "content_html": "<h1 id=\"c环境\"><a class=\"markdownIt-Anchor\" href=\"#c环境\">#</a> C# 环境</h1>\n<h2 id=\"net框架net-framework\"><a class=\"markdownIt-Anchor\" href=\"#net框架net-framework\">#</a> .NET 框架（.Net Framework）</h2>\n<pre><code>.Net框架是一个创新的平台，能写\n    * Windows应用程序\n    * Web应用程序\n    * Web服务\n\n.Net框架应用程序是多平台的应用程序。框架的设计方式使它适用于下列各种语言：C#、C++、Visual Basic、Jscript、COBOL 等等。所有这些语言可以访问框架，彼此之间也可以互相交互。\n\n.Net 框架由一个巨大的代码库组成，用于 C# 等客户端语言。下面列出一些 .Net 框架的组件：\n    公共语言运行库（Common Language Runtime - CLR）\n    .Net 框架类库（.Net Framework Class Library）\n    公共语言规范（Common Language Specification）\n    通用类型系统（Common Type System）\n    元数据（Metadata）和组件（Assemblies）\n    Windows 窗体（Windows Forms）\n    ASP.Net 和 ASP.Net AJAX\n    ADO.Net\n    Windows 工作流基础（Windows Workflow Foundation - WF）\n    Windows 显示基础（Windows Presentation Foundation）\n    Windows 通信基础（Windows Communication Foundation - WCF）\n    LINQ\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/C#/4.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/C#/4.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.921Z",
            "content_html": "<h1 id=\"c基本语法\"><a class=\"markdownIt-Anchor\" href=\"#c基本语法\">#</a> C# 基本语法</h1>\n<h2 id=\"using-关键字\"><a class=\"markdownIt-Anchor\" href=\"#using-关键字\">#</a> using 关键字</h2>\n<pre><code>在任何 C# 程序中的第一条语句都是：\n\nusing System;\nusing 关键字用于在程序中包含命名空间。一个程序可以包含多个 using 语句。\n</code></pre>\n<h2 id=\"class-关键字\"><a class=\"markdownIt-Anchor\" href=\"#class-关键字\">#</a> class 关键字</h2>\n<pre><code>class 关键字用于声明一个类。\n</code></pre>\n<h2 id=\"c-中的注释\"><a class=\"markdownIt-Anchor\" href=\"#c-中的注释\">#</a> C# 中的注释</h2>\n<pre><code>知识点补充：\n\nC# 中 // 注释和 /// 注的区别：\n\nC# 引入了新的 XML 注释，即我们在某个函数前新起一行，输入 ///，VS.Net 会自动增加 XML 格式的注释\n\n// 不会被编译，而 /// 会被编译\n\n所以使用 /// 会减慢编译的速度（但不会影响执行速度）\n\n但使用 /// 会在其它的人调用你的代码时提供智能感知（通常在Form。Designer.cs 窗口会自动生成 /// 注释的程序）\n</code></pre>\n<h2 id=\"成员变量\"><a class=\"markdownIt-Anchor\" href=\"#成员变量\">#</a> 成员变量</h2>\n<h2 id=\"标识符\"><a class=\"markdownIt-Anchor\" href=\"#标识符\">#</a> 标识符</h2>\n<pre><code>标识符是用来识别类、变量、函数或任何其它用户定义的项目。在 C# 中，类的命名必须遵循如下基本规则：\n\n标识符必须以字母开头，后面可以跟一系列的字母、数字（ 0 - 9 ）或下划线（ _ ）。标识符中的第一个字符不能是数字。\n标识符必须不包含任何嵌入的空格或符号，比如 ? - +! @ # % ^ &amp; * ( ) [ ] &#123; &#125; . ; : &quot; ' / \\。但是，可以使用下划线（ _ ）。\n标识符不能是 C# 关键字。\n</code></pre>\n<h2 id=\"c-关键字\"><a class=\"markdownIt-Anchor\" href=\"#c-关键字\">#</a> C# 关键字</h2>\n<pre><code>关键字是 C# 编译器预定义的保留字。这些关键字不能用作标识符，但是，如果您想使用这些关键字作为标识符，可以在关键字前面加上 @ 字符作为前缀。\n\n在 C# 中，有些标识符在代码的上下文中有特殊的意义，如 get 和 set，这些被称为上下文关键字（contextual keywords）。\n\n下表列出了 C# 中的保留关键字（Reserved Keywords）和上下文关键字（Contextual Keywords）：\n\n保留关键字\n\nabstract\tas\tbase\tbool\tbreak\tbyte\tcase\ncatch\tchar\tchecked\tclass\tconst\tcontinue\tdecimal\ndefault\tdelegate\tdo\tdouble\telse\tenum\tevent\nexplicit\textern\tfalse\tfinally\tfixed\tfloat\tfor\nforeach\tgoto\tif\timplicit\tin\tin (generic\nmodifier)\tint\ninterface\tinternal\tis\tlock\tlong\tnamespace\tnew\nnull\tobject\toperator\tout\tout\n(generic\nmodifier)\toverride\tparams\nprivate\tprotected\tpublic\treadonly\tref\treturn\tsbyte\nsealed\tshort\tsizeof\tstackalloc\tstatic\tstring\tstruct\nswitch\tthis\tthrow\ttrue\ttry\ttypeof\tuint\nulong\tunchecked\tunsafe\tushort\tusing\tvirtual\tvoid\nvolatile\twhile\t\n\n上下文关键字\n\nadd\talias\tascending\tdescending\tdynamic\tfrom\tget\nglobal\tgroup\tinto\tjoin\tlet\torderby\tpartial\n(type)\npartial\n(method)\tremove\tselect\tset\t\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/C#/3.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/C#/3.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.921Z",
            "content_html": "<h1 id=\"c程序结构\"><a class=\"markdownIt-Anchor\" href=\"#c程序结构\">#</a> C# 程序结构</h1>\n<p>一个 C# 程序主要包含一下几个部分：</p>\n<pre><code>* 命名空间声明（Namespace declaration）\n* 一个class\n* Class方法\n* Class属性\n* 一个Main方法\n* 语句（Statements）&amp; 表达式（Expressions）\n* 注释\n</code></pre>\n<pre><code>    using System;\n    namespace HelloWorldApplication&#123;\n    class HelloWorld&#123;\n        static void Main(string[] args)&#123;\n            /* 我的第一个 C# 程序*/\n            Console.WriteLine(&quot;Hello World&quot;);\n            Console.ReadKey();\n        &#125;\n    &#125;\n    &#125;\n</code></pre>\n<pre><code>程序的第一行 using System; - using 关键字用于在程序中包含 System 命名空间。 一个程序一般有多个 using 语句。\n\n下一行是 namespace 声明。一个 namespace 是一系列的类。HelloWorldApplication 命名空间包含了类 HelloWorld。\n\n下一行是 class 声明。类 HelloWorld 包含了程序使用的数据和方法声明。类一般包含多个方法。方法定义了类的行为。在这里，HelloWorld 类只有一个 Main 方法。\n\n下一行定义了 Main 方法，是所有 C# 程序的 入口点。Main 方法说明当执行时 类将做什么动作。\n\n下一行 /*...*/ 将会被编译器忽略，且它会在程序中添加额外的 注释。\n\nMain 方法通过语句 Console.WriteLine(&quot;Hello World&quot;); 指定了它的行为。\n\nWriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法。该语句会在屏幕上显示消息 &quot;Hello, World!&quot;。\n\n最后一行 Console.ReadKey(); 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。\n</code></pre>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<pre><code>C#是大小写敏感的。\n\n所有的语句和表达式必须以分号(;)结尾。\n\n程序的执行从Main方法开始。\n\n与Java不同的是，C#的文件名和类的名称可以不相同（java的类和文件名不同则无法通过编译）\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/C#/1.%E7%AE%80%E4%BB%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/C#/1.%E7%AE%80%E4%BB%8B/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.913Z",
            "content_html": "<h1 id=\"c简介\"><a class=\"markdownIt-Anchor\" href=\"#c简介\">#</a> C# 简介</h1>\n<p>C# 是微软（Microsoft）开发的，是一个现代的、通用的、面向对象的编程语言</p>\n<p>C# 是专门为 ** 公共语言基础结构 (CLI)** 设计的。CLI 由可执行代码和运行时环境组成，允许在不同计算机平台和体系结构上使用各种高级语言。</p>\n<h2 id=\"c的一些特点\"><a class=\"markdownIt-Anchor\" href=\"#c的一些特点\">#</a> C# 的一些特点：</h2>\n<pre><code>* 现代的、通用的编程语言\n* 面向对象\n* 面向组件\n* 容易学习\n* 结构化语言\n* 它产生高效率的程序\n* 它可以在多种计算机平台上编译\n* .Net框架的一部分\n</code></pre>\n<h2 id=\"c的一些重要功能\"><a class=\"markdownIt-Anchor\" href=\"#c的一些重要功能\">#</a> C# 的一些重要功能</h2>\n<pre><code>* 布尔条件\n* 自动垃圾回收\n* 标准库\n* 组件版本\n* 属性和事件\n* 委托和事件管理\n* 易于使用的泛型\n* 索引器\n* 条件编译\n* LINQ和Lambda表达式\n* 集成Windows\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E4%B8%AA%E4%BA%BA/PhotoShop/%E5%8E%BB%E6%B0%B4%E5%8D%B0/",
            "url": "http://1405904364.github.io/2024/02/18/%E4%B8%AA%E4%BA%BA/PhotoShop/%E5%8E%BB%E6%B0%B4%E5%8D%B0/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.904Z",
            "content_html": "<h1 id=\"去除水印\"><a class=\"markdownIt-Anchor\" href=\"#去除水印\">#</a> 去除水印</h1>\n<h2 id=\"裁剪法\"><a class=\"markdownIt-Anchor\" href=\"#裁剪法\">#</a> 裁剪法</h2>\n<p>适用于在图片边缘的水印</p>\n<h2 id=\"色阶法\"><a class=\"markdownIt-Anchor\" href=\"#色阶法\">#</a> 色阶法</h2>\n<p>适用于文件上的不透明水印</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E4%B8%AA%E4%BA%BA/PowerDesigner/%E4%BD%BF%E7%94%A8/",
            "url": "http://1405904364.github.io/2024/02/18/%E4%B8%AA%E4%BA%BA/PowerDesigner/%E4%BD%BF%E7%94%A8/",
            "title": "PowerDesigner工具的使用",
            "date_published": "2024-02-18T08:13:44.904Z",
            "content_html": "",
            "tags": [
                "PowerDesigner"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E4%B8%AA%E4%BA%BA/PhotoShop/1.%E4%BA%86%E8%A7%A3%E5%9B%BE%E5%B1%82/",
            "url": "http://1405904364.github.io/2024/02/18/%E4%B8%AA%E4%BA%BA/PhotoShop/1.%E4%BA%86%E8%A7%A3%E5%9B%BE%E5%B1%82/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.896Z",
            "content_html": "<h1 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h1>\n<h2 id=\"常用文件存储格式\"><a class=\"markdownIt-Anchor\" href=\"#常用文件存储格式\">#</a> 常用文件存储格式</h2>\n<p>1、PSD（*.psd）格式是 Adobe PhotoShop 软件自带的格式，这种格式可以存储 PtotoShop 中所有的图层、通道、参考线、注释和颜色模式等信息。</p>\n<p>2、DNG（*.dng）格式是一种用于数码生成的原始数据文件的公共存档格式。</p>\n<p>3、JPEG（*.jpg）格式是一种<strong>有损压缩格式</strong>，最大特色就是可以进行高倍率的压缩，文件比较小，是目前格式中压缩率非常高的格式。</p>\n<p>4、PNG（*.png）可以记录透明区域。png 格式可以保存 24 位的真彩色图像，能够支持透明背景色并具有消除锯齿边缘的功能。</p>\n<p>5、GIF（*.gif）格式最多只能保存 256 色的 RGB 色阶阶数。它使用 LZW 压缩方式压缩文件，并且不会占用太多的磁盘空间。</p>\n<p>6、TIFF（*.tif）印刷主要使用的格式。格式是一种无损压缩格式，便于在应用程序之间和计算机平台之间进行图像数据交换</p>\n<p>7、PSB（*.psb）超大型文件</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/7.%E6%80%BB%E7%BB%93/",
            "url": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/7.%E6%80%BB%E7%BB%93/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.888Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/1.top%E5%91%BD%E4%BB%A4/",
            "url": "http://1405904364.github.io/2024/02/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/1.top%E5%91%BD%E4%BB%A4/",
            "title": "top命令",
            "date_published": "2024-02-18T08:13:44.888Z",
            "content_html": "<h1 id=\"linux中top命令的使用\"><a class=\"markdownIt-Anchor\" href=\"#linux中top命令的使用\">#</a> Linux 中 top 命令的使用</h1>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h2>\n<p>top 命令是 Linux 中常用的性能分析工具，能够实时显示系统中各进程的资源占用状况，类似于 Windows 的任务管理器，显示系统当前的进程和其他状况</p>\n<blockquote>\n<p>top 是一个动态显示过程，即可以通过用户案件来不断刷新当前状态，如果在前台执行该命令，它将一直占用前台，知道用户终结该程序为止</p>\n</blockquote>\n<h2 id=\"使用方法\"><a class=\"markdownIt-Anchor\" href=\"#使用方法\">#</a> 使用方法</h2>\n<h3 id=\"使用格式\"><a class=\"markdownIt-Anchor\" href=\"#使用格式\">#</a> 使用格式</h3>\n<blockquote>\n<p>top [-] [选项 ]</p>\n</blockquote>\n<h3 id=\"参数说明\"><a class=\"markdownIt-Anchor\" href=\"#参数说明\">#</a> 参数说明</h3>\n<ul>\n<li>b：以批处理模式操作；</li>\n<li>c：显示完整的治命令；</li>\n<li>d：屏幕刷新间隔时间；</li>\n<li>I：忽略失效过程；</li>\n<li>s：保密模式；</li>\n<li>S：累积模式；</li>\n<li>i &lt;时间&gt;：设置间隔时间；</li>\n<li>u &lt;用户名&gt;：指定用户名；</li>\n<li>p &lt;进程号&gt;：指定进程；</li>\n<li>n &lt;次数&gt;：循环显示的次数。</li>\n</ul>\n<h3 id=\"交互命令\"><a class=\"markdownIt-Anchor\" href=\"#交互命令\">#</a> 交互命令</h3>\n<ul>\n<li>h：显示帮助画面，给出一些简短的命令总结说明；</li>\n<li>k：终止一个进程；</li>\n<li>i：忽略闲置和僵死进程，这是一个开关式命令；</li>\n<li>q：退出程序；</li>\n<li>r：重新安排一个进程的优先级别；</li>\n<li>S：切换到累计模式；</li>\n<li>s：改变两次刷新之间的延迟时间（单位为 s），如果有小数，就换算成 ms。输入 0 值则系 - 统将不断刷新，默认值是 5s；</li>\n<li>f 或者 F：从当前显示中添加或者删除项目；</li>\n<li>o 或者 O：改变显示项目的顺序；</li>\n<li>l：切换显示平均负载和启动时间信息；</li>\n<li>m：切换显示内存信息；</li>\n<li>t：切换显示进程和 CPU 状态信息；</li>\n<li>c：切换显示命令名称和完整命令行；</li>\n<li>M：根据驻留内存大小进行排序；</li>\n<li>P：根据 CPU 使用百分比大小进行排序；</li>\n<li>T：根据时间 / 累计时间进行排序；</li>\n<li>w：将当前设置写入～/.toprc 文件中。</li>\n</ul>\n<h3 id=\"进程区信息\"><a class=\"markdownIt-Anchor\" href=\"#进程区信息\">#</a> 进程区信息</h3>\n<p>序号  列名  含义<br>\n a  PID    进程 id<br>\nb  PPID    父进程 id<br>\nc  RUSER  Real user name<br>\nd  UID    进程所有者的用户 id<br>\ne  USER    进程所有者的用户名<br>\n f  GROUP  进程所有者的组名<br>\n g  TTY    启动进程的终端名。不是从终端启动的进程则显示为？<br>\nh  PR      优先级<br>\n i  NI      nice 值。负值表示高优先级，正值表示低优先级<br>\n j  P      最后使用的 CPU，仅在多 CPU 环境下有意义<br>\n k  % CPU    上次更新到现在的 CPU 时间占用百分比<br>\n l  TIME    进程使用的 CPU 时间总计，单位秒<br>\n m  TIME+  进程使用的 CPU 时间总计，单位 1/100 秒<br>\n n  % MEM    进程使用的物理内存百分比<br>\n o  VIRT    进程使用的虚拟内存总量，单位 kb。VIRT=SWAP+RES<br>\np  SWAP    进程使用的虚拟内存中，被换出的大小，单位 kb。<br>\nq  RES    进程使用的、未被换出的物理内存大小，单位 kb。RES=CODE+DATA<br>\nr  CODE    可执行代码占用的物理内存大小，单位 kb<br>\ns  DATA    可执行代码以外的部分 (数据段 + 栈) 占用的物理内存大小，单位 kb<br>\nt  SHR    共享内存大小，单位 kb<br>\nu  nFLT    页面错误次数<br>\n v  nDRT    最后一次写入到现在，被修改过的页面数。<br>\nw  S      进程状态。<br>\nD = 不可中断的睡眠状态<br>\n R = 运行<br>\n S = 睡眠<br>\n T = 跟踪 / 停止<br>\n Z = 僵尸进程<br>\n x  COMMAND 命令名 / 命令行<br>\n y  WCHAN  若该进程在睡眠，则显示睡眠中的系统函数名<br>\n z  Flags  任务标志，参考 sched.h<br>\n 默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、% CPU、% MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。</p>\n<p>更改显示内容</p>\n<p>通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。<br>\n按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。<br>\n按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。</p>\n",
            "tags": [
                "linux"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/1.%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B/",
            "url": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/1.%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.880Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/2.%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/",
            "url": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/2.%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.880Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/6.%E5%8F%98%E5%9F%BA/",
            "url": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/6.%E5%8F%98%E5%9F%BA/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.880Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/5.%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/",
            "url": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/5.%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.880Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/3.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/",
            "url": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/3.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.880Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/3.%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/",
            "url": "http://1405904364.github.io/2024/02/18/Git/2.Git%E5%88%86%E6%94%AF/3.%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.880Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/6.%E6%89%93%E6%A0%87%E7%AD%BE/",
            "url": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/6.%E6%89%93%E6%A0%87%E7%AD%BE/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.871Z",
            "content_html": "<h1 id=\"打标签\"><a class=\"markdownIt-Anchor\" href=\"#打标签\">#</a> 打标签</h1>\n<p>给仓库历史的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0、v2.0 等等）</p>\n<h2 id=\"列出标签\"><a class=\"markdownIt-Anchor\" href=\"#列出标签\">#</a> 列出标签</h2>\n<pre><code>// 以字母顺序列出标签\ngit tag\n\n// 以特定模式查找标签\n// -l 或 -list 选项按照通配符列出标签\ngit tag -l v1.*\n</code></pre>\n<h2 id=\"创建标签\"><a class=\"markdownIt-Anchor\" href=\"#创建标签\">#</a> 创建标签</h2>\n<p>git 支持两种标签：轻量标签与附注标签</p>\n<p>轻量标签很像一个不会改变的分支 - 它只是某个特定提交的引用</p>\n<p>附注标签是存储在 git 数据库中的一个完整对象，它们是可以被校验的，其中包含打标签的名字等</p>\n<h3 id=\"附注标签\"><a class=\"markdownIt-Anchor\" href=\"#附注标签\">#</a> 附注标签</h3>\n<pre><code>// -m 选项制定了一条存储在标签中的信息\ngit tag -a v1.4 -m &quot;my version 1.4&quot;\n\n// git show 可以看到标签信息与之对应的提交信息\ngit show\n输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。\n</code></pre>\n<h3 id=\"轻量标签\"><a class=\"markdownIt-Anchor\" href=\"#轻量标签\">#</a> 轻量标签</h3>\n<pre><code>git tag v1.4\n</code></pre>\n<h2 id=\"后期打标签\"><a class=\"markdownIt-Anchor\" href=\"#后期打标签\">#</a> 后期打标签</h2>\n<pre><code>// 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）\ngit tag -a v1.2 9fceb02\n</code></pre>\n<h2 id=\"共享标签\"><a class=\"markdownIt-Anchor\" href=\"#共享标签\">#</a> 共享标签</h2>\n<p>默认情况下，git push 不会传送标签到远程服务器上。在创建完标签后你必须显示地推送标签到共享服务器上。这个过程就像共享远程分支一样–你可以运行 git push origin <tagname>。</p>\n<p>如果一次要推送很多标签，也可以时可用带有 --tags 选项的 git push 命令。这将会把所有不在远程服务器上的标签全部传送到哪里</p>\n<pre><code>git push origin --tags\n</code></pre>\n<p>这样，其他人从仓库克隆或者拉取，就能得到你那些标签</p>\n<p>注意： git push <remote> --tags 命令不会区分轻量标签和附注标签，没有简单的选项能够让你只选择推送一种标签</p>\n<h2 id=\"删除标签\"><a class=\"markdownIt-Anchor\" href=\"#删除标签\">#</a> 删除标签</h2>\n<pre><code>git tag -d &lt;tagname&gt;\n</code></pre>\n<p>上述命令不会从任何远程仓库中删除这个标签</p>\n<p>删除远程标签：</p>\n<p>第一种方式：(更高效)<br>\ngit push <remote> :refs/tags/<tagname></p>\n<p>例如：<br>\ngit push origin :refs/tags/v1.4-lw</p>\n<p>第二种方式：<br>\ngit push origin --delete <tagname></p>\n<h2 id=\"检出标签\"><a class=\"markdownIt-Anchor\" href=\"#检出标签\">#</a> 检出标签</h2>\n<p>查看某个标签所指向的文件版本，可以使用 git checkout 命令。该命令会使你的仓库处于 “分离头指针（detached HEAD）” 的状态 — 有些不好的副作用</p>\n<pre><code>git checkout 2.0.0\n</code></pre>\n<p>在 “分离头指针” 状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p>\n<pre><code>$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n</code></pre>\n<p>如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。</p>\n<hr>\n<h2 id=\"列出所有tag\"><a class=\"markdownIt-Anchor\" href=\"#列出所有tag\">#</a> 列出所有 tag</h2>\n<blockquote>\n<p>git tag // 默认显示<br>\n git tag -l<br>\ngit tag -n // 查看所有 tag 和说明<br>\n git tag -l v1.* // 查看匹配到的 tag<br>\ngit ls-remote --tags origin // 查看远程所有 tag</p>\n</blockquote>\n<h2 id=\"查看tag信息\"><a class=\"markdownIt-Anchor\" href=\"#查看tag信息\">#</a> 查看 tag 信息</h2>\n<blockquote>\n<p>git show v1.0.1 <span class=\"exturl\" data-url=\"Ly94bi0tdjEtMTI4ZDI3NmMuMC54bi0tMS1pNDdhbDcyYTMxMWE=\">// 查看 v1.0.1 的内容</span></p>\n</blockquote>\n<h2 id=\"创建tag\"><a class=\"markdownIt-Anchor\" href=\"#创建tag\">#</a> 创建 tag</h2>\n<blockquote>\n<p>git tag v2.0<br>\ngit push origin // 远程 tag 的创建</p>\n</blockquote>\n<h2 id=\"创建带注释的tag\"><a class=\"markdownIt-Anchor\" href=\"#创建带注释的tag\">#</a> 创建带注释的 tag</h2>\n<blockquote>\n<p>git tag -a v2.1 -m ‘第二版本’ //-m 后面跟着的是注释信息，当使用 git show v2.0 的时候，会显示这个注释信息</p>\n</blockquote>\n<h2 id=\"推送tag\"><a class=\"markdownIt-Anchor\" href=\"#推送tag\">#</a> 推送 tag</h2>\n<blockquote>\n<p>git push origin [tagname] // 推送到远程仓库<br>\n git push origin --tags // 推送所有 tag 到远程仓库</p>\n</blockquote>\n<h2 id=\"特定commit_id-创建tag\"><a class=\"markdownIt-Anchor\" href=\"#特定commit_id-创建tag\">#</a> 特定 commit_id 创建 tag</h2>\n<blockquote>\n<p>git tag -a v3.1 [commitID] // 为之前的历史提交添加 tag</p>\n</blockquote>\n<h2 id=\"删除tag\"><a class=\"markdownIt-Anchor\" href=\"#删除tag\">#</a> 删除 tag</h2>\n<blockquote>\n<p>git tag -d // 方式一<br>\n git tag -d [tagname] // 方式二<br>\n git push origin :refs/tags/v2.0 // 方式一：远程 tag 的删除<br>\n git push origin --delete <tagname> // 方式二：远程 tag 的删除</p>\n</blockquote>\n<h2 id=\"重命名tag\"><a class=\"markdownIt-Anchor\" href=\"#重命名tag\">#</a> 重命名 tag</h2>\n<blockquote>\n<p>// 方式一：强制替换，再删除原有<br>\n git tag -f <new-tag> <old-tag><br>\ngit tag -d <old-tag></p>\n<p>// 方式二：删除原有 tag，重新添加<br>\n git tag -d <old-tag><br>\ngit tag -a <new-tag> -m ‘information’</p>\n</blockquote>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/5.%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/5.%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.871Z",
            "content_html": "<h1 id=\"远程仓库的使用\"><a class=\"markdownIt-Anchor\" href=\"#远程仓库的使用\">#</a> 远程仓库的使用</h1>\n<h2 id=\"查看远程仓库\"><a class=\"markdownIt-Anchor\" href=\"#查看远程仓库\">#</a> 查看远程仓库</h2>\n<pre><code>git remote\n</code></pre>\n<p>它会列出你指定的每一个远程服务器的简写</p>\n<pre><code>git remote -v\n</code></pre>\n<p>它会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</p>\n<h2 id=\"添加远程仓库\"><a class=\"markdownIt-Anchor\" href=\"#添加远程仓库\">#</a> 添加远程仓库</h2>\n<pre><code>git remote add &lt;shortname&gt; &lt;url&gt;\n</code></pre>\n<p>使用该命令添加一个新的远程仓库，同时指定远程仓库的简介 shortname</p>\n<h2 id=\"从远程仓库中抓取与拉取\"><a class=\"markdownIt-Anchor\" href=\"#从远程仓库中抓取与拉取\">#</a> 从远程仓库中抓取与拉取</h2>\n<pre><code>git fetch &lt;remote&gt;\n</code></pre>\n<p>这个命令会访问远程仓库，从中拉去所有你还没有的数据。执行完成后，你将拥有那个远程仓库中所有分支的引用，可以随时合并或查看</p>\n<p>注意：git fetch origin 会抓取后新推送的所有工作，但是它之后将数据下载到你本地仓库 — 不会自动合并或修改你当前的工作，当准备好时，你必须手动将其合并入你的工作</p>\n<pre><code>git pull\n</code></pre>\n<p>该命令会自动拉取远程分支到当前分支，并自动尝试合并到当前所在的分支</p>\n<h2 id=\"推送到远程仓库\"><a class=\"markdownIt-Anchor\" href=\"#推送到远程仓库\">#</a> 推送到远程仓库</h2>\n<pre><code>git push &lt;remote&gt; &lt;branch&gt;\n\ngit push &lt;remote&gt; 本地分支:远程仓库分支\n\n推送一个空分支到远程仓库分支，表示删除该分支\ngit push &lt;remote&gt; :远程仓库分支\ngit push &lt;remote&gt; --delete 远程分支\n</code></pre>\n<h2 id=\"查看某个远程仓库\"><a class=\"markdownIt-Anchor\" href=\"#查看某个远程仓库\">#</a> 查看某个远程仓库</h2>\n<p>查看远程仓库的更多信息</p>\n<pre><code>git remote show &lt;remote&gt;\n</code></pre>\n<h2 id=\"远程仓库的重命名与移除\"><a class=\"markdownIt-Anchor\" href=\"#远程仓库的重命名与移除\">#</a> 远程仓库的重命名与移除</h2>\n<pre><code>git remote rename pb paul\n</code></pre>\n<p>这会修改你所有远程跟踪的分支的名字，例如过去的 pb/master 现在会变为 paul/master</p>\n<pre><code>git remote remove paul\ngit remote rm paul\n</code></pre>\n<p>这会移除一个远程仓库<br>\n<strong>一旦以这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会被一起删除</strong></p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/7.Git%E5%88%AB%E5%90%8D/",
            "url": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/7.Git%E5%88%AB%E5%90%8D/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.871Z",
            "content_html": "<h1 id=\"git别名\"><a class=\"markdownIt-Anchor\" href=\"#git别名\">#</a> Git 别名</h1>\n<p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p>\n<pre><code>$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n</code></pre>\n<p>这意味着，当要输入 git commit 时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/%E6%80%BB%E7%BB%93/",
            "url": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/%E6%80%BB%E7%BB%93/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.871Z",
            "content_html": "<p>查看全局配置<br>\n git config --global --list</p>\n<p>配置用户名<br>\n git config --global <span class=\"exturl\" data-url=\"aHR0cDovL3VzZXIubmFtZQ==\">user.name</span> “userName”</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99/",
            "url": "http://1405904364.github.io/2024/02/18/Git/%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.863Z",
            "content_html": "<h1 id=\"git-gitignore-文件的忽略规则\"><a class=\"markdownIt-Anchor\" href=\"#git-gitignore-文件的忽略规则\">#</a> git .gitignore 文件的忽略规则</h1>\n<h1 id=\"注释-gitignore-以中-开头作为注释\"><a class=\"markdownIt-Anchor\" href=\"#注释-gitignore-以中-开头作为注释\">#</a> 注释  .gitignore 以中 ‘#’ 开头作为注释</h1>\n<h1 id=\"忽略所有txt后缀的文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略所有txt后缀的文件\">#</a> 忽略所有.txt 后缀的文件</h1>\n<p>.txt</p>\n<h1 id=\"忽略除srca外的其他文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略除srca外的其他文件\">#</a> 忽略除 src.a 外的其他文件</h1>\n<p>!src.a</p>\n<h1 id=\"仅忽略项目根目录下的todo文件不包括-srctodo\"><a class=\"markdownIt-Anchor\" href=\"#仅忽略项目根目录下的todo文件不包括-srctodo\">#</a> 仅忽略项目根目录下的 todo 文件，不包括 src/todo</h1>\n<p>/todo</p>\n<h1 id=\"忽略-build-目录下的所有文件过滤整个build文件夹\"><a class=\"markdownIt-Anchor\" href=\"#忽略-build-目录下的所有文件过滤整个build文件夹\">#</a> 忽略 build/ 目录下的所有文件，过滤整个 build 文件夹</h1>\n<p>build/</p>\n<h1 id=\"忽略doc目录下所有-txt-后缀的文件但不包括doc子目录中的txt文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略doc目录下所有-txt-后缀的文件但不包括doc子目录中的txt文件\">#</a> 忽略 doc 目录下所有 .txt 后缀的文件，但不包括 doc 子目录中的.txt 文件</h1>\n<p>doc/*.txt</p>\n<h1 id=\"忽略当前路径下的-bin-文件夹该文件夹下的所有内容都会被忽略不忽略-bin-文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略当前路径下的-bin-文件夹该文件夹下的所有内容都会被忽略不忽略-bin-文件\">#</a> 忽略当前路径下的 bin 文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</h1>\n<p>bin/</p>\n<h1 id=\"忽略根目录下的-bin-文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略根目录下的-bin-文件\">#</a> 忽略根目录下的 bin 文件</h1>\n<p>/bin</p>\n<h1 id=\"忽略-catc不忽略-buildcatc\"><a class=\"markdownIt-Anchor\" href=\"#忽略-catc不忽略-buildcatc\">#</a> 忽略 cat.c，不忽略 build/cat.c</h1>\n<p>/*.c</p>\n<h1 id=\"忽略debugioobj不忽略-debugcommonioobj和toolsdebugioobj\"><a class=\"markdownIt-Anchor\" href=\"#忽略debugioobj不忽略-debugcommonioobj和toolsdebugioobj\">#</a> 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj</h1>\n<p>debug/*.obj</p>\n<h1 id=\"忽略foo-afoo-abfoo等\"><a class=\"markdownIt-Anchor\" href=\"#忽略foo-afoo-abfoo等\">#</a> 忽略 /foo, a/foo, a/b/foo 等</h1>\n<p>**/foo</p>\n<h1 id=\"忽略ab-axb-axyb等\"><a class=\"markdownIt-Anchor\" href=\"#忽略ab-axb-axyb等\">#</a> 忽略 a/b, a/x/b, a/x/y/b 等</h1>\n<p>a/**/b</p>\n<h1 id=\"不忽略bin目录下的runsh文件\"><a class=\"markdownIt-Anchor\" href=\"#不忽略bin目录下的runsh文件\">#</a> 不忽略 bin 目录下的 run.sh 文件</h1>\n<p>!/bin/run.sh</p>\n<h1 id=\"忽略所有-log-文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略所有-log-文件\">#</a> 忽略所有 .log 文件</h1>\n<p>*.log</p>\n<h1 id=\"忽略当前路径的-configjs-文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略当前路径的-configjs-文件\">#</a> 忽略当前路径的 config.js 文件</h1>\n<p>config.js</p>\n<h1 id=\"忽略整个文件夹\"><a class=\"markdownIt-Anchor\" href=\"#忽略整个文件夹\">#</a> 忽略整个文件夹</h1>\n<p>/mtk/</p>\n<h1 id=\"忽略所有zip文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略所有zip文件\">#</a> 忽略所有.zip 文件</h1>\n<p>*.zip</p>\n<h1 id=\"忽略某个具体文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略某个具体文件\">#</a> 忽略某个具体文件</h1>\n<p>/mtk/do.c</p>\n<h1 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h1>\n<p><strong>被过滤掉的文件就不会出现在 git 仓库中（gitlab 或 github）了，当然本地库中还有，只是 push 的时候不会上传。</strong></p>\n<p>2、语法解释<br>\n在 .gitignore 文件中，每一行的忽略规则的语法如下：</p>\n<p>1）空格不匹配任意文件，可作为分隔符，可用反斜杠转义；</p>\n<p>2）以 “＃” 开头的行都会被 Git 忽略。即 #开头的文件标识注释，可以使用反斜杠进行转义；</p>\n<p>3）可以使用标准的 glob 模式匹配。所谓的 glob 模式是指 shell 所使用的简化了的正则表达式；</p>\n<p>4）以斜杠 “/” 开头表示目录；“/” 结束的模式只匹配该文件夹以及在该文件夹路径下的内容，但是不匹配该文件；&quot;/&quot; 开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录；</p>\n<p>5）以星号 “*” 通配多个字符，即匹配多个任意字符；使用两个星号 “**” 表示匹配任意中间目录，比如 <code>a/**/z</code>  可以匹配 a/z, a/b/z 或 a/b/c/z 等；</p>\n<p>6）以问号 &quot;?&quot; 通配单个字符，即匹配一个任意字符；</p>\n<p>7）以方括号 “[] ” 包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如 [abc] 表示要么匹配一个 a，要么匹配一个 b，要么匹配一个 c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如 [0-9] 表示匹配所有 0 到 9 的数字，[a-z] 表示匹配任意的小写字母）；</p>\n<p>8）以叹号 &quot;!&quot; 表示不忽略 (跟踪) 匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反；</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/1.%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93/",
            "url": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/1.%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.863Z",
            "content_html": "<h1 id=\"获取git仓库\"><a class=\"markdownIt-Anchor\" href=\"#获取git仓库\">#</a> 获取 Git 仓库</h1>\n<h2 id=\"获取git仓库-2\"><a class=\"markdownIt-Anchor\" href=\"#获取git仓库-2\">#</a> 获取 Git 仓库</h2>\n<ol>\n<li>\n<p>将尚未进行版本控制的本地目录转换为 Git 仓库</p>\n<pre><code> git init\n\n git init 目录名称\n\n 例如：\n\n // 在当前目录下，创建git仓库\n git init\n\n // 在当前目录创建一个名为blob的目录，并在其中创建git仓库\n git init blob\n\n git init blob/a\n\n // '/'斜杠代表根目录\n git init /blob/a\n</code></pre>\n</li>\n<li>\n<p>从其他服务器克隆一个已经存在的 Git 仓库</p>\n<pre><code>git clone 仓库地址 [自定义仓库名称]\n\n例如\n\n// 在当前目录下，创建一个名为&quot;libgit2&quot;的目录，并在这个目录下初始化一个.git文件夹（创建git仓库）\ngit clone https://github.com/libgit2/libgit2\n\n// 该命令操作同上，但是创建的目录名变为了mylibgit\ngit clone https://github.com/libgit2/libgit2 mylibgit\n</code></pre>\n</li>\n</ol>\n<p>Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。 在服务器上搭建 Git 将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/2.%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93/",
            "url": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/2.%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.863Z",
            "content_html": "<h1 id=\"更新仓库\"><a class=\"markdownIt-Anchor\" href=\"#更新仓库\">#</a> 更新仓库</h1>\n<p>现在的 Git 仓库中，文件只有两种状态，<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。</p>\n<h2 id=\"检查文件状态\"><a class=\"markdownIt-Anchor\" href=\"#检查文件状态\">#</a> 检查文件状态</h2>\n<pre><code>// 会查看哪些文件处于什么状态\ngit status\n</code></pre>\n<h2 id=\"跟踪新文件\"><a class=\"markdownIt-Anchor\" href=\"#跟踪新文件\">#</a> 跟踪新文件</h2>\n<pre><code>// 如果参数是文件，则会跟踪该文件·\n// 如果参数是目录，则会递归跟踪该目录下的所有文件\ngit add [文件/目录的路径]\n</code></pre>\n<p>注意：该命令可以</p>\n<p><strong>跟踪新文件</strong></p>\n<p><strong>也可以将已经跟踪的文件放入到暂存区</strong></p>\n<p><strong>可用于合并时，出现冲突后，把冲突文件标记为已解决的状态</strong></p>\n<h2 id=\"暂存已修改文件\"><a class=\"markdownIt-Anchor\" href=\"#暂存已修改文件\">#</a> 暂存已修改文件</h2>\n<pre><code>// 命令同上\ngit add\n</code></pre>\n<h2 id=\"状态简览\"><a class=\"markdownIt-Anchor\" href=\"#状态简览\">#</a> 状态简览</h2>\n<pre><code>// 缩短命令的输出\ngit status -s\ngit status -short\n\n例如：\n\n$ git status -s\nM README\nMM Rakefile\nA  lib/git.rb\nM  lib/simplegit.rb\n?? LICENSE.txt\n</code></pre>\n<p>新添加的未跟踪文件前面有？？标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>\n<h2 id=\"忽略文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略文件\">#</a> 忽略文件</h2>\n<p>遇到一些不需要加入到 git 管理的文件，可以创建忽略文件。</p>\n<p>创建一个名为 .gitignore 的文件，列出要忽略的文件的模式</p>\n<p>文件.gitignore 的格式规范如下：</p>\n<pre><code>1. 所有空行或者以 # 开头的行都会被Git忽略\n\n2. 可以使用标准的glob模式匹配，它会递归的应用在整个工作区中\n\n3. 匹配模式可以以（/）开头防止递归\n\n4. 匹配模式可以以（/）结尾指定目录\n\n5. 要忽略指定模式以外的文件或目录，可以在模式前加上感叹号（！）取反\n</code></pre>\n<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。</p>\n<pre><code>星号（*）匹配零个或多个任意字符\n\n[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一   个 a，要么匹配一个 b，要么匹配一个 c）\n\n问号（?）只匹配一个任意字符\n\n如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符 范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数  字）\n\n使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等\n</code></pre>\n<p>案例：</p>\n<pre><code>\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO\n# / 斜杠在开头，防止递归（忽略当前目录下的所有 TODO 文件）\n/TODO\n\n# 忽略任何目录下名为 build 的文件夹\n# 没有以斜杠开头，且又以斜杠结尾（表明该规则时作用于文件夹），则会进行递归（忽略当前目录下的所有 build 文件夹）\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n</code></pre>\n<p><strong>Tip:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9naXRpZ25vcmU=\">https://github.com/github/gitignore</span></strong></p>\n<h2 id=\"查看已暂存和未暂存的修改\"><a class=\"markdownIt-Anchor\" href=\"#查看已暂存和未暂存的修改\">#</a> 查看已暂存和未暂存的修改</h2>\n<pre><code>// 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容\ngit diff\n\n// 这条命令将对比已暂存文件于最后一次提交的文件差异\ngit diff --staged\ngit diff --cached\n// 以上两条命令作用相同（--staged 和 --cached 是同义词）\n</code></pre>\n<h2 id=\"提交更新\"><a class=\"markdownIt-Anchor\" href=\"#提交更新\">#</a> 提交更新</h2>\n<pre><code>// 将暂存区的内容提交\ngit commit\n// 以上命令会打开默认编辑器来输入提交说明\n\ngit commit -m 提交说明\n</code></pre>\n<p>注意：未暂存的文件之后保留在本地磁盘上，可以在下一次提交时纳入版本管理。每一次提交操作，都会对你的项目做一次快照，以后可以回到这个状态，或者进行比较</p>\n<h2 id=\"跳过使用暂存区域\"><a class=\"markdownIt-Anchor\" href=\"#跳过使用暂存区域\">#</a> 跳过使用暂存区域</h2>\n<p>在 git 中，使用暂存区域可以精确的准备好要提交的细节（比如那些文件需要提交，那些不需要），但是有时候会略显繁琐。Git 提供了快速提交的方式来跳过暂存区域。<br>\ngit commit -a -m 提交说明</p>\n<p>这种方式会自动将所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 的步骤。<br>\n注意：这种方式会及那个所有跟踪过的文件全部提交，使用时需要注意。而那些新添加的未被跟踪的文件不会被提交</p>\n<pre><code>git commit --amend -m 覆盖上一次提交说明\n</code></pre>\n<h2 id=\"移除文件\"><a class=\"markdownIt-Anchor\" href=\"#移除文件\">#</a> 移除文件</h2>\n<h3 id=\"情况一将已经被跟踪的文件删除\"><a class=\"markdownIt-Anchor\" href=\"#情况一将已经被跟踪的文件删除\">#</a> 情况一：将已经被跟踪的文件删除</h3>\n<p>要从 Git 中移除文件，就必须要从已跟踪文件清单中清除（从暂存区域中清除），然后提交</p>\n<pre><code>git rm 文件名称\ngit rm -r 路径\n</code></pre>\n<p><strong>git rm 命令可以完成删除工作， 并连带将工作区中的指定文件或目录删除</strong></p>\n<p>如果要删除的文件之前进行过修改，或者已经被放到了暂存区，则必须使用强制删除选项 -f （即： force 强制）。这是一种安全机制，用于防止误删除尚未添加到快照中的数据，因为这样未被添加到快照的数据不能被 Git 恢复</p>\n<h3 id=\"情况二将仓库的文件删除同样将暂存区的文件也进行删除但保留工作区的文件\"><a class=\"markdownIt-Anchor\" href=\"#情况二将仓库的文件删除同样将暂存区的文件也进行删除但保留工作区的文件\">#</a> 情况二：将仓库的文件删除（同样将暂存区的文件也进行删除），但保留工作区的文件</h3>\n<p>例如：之前没有使用.gitignore 文件，不小心将很多.log 日志文件添加到仓库中，现在需要将仓库的这些.log 文件删除，但是保留工作区的.log 文件</p>\n<pre><code>git rm --cached 文件名称\n</code></pre>\n<p>git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。比如：</p>\n<pre><code>git rm log/\\*.log\n</code></pre>\n<p>注意到星号 * 之前的反斜杠 \\， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如：</p>\n<pre><code>git rm \\*~\n</code></pre>\n<h3 id=\"清空三删除未跟踪的文件\"><a class=\"markdownIt-Anchor\" href=\"#清空三删除未跟踪的文件\">#</a> 清空三：删除未跟踪的文件</h3>\n<pre><code>git clean -n -d\n\ngit clean -f target\n</code></pre>\n<h2 id=\"移动文件\"><a class=\"markdownIt-Anchor\" href=\"#移动文件\">#</a> 移动文件</h2>\n<pre><code>git mv file_from file_to\n</code></pre>\n<p>实际上，git mv 相当于三条命令</p>\n<p>mv file_from file_to<br>\ngit rm file_from<br>\ngit add file_to</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/4.%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/",
            "url": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/4.%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.863Z",
            "content_html": "<h1 id=\"撤销操作\"><a class=\"markdownIt-Anchor\" href=\"#撤销操作\">#</a> 撤销操作</h1>\n<pre><code>git commit --amend\n</code></pre>\n<p>该命令会将暂存区的文件提交，同时可以修改提交信息（用来覆盖上一次的提交信息）</p>\n<h2 id=\"取消暂存文件\"><a class=\"markdownIt-Anchor\" href=\"#取消暂存文件\">#</a> 取消暂存文件</h2>\n<pre><code>git reset head [file]\n</code></pre>\n<p>该命令用于取消暂存文件</p>\n<h2 id=\"取消对文件的修改\"><a class=\"markdownIt-Anchor\" href=\"#取消对文件的修改\">#</a> 取消对文件的修改</h2>\n<pre><code>git checkout --&lt;file&gt;\n</code></pre>\n<p>注意：该命令是非常危险的，你对这个文件在本地工作区的任何修改都会消失–Git 会使用最近提交的版本覆盖掉它</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/3.%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2/",
            "url": "http://1405904364.github.io/2024/02/18/Git/1.Git%E5%9F%BA%E7%A1%80/3.%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2/",
            "title": "",
            "date_published": "2024-02-18T08:13:44.863Z",
            "content_html": "<h1 id=\"查看提交历史\"><a class=\"markdownIt-Anchor\" href=\"#查看提交历史\">#</a> 查看提交历史</h1>\n<p>查看项目的提交历史</p>\n<pre><code>git log\n</code></pre>\n<p>不传入任何参数的默认情况下，git log 会按照时间先后顺序列出所有的提交</p>\n<h2 id=\"git-log-参数\"><a class=\"markdownIt-Anchor\" href=\"#git-log-参数\">#</a> git log 参数</h2>\n<h3 id=\"-p\"><a class=\"markdownIt-Anchor\" href=\"#-p\">#</a> -p</h3>\n<pre><code>git log -p\ngit log -patch\n</code></pre>\n<p>它会显示每次所提交的差异（按补丁的格式输出）</p>\n<h3 id=\"-显示日志条目数量\"><a class=\"markdownIt-Anchor\" href=\"#-显示日志条目数量\">#</a> - 显示日志条目数量</h3>\n<p>你也可以显示显示的条目数量</p>\n<pre><code>git log -p -2\n</code></pre>\n<h3 id=\"-stat\"><a class=\"markdownIt-Anchor\" href=\"#-stat\">#</a> -stat</h3>\n<pre><code>git log --stat\n</code></pre>\n<p>它会显示每次提交的简略统计信息</p>\n<p>git log 笔记暂时就写到这里</p>\n",
            "tags": []
        },
        {
            "id": "http://1405904364.github.io/2023/08/10/hello-world/",
            "url": "http://1405904364.github.io/2023/08/10/hello-world/",
            "title": "Hello World",
            "date_published": "2023-08-10T03:59:27.411Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"markdownIt-Anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"markdownIt-Anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"markdownIt-Anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"markdownIt-Anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"markdownIt-Anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}