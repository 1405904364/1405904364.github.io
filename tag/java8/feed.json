{
    "version": "https://jsonfeed.org/version/1",
    "title": "Live My Life • All posts by \"java8\" tag",
    "description": "个人学习使用",
    "home_page_url": "http://1405904364.github.io",
    "items": [
        {
            "id": "http://1405904364.github.io/2023/08/10/Java/Stream%E6%B5%81/",
            "url": "http://1405904364.github.io/2023/08/10/Java/Stream%E6%B5%81/",
            "title": "Stream流式编程",
            "date_published": "2023-08-10T08:29:50.064Z",
            "content_html": "<h1 id=\"stream流式编程\"><a class=\"markdownIt-Anchor\" href=\"#stream流式编程\">#</a> Stream 流式编程</h1>\n<h2 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类</h2>\n<p><img data-src=\"/image/Java/13170952_625693608975b29303.webp\" alt=\"分类图片\"></p>\n<p><strong>中间操作</strong>可分为：</p>\n<blockquote>\n<ul>\n<li>无状态：指元素的处理不受之前元素的影响</li>\n<li>有状态：指该操作只有拿到所有元素之后才能继续下去</li>\n</ul>\n</blockquote>\n<p><strong>终结操作</strong>可分为：</p>\n<blockquote>\n<ul>\n<li>非短路操作：指必须处理所有元素才能得到最终结果</li>\n<li>短路操作：指遇到某些符合条件的元素就可以得到最终结果</li>\n</ul>\n</blockquote>\n<p>具体操作如图所示：</p>\n<p><img data-src=\"/image/Java/20201218181011714.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"stream-api使用\"><a class=\"markdownIt-Anchor\" href=\"#stream-api使用\">#</a> Stream API 使用</h2>\n<h3 id=\"流的构成\"><a class=\"markdownIt-Anchor\" href=\"#流的构成\">#</a> 流的构成</h3>\n<blockquote>\n<p>使用流的时候，通常包括三个步骤：</p>\n<ol>\n<li>获取一个数据源</li>\n<li>数据转换<br>\n执行操作获取想要的结果，每次转换原有的 Stream 对象不变，返回一个新的 Stream 对象，这就允许对其操作可以像链条一样排列</li>\n</ol>\n</blockquote>\n<h3 id=\"流的创建\"><a class=\"markdownIt-Anchor\" href=\"#流的创建\">#</a> 流的创建</h3>\n<ul>\n<li>\n<p>通过 java.util.Collection.stream () 方法用集合创建流</p>\n<pre><code class=\"language-Java\">\n  List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;stream&quot;);\n  //创建顺序流\n  Stream&lt;String&gt; stream = list.stream();\n  //创建并行流\n  Stream&lt;String&gt; parallelStream = list.parallelStream();\n\n</code></pre>\n</li>\n<li>\n<p>使用 java.util.Arrays.stream (T [] array) 方法用数组创建流</p>\n<pre><code class=\"language-Java\">\n  String[] array = &#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;&#125;;\n  Stream&lt;String&gt; arrayStream = Arrays.stream(array);\n\n</code></pre>\n</li>\n<li>\n<p>Stream 的静态方法：of ()、iterate ()、generate ()</p>\n<pre><code class=\"language-Java\">\n  Stream&lt;Integer&gt; stream1 = Stream.of(1, 2, 3, 4, 5, 6);\n  \n  Stream&lt;Integer&gt; stream2 = Stream.iterate(0, (x) -&gt; x + 2).limit(3);\n  \n  Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(3);\n\n</code></pre>\n</li>\n<li>\n<p>stream 和 parallelStream 的简单区分</p>\n</li>\n</ul>\n<blockquote>\n<p>stream 是顺序流，由主线程按顺序对流执行操作，而 parallelStream 是并行流，内部以多线程并行执行的方式对流进行操作，需要注意使用并行流的前提是流中的数据处理没有顺序要求（会乱序，即使用了 forEachOrdered）</p>\n</blockquote>\n<hr>\n<h3 id=\"一-stream中间操作\"><a class=\"markdownIt-Anchor\" href=\"#一-stream中间操作\">#</a> 一、Stream 中间操作</h3>\n<pre><code>Stream流中间操作是指在流链当中，可以对数据进行处理操作，包括filter过滤、map映射转换、flatMap合并、distinct去重、sorted排序等操作，这些操作都会返回一个新的Stream流对象，可以通过链式调用多个中间操作进行复杂的数据处理。\n\n需要注意的是，中间操作需要具有终止操作才会触发。\n</code></pre>\n<h4 id=\"无状态stateless操作\"><a class=\"markdownIt-Anchor\" href=\"#无状态stateless操作\">#</a> 无状态 (Stateless) 操作</h4>\n<h5 id=\"filter过滤出符合条件的元素\"><a class=\"markdownIt-Anchor\" href=\"#filter过滤出符合条件的元素\">#</a> filter: 过滤出符合条件的元素</h5>\n<blockquote>\n<p>filter () 方法常用于实现数据过滤，即可以对集合、数组等数据源筛选出符合指定条件的元素，并返回一个新的流</p>\n</blockquote>\n<pre><code class=\"language-Java\">// 将数组转换为一个字符串列表\nList&lt;String&gt; numbers = Arrays.asList&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13358520000&quot;);\n// 通过stream()方法创建一个流，接着使用filter方法过滤出前缀为&quot;133&quot;的元素，最终通过collect()方法将结果收集到一个新的列表中\nList&lt;String&gt; filterNumbers = numbers.stream().filter(s -&gt; s.startWith(&quot;133&quot;)).collect(Collectors.toList());\nSystem.out.println(filterNumbers);\n\n打印结果：[13378520000, 13358520000]\n</code></pre>\n<hr>\n<h5 id=\"map映射转换元素\"><a class=\"markdownIt-Anchor\" href=\"#map映射转换元素\">#</a> map: 映射转换元素</h5>\n<blockquote>\n<p>map 方法用于对流中的每个元素进行映射操作，将其转换为另一个元素或者提取其中的信息，并返回一个新的流</p>\n</blockquote>\n<p>1.2.1 转换元素</p>\n<blockquote>\n<p>获取每个手机号的前七位子字符串</p>\n</blockquote>\n<pre><code class=\"language-Java\">List&lt;String&gt; numbers = Arrays.asList(&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13558520000&quot;);\n//通过stream()方法创建一个流，使用map()方法将每个字符串转换为截取前7位的字符，最后使用collect()方法将结果收集到一个新列表中\nList&lt;String&gt; filterdNumbers = numbers.stream().map(s -&gt; s.substring(0,7)).collect(Collectors.toList());\nSystem.out.println(filterdNumbers);\n\n\n打印结果：[1337852, 1327852, 1317852, 1355852]\n\n</code></pre>\n<hr>\n<p>1.2.2 提取元素信息</p>\n<blockquote>\n<p>获取每个对象的手机号</p>\n</blockquote>\n<pre><code class=\"language-Java\">List&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,&quot;13378520000&quot;),\n        new People(&quot;李二&quot;,&quot;13278520000&quot;),\n        new People(&quot;张四&quot;,&quot;13178520000&quot;)\n);\n//通过stream()方法创建一个流，使用map()方法提取每个用户的手机号，最后使用collect()方法将结果收集到一个新列表中\nList&lt;String&gt; tel = peopleList.stream().map(People::getTel).collect(Collectors.toList());\nSystem.out.println(tel);\n\n\n打印结果：[13378520000, 13278520000, 13178520000]\n</code></pre>\n<hr>\n<h5 id=\"flatmap将多个流合并为一个流\"><a class=\"markdownIt-Anchor\" href=\"#flatmap将多个流合并为一个流\">#</a> flatMap: 将多个流合并为一个流</h5>\n<p>1.3.1 实现多对多的映射</p>\n<blockquote>\n<p>将 A 组数据和 B 组数据一次进行相加</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;Integer&gt; listA = Arrays.asList(1,2,3);\nList&lt;Integer&gt; listB = Arrays.asList(4, 5, 6);\nList&lt;Integer&gt; list = listA.stream().flatMap(a -&gt; listB.stream().map(b -&gt; a +b)).collect(Collectors.toList());\nSystem.out.println(list);\n\n\n打印结果:  [5, 6, 7, 6, 7, 8, 7, 8, 9]\n</code></pre>\n<hr>\n<p>1.3.2 将多个列表合并成一个列表</p>\n<pre><code class=\"language-Java\">\nList&lt;List&lt;String&gt;&gt; listOfLists = Arrays.asList(\n        Arrays.asList(&quot;13378520000&quot;, &quot;13278520000&quot;),\n        Arrays.asList(&quot;13178520000&quot;, &quot;13558520000&quot;),\n        Arrays.asList(&quot;15138510000&quot;, &quot;15228310000&quot;)\n);\nList&lt;String&gt; flatMapList = listOfLists.stream().flatMap(Collection::stream).collect(Collectors.toList());\nSystem.out.println(flatMapList);\n\n\n打印结果：[13378520000, 13278520000, 13178520000, 13558520000, 15138510000, 15228310000]\n\n</code></pre>\n<hr>\n<h5 id=\"peek查看每个元素的信息但不改变流中元素的状态\"><a class=\"markdownIt-Anchor\" href=\"#peek查看每个元素的信息但不改变流中元素的状态\">#</a> peek: 查看每个元素的信息，但不改变流中元素的状态</h5>\n<pre><code class=\"language-Java\">\nList&lt;String&gt; telList = Arrays.asList(&quot;13378520000&quot;,&quot;13278520000&quot;,&quot;13178520000&quot;,&quot;13558520000&quot;);\ntelList.stream().peek(t -&gt; System.out.println(t))\n        .map(t -&gt; t.substring(0,3))\n        .peek(t -&gt; System.out.println(t))\n        .collect(Collectors.toList());\n\n</code></pre>\n<hr>\n<p><strong>重点:</strong> peek VS map</p>\n<blockquote>\n<p>peek 操作一般用于 不想改变流中元素本身的类型或者只想元素的内部状态改变时<br>\n map 则用于改变流中元素本身，即从元素中派生出另一种类型的操作</p>\n</blockquote>\n<hr>\n<h5 id=\"maptoint-maptolong-maptodouble-flatmaptodouble-flatmaptoint-flatmaptolong\"><a class=\"markdownIt-Anchor\" href=\"#maptoint-maptolong-maptodouble-flatmaptodouble-flatmaptoint-flatmaptolong\">#</a> mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong</h5>\n<blockquote>\n<p>以上操作是 map 和 flatMap 的特别版，也就是针对特定的数据类型进行映射处理</p>\n<p>其对应方法如下：</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nIntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);\n \nLongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper); \n \nDoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);\n \nIntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);\n \nLongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);\n \nDoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);\n\n</code></pre>\n<hr>\n<h4 id=\"有状态stateful操作\"><a class=\"markdownIt-Anchor\" href=\"#有状态stateful操作\">#</a> 有状态 (Stateful) 操作</h4>\n<h5 id=\"distinct去除重复的元素\"><a class=\"markdownIt-Anchor\" href=\"#distinct去除重复的元素\">#</a> distinct: 去除重复的元素</h5>\n<blockquote>\n<p>distinct () 方法可以用来去除流中的重复元素，生成无重复的列表<br>\n需要注意的是：distinct 用于针对流元素去重操作时，需要确定流中的元素实现了 equals () 和 hasCode () 方法</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;String&gt; numbers = Arrays.asList(&quot;13378520000&quot;, &quot;15138510000&quot;,&quot;13178520000&quot;, &quot;15138510000&quot;);\nList&lt;String&gt; disNumbers = numbers.stream().distinct().collect(Collectors.toList());\nSystem.out.println(disNumbers);\t\t\n\n\n打印结果：[13378520000, 15138510000, 13178520000]\n\n</code></pre>\n<hr>\n<h5 id=\"15-sorted排序元素\"><a class=\"markdownIt-Anchor\" href=\"#15-sorted排序元素\">#</a> 1.5 sorted: 排序元素</h5>\n<blockquote>\n<p>sorted 方法用于对流中元素进行排序</p>\n</blockquote>\n<p>1.5.1 升序排序</p>\n<pre><code class=\"language-Java\">\nList&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,20),\n        new People(&quot;李二&quot;,30),\n        new People(&quot;张四&quot;,31)\n);\nList&lt;People&gt; newpeopleList=peopleList.stream().sorted(Comparator.comparing(People::getAge)).collect(Collectors.toList());\n//打印结果\nnewpeopleList.stream().forEach(System.out::println);\n\n\n打印结果：\nPeople&#123;name='王二', age=20&#125;\nPeople&#123;name='李二', age=30&#125;\nPeople&#123;name='张四', age=31&#125;\n\n</code></pre>\n<p>1.5.2 降序排序</p>\n<blockquote>\n<p>通过 reversed () 方法进行逆序排序</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nList&lt;People&gt; peopleList = Arrays.asList(\n        new People(&quot;王二&quot;,20),\n        new People(&quot;李二&quot;,30),\n        new People(&quot;张四&quot;,31)\n);\nList&lt;People&gt; newpeopleList = peopleList.stream().sorted(Comparator.comparing(People::getAge).reversed()).collect(Collectors.toList());\n//打印结果\nnewpeopleList.stream().forEach(System.out::println);\n\n打印结果：\nPeople&#123;name='张四', age=31&#125;\nPeople&#123;name='李二', age=30&#125;\nPeople&#123;name='王二', age=20&#125;\n\n</code></pre>\n<hr>\n<h5 id=\"17-limit和skip截取流中的部分元素\"><a class=\"markdownIt-Anchor\" href=\"#17-limit和skip截取流中的部分元素\">#</a> 1.7 limit 和 skip: 截取流中的部分元素</h5>\n<blockquote>\n<p>limit 返回一个包含前 n 个元素的新流<br>\n skip 返回一个丢弃前 n 个元素后剩余元素组成的新流</p>\n</blockquote>\n<pre><code class=\"language-Java\">\nint[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;\nSystem.out.print(&quot;取数组前5个元素:&quot;);\nArrays.stream(arr).limit(5).forEach(n -&gt; System.out.print(n + &quot; &quot;)); // 输出结果为：1 2 3 4 5\n\nSystem.out.print(&quot;跳过前3个元素，取剩余数组元素:&quot;);\nArrays.stream(arr).skip(3).forEach(n -&gt; System.out.print(n + &quot; &quot;)); // 输出结果为：4 5 6 7 8 9 10\n\n</code></pre>\n<hr>\n<h3 id=\"终结操作terminal-operation\"><a class=\"markdownIt-Anchor\" href=\"#终结操作terminal-operation\">#</a> 终结操作 (Terminal Operation)</h3>\n<h4 id=\"短路short-circuiting操作\"><a class=\"markdownIt-Anchor\" href=\"#短路short-circuiting操作\">#</a> 短路 (Short-circuiting) 操作</h4>\n<ul>\n<li>anyMatch: Stream 中只要有一个元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean anyMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>allMatch: Stream 中全部元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean allMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>noneMatch: Stream 中没有一个元素符合传入的 predicate, 返回 true</li>\n</ul>\n<blockquote>\n<p>boolean noneMatch(Predicate&lt;? super T&gt; predicate);</p>\n</blockquote>\n<ul>\n<li>findFirst: 用于返回满足条件的第一个元素 (凡是该元素是封装在 Optional 类中)</li>\n</ul>\n<blockquote>\n<p>Optional<T> findFirst();</p>\n</blockquote>\n<ul>\n<li>findAny: 返回流中的任意元素 (但是该元素也是封装在 Optional 类中)</li>\n</ul>\n<blockquote>\n<p>Optional<T> findAny();</p>\n</blockquote>\n<hr>\n<h4 id=\"非短路操作\"><a class=\"markdownIt-Anchor\" href=\"#非短路操作\">#</a> 非短路操作</h4>\n<h5 id=\"foreach\"><a class=\"markdownIt-Anchor\" href=\"#foreach\">#</a> forEach()</h5>\n<p>该方法接收一个 lambda 表达式，然后在 Stream 的每一个元素上执行该表达式</p>\n<blockquote>\n<p>void forEach(Consumer&lt;? super T&gt; action);</p>\n</blockquote>\n<hr>\n<h5 id=\"foreachordered\"><a class=\"markdownIt-Anchor\" href=\"#foreachordered\">#</a> forEachOrdered()</h5>\n<p>该方法接收一个 Lambda 表达式，然后按顺序在 Stream 中的每一个元素上执行该表达式</p>\n<blockquote>\n<p>void forEachOrdered(Consumer&lt;? super T&gt; action);</p>\n</blockquote>\n<p>该功能其实和 forEach 是很相似的，也是循环操作！那唯一的区别，就在于 forEachOrdered 是可以保证循环时元素是按原来的顺序逐个循环的！</p>\n<hr>\n<h5 id=\"toarray\"><a class=\"markdownIt-Anchor\" href=\"#toarray\">#</a> toArray()</h5>\n<p>返回包含此流元素的数组，当有参数时，</p>\n<blockquote>\n<p>Object [] toArray();</p>\n</blockquote>\n<blockquote>\n<p><A> A[] toArray(IntFunction&lt;A[]&gt; generator);</p>\n</blockquote>\n<p>举例：</p>\n<pre><code class=\"language-Java\">\n\nList&lt;String&gt; strList = Arrays.asList( &quot;Jhonny&quot;, &quot;David&quot;, &quot;Jack&quot;, &quot;Duke&quot;, &quot;Jill&quot;,&quot;Dany&quot;,&quot;Julia&quot;,&quot;Jenish&quot;,&quot;Divya&quot;);\n \nObject [] strAryNoArg = strList.stream().toArray();\nString [] strAry = strList.stream().toArray(String[]::new);\n\n</code></pre>\n",
            "tags": [
                "Java8"
            ]
        }
    ]
}