<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://1405904364.github.io</id>
    <title>Live My Life • Posts by &#34;java8&#34; tag</title>
    <link href="http://1405904364.github.io" />
    <updated>2023-08-10T08:29:50.064Z</updated>
    <category term="Java" />
    <category term="Html" />
    <category term="Java8" />
    <category term="maven" />
    <entry>
        <id>http://1405904364.github.io/2023/08/10/Java/Stream%E6%B5%81/</id>
        <title>Stream流式编程</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/10/Java/Stream%E6%B5%81/"/>
        <content type="html">&lt;h1 id=&#34;stream流式编程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#stream流式编程&#34;&gt;#&lt;/a&gt; Stream 流式编程&lt;/h1&gt;
&lt;h2 id=&#34;分类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分类&#34;&gt;#&lt;/a&gt; 分类&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/Java/13170952_625693608975b29303.webp&#34; alt=&#34;分类图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中间操作&lt;/strong&gt;可分为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;无状态：指元素的处理不受之前元素的影响&lt;/li&gt;
&lt;li&gt;有状态：指该操作只有拿到所有元素之后才能继续下去&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;终结操作&lt;/strong&gt;可分为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;非短路操作：指必须处理所有元素才能得到最终结果&lt;/li&gt;
&lt;li&gt;短路操作：指遇到某些符合条件的元素就可以得到最终结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体操作如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/Java/20201218181011714.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;stream-api使用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#stream-api使用&#34;&gt;#&lt;/a&gt; Stream API 使用&lt;/h2&gt;
&lt;h3 id=&#34;流的构成&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#流的构成&#34;&gt;#&lt;/a&gt; 流的构成&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;使用流的时候，通常包括三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取一个数据源&lt;/li&gt;
&lt;li&gt;数据转换&lt;br&gt;
执行操作获取想要的结果，每次转换原有的 Stream 对象不变，返回一个新的 Stream 对象，这就允许对其操作可以像链条一样排列&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;流的创建&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#流的创建&#34;&gt;#&lt;/a&gt; 流的创建&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过 java.util.Collection.stream () 方法用集合创建流&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
  List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;hello&amp;quot;,&amp;quot;world&amp;quot;,&amp;quot;stream&amp;quot;);
  //创建顺序流
  Stream&amp;lt;String&amp;gt; stream = list.stream();
  //创建并行流
  Stream&amp;lt;String&amp;gt; parallelStream = list.parallelStream();

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 java.util.Arrays.stream (T [] array) 方法用数组创建流&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
  String[] array = &amp;#123;&amp;quot;h&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;o&amp;quot;&amp;#125;;
  Stream&amp;lt;String&amp;gt; arrayStream = Arrays.stream(array);

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stream 的静态方法：of ()、iterate ()、generate ()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
  Stream&amp;lt;Integer&amp;gt; stream1 = Stream.of(1, 2, 3, 4, 5, 6);
  
  Stream&amp;lt;Integer&amp;gt; stream2 = Stream.iterate(0, (x) -&amp;gt; x + 2).limit(3);
  
  Stream&amp;lt;Double&amp;gt; stream3 = Stream.generate(Math::random).limit(3);

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stream 和 parallelStream 的简单区分&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;stream 是顺序流，由主线程按顺序对流执行操作，而 parallelStream 是并行流，内部以多线程并行执行的方式对流进行操作，需要注意使用并行流的前提是流中的数据处理没有顺序要求（会乱序，即使用了 forEachOrdered）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;一-stream中间操作&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一-stream中间操作&#34;&gt;#&lt;/a&gt; 一、Stream 中间操作&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Stream流中间操作是指在流链当中，可以对数据进行处理操作，包括filter过滤、map映射转换、flatMap合并、distinct去重、sorted排序等操作，这些操作都会返回一个新的Stream流对象，可以通过链式调用多个中间操作进行复杂的数据处理。

需要注意的是，中间操作需要具有终止操作才会触发。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;无状态stateless操作&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#无状态stateless操作&#34;&gt;#&lt;/a&gt; 无状态 (Stateless) 操作&lt;/h4&gt;
&lt;h5 id=&#34;filter过滤出符合条件的元素&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#filter过滤出符合条件的元素&#34;&gt;#&lt;/a&gt; filter: 过滤出符合条件的元素&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;filter () 方法常用于实现数据过滤，即可以对集合、数组等数据源筛选出符合指定条件的元素，并返回一个新的流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// 将数组转换为一个字符串列表
List&amp;lt;String&amp;gt; numbers = Arrays.asList&amp;quot;13378520000&amp;quot;,&amp;quot;13278520000&amp;quot;,&amp;quot;13178520000&amp;quot;,&amp;quot;13358520000&amp;quot;);
// 通过stream()方法创建一个流，接着使用filter方法过滤出前缀为&amp;quot;133&amp;quot;的元素，最终通过collect()方法将结果收集到一个新的列表中
List&amp;lt;String&amp;gt; filterNumbers = numbers.stream().filter(s -&amp;gt; s.startWith(&amp;quot;133&amp;quot;)).collect(Collectors.toList());
System.out.println(filterNumbers);

打印结果：[13378520000, 13358520000]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h5 id=&#34;map映射转换元素&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#map映射转换元素&#34;&gt;#&lt;/a&gt; map: 映射转换元素&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;map 方法用于对流中的每个元素进行映射操作，将其转换为另一个元素或者提取其中的信息，并返回一个新的流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.1 转换元素&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取每个手机号的前七位子字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;List&amp;lt;String&amp;gt; numbers = Arrays.asList(&amp;quot;13378520000&amp;quot;,&amp;quot;13278520000&amp;quot;,&amp;quot;13178520000&amp;quot;,&amp;quot;13558520000&amp;quot;);
//通过stream()方法创建一个流，使用map()方法将每个字符串转换为截取前7位的字符，最后使用collect()方法将结果收集到一个新列表中
List&amp;lt;String&amp;gt; filterdNumbers = numbers.stream().map(s -&amp;gt; s.substring(0,7)).collect(Collectors.toList());
System.out.println(filterdNumbers);


打印结果：[1337852, 1327852, 1317852, 1355852]

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;1.2.2 提取元素信息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取每个对象的手机号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;List&amp;lt;People&amp;gt; peopleList = Arrays.asList(
        new People(&amp;quot;王二&amp;quot;,&amp;quot;13378520000&amp;quot;),
        new People(&amp;quot;李二&amp;quot;,&amp;quot;13278520000&amp;quot;),
        new People(&amp;quot;张四&amp;quot;,&amp;quot;13178520000&amp;quot;)
);
//通过stream()方法创建一个流，使用map()方法提取每个用户的手机号，最后使用collect()方法将结果收集到一个新列表中
List&amp;lt;String&amp;gt; tel = peopleList.stream().map(People::getTel).collect(Collectors.toList());
System.out.println(tel);


打印结果：[13378520000, 13278520000, 13178520000]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h5 id=&#34;flatmap将多个流合并为一个流&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#flatmap将多个流合并为一个流&#34;&gt;#&lt;/a&gt; flatMap: 将多个流合并为一个流&lt;/h5&gt;
&lt;p&gt;1.3.1 实现多对多的映射&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将 A 组数据和 B 组数据一次进行相加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
List&amp;lt;Integer&amp;gt; listA = Arrays.asList(1,2,3);
List&amp;lt;Integer&amp;gt; listB = Arrays.asList(4, 5, 6);
List&amp;lt;Integer&amp;gt; list = listA.stream().flatMap(a -&amp;gt; listB.stream().map(b -&amp;gt; a +b)).collect(Collectors.toList());
System.out.println(list);


打印结果:  [5, 6, 7, 6, 7, 8, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;1.3.2 将多个列表合并成一个列表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; listOfLists = Arrays.asList(
        Arrays.asList(&amp;quot;13378520000&amp;quot;, &amp;quot;13278520000&amp;quot;),
        Arrays.asList(&amp;quot;13178520000&amp;quot;, &amp;quot;13558520000&amp;quot;),
        Arrays.asList(&amp;quot;15138510000&amp;quot;, &amp;quot;15228310000&amp;quot;)
);
List&amp;lt;String&amp;gt; flatMapList = listOfLists.stream().flatMap(Collection::stream).collect(Collectors.toList());
System.out.println(flatMapList);


打印结果：[13378520000, 13278520000, 13178520000, 13558520000, 15138510000, 15228310000]

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h5 id=&#34;peek查看每个元素的信息但不改变流中元素的状态&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#peek查看每个元素的信息但不改变流中元素的状态&#34;&gt;#&lt;/a&gt; peek: 查看每个元素的信息，但不改变流中元素的状态&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
List&amp;lt;String&amp;gt; telList = Arrays.asList(&amp;quot;13378520000&amp;quot;,&amp;quot;13278520000&amp;quot;,&amp;quot;13178520000&amp;quot;,&amp;quot;13558520000&amp;quot;);
telList.stream().peek(t -&amp;gt; System.out.println(t))
        .map(t -&amp;gt; t.substring(0,3))
        .peek(t -&amp;gt; System.out.println(t))
        .collect(Collectors.toList());

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;重点:&lt;/strong&gt; peek VS map&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;peek 操作一般用于 不想改变流中元素本身的类型或者只想元素的内部状态改变时&lt;br&gt;
 map 则用于改变流中元素本身，即从元素中派生出另一种类型的操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h5 id=&#34;maptoint-maptolong-maptodouble-flatmaptodouble-flatmaptoint-flatmaptolong&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#maptoint-maptolong-maptodouble-flatmaptodouble-flatmaptoint-flatmaptolong&#34;&gt;#&lt;/a&gt; mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;以上操作是 map 和 flatMap 的特别版，也就是针对特定的数据类型进行映射处理&lt;/p&gt;
&lt;p&gt;其对应方法如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
IntStream mapToInt(ToIntFunction&amp;lt;? super T&amp;gt; mapper);
 
LongStream mapToLong(ToLongFunction&amp;lt;? super T&amp;gt; mapper); 
 
DoubleStream mapToDouble(ToDoubleFunction&amp;lt;? super T&amp;gt; mapper);
 
IntStream flatMapToInt(Function&amp;lt;? super T, ? extends IntStream&amp;gt; mapper);
 
LongStream flatMapToLong(Function&amp;lt;? super T, ? extends LongStream&amp;gt; mapper);
 
DoubleStream flatMapToDouble(Function&amp;lt;? super T, ? extends DoubleStream&amp;gt; mapper);

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h4 id=&#34;有状态stateful操作&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#有状态stateful操作&#34;&gt;#&lt;/a&gt; 有状态 (Stateful) 操作&lt;/h4&gt;
&lt;h5 id=&#34;distinct去除重复的元素&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#distinct去除重复的元素&#34;&gt;#&lt;/a&gt; distinct: 去除重复的元素&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;distinct () 方法可以用来去除流中的重复元素，生成无重复的列表&lt;br&gt;
需要注意的是：distinct 用于针对流元素去重操作时，需要确定流中的元素实现了 equals () 和 hasCode () 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
List&amp;lt;String&amp;gt; numbers = Arrays.asList(&amp;quot;13378520000&amp;quot;, &amp;quot;15138510000&amp;quot;,&amp;quot;13178520000&amp;quot;, &amp;quot;15138510000&amp;quot;);
List&amp;lt;String&amp;gt; disNumbers = numbers.stream().distinct().collect(Collectors.toList());
System.out.println(disNumbers);		


打印结果：[13378520000, 15138510000, 13178520000]

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h5 id=&#34;15-sorted排序元素&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#15-sorted排序元素&#34;&gt;#&lt;/a&gt; 1.5 sorted: 排序元素&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;sorted 方法用于对流中元素进行排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.5.1 升序排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
List&amp;lt;People&amp;gt; peopleList = Arrays.asList(
        new People(&amp;quot;王二&amp;quot;,20),
        new People(&amp;quot;李二&amp;quot;,30),
        new People(&amp;quot;张四&amp;quot;,31)
);
List&amp;lt;People&amp;gt; newpeopleList=peopleList.stream().sorted(Comparator.comparing(People::getAge)).collect(Collectors.toList());
//打印结果
newpeopleList.stream().forEach(System.out::println);


打印结果：
People&amp;#123;name=&#39;王二&#39;, age=20&amp;#125;
People&amp;#123;name=&#39;李二&#39;, age=30&amp;#125;
People&amp;#123;name=&#39;张四&#39;, age=31&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.5.2 降序排序&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过 reversed () 方法进行逆序排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
List&amp;lt;People&amp;gt; peopleList = Arrays.asList(
        new People(&amp;quot;王二&amp;quot;,20),
        new People(&amp;quot;李二&amp;quot;,30),
        new People(&amp;quot;张四&amp;quot;,31)
);
List&amp;lt;People&amp;gt; newpeopleList = peopleList.stream().sorted(Comparator.comparing(People::getAge).reversed()).collect(Collectors.toList());
//打印结果
newpeopleList.stream().forEach(System.out::println);

打印结果：
People&amp;#123;name=&#39;张四&#39;, age=31&amp;#125;
People&amp;#123;name=&#39;李二&#39;, age=30&amp;#125;
People&amp;#123;name=&#39;王二&#39;, age=20&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h5 id=&#34;17-limit和skip截取流中的部分元素&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#17-limit和skip截取流中的部分元素&#34;&gt;#&lt;/a&gt; 1.7 limit 和 skip: 截取流中的部分元素&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;limit 返回一个包含前 n 个元素的新流&lt;br&gt;
 skip 返回一个丢弃前 n 个元素后剩余元素组成的新流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
int[] arr = &amp;#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&amp;#125;;
System.out.print(&amp;quot;取数组前5个元素:&amp;quot;);
Arrays.stream(arr).limit(5).forEach(n -&amp;gt; System.out.print(n + &amp;quot; &amp;quot;)); // 输出结果为：1 2 3 4 5

System.out.print(&amp;quot;跳过前3个元素，取剩余数组元素:&amp;quot;);
Arrays.stream(arr).skip(3).forEach(n -&amp;gt; System.out.print(n + &amp;quot; &amp;quot;)); // 输出结果为：4 5 6 7 8 9 10

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;终结操作terminal-operation&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#终结操作terminal-operation&#34;&gt;#&lt;/a&gt; 终结操作 (Terminal Operation)&lt;/h3&gt;
&lt;h4 id=&#34;短路short-circuiting操作&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#短路short-circuiting操作&#34;&gt;#&lt;/a&gt; 短路 (Short-circuiting) 操作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;anyMatch: Stream 中只要有一个元素符合传入的 predicate, 返回 true&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;boolean anyMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;allMatch: Stream 中全部元素符合传入的 predicate, 返回 true&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;boolean allMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;noneMatch: Stream 中没有一个元素符合传入的 predicate, 返回 true&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;boolean noneMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;findFirst: 用于返回满足条件的第一个元素 (凡是该元素是封装在 Optional 类中)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Optional&lt;T&gt; findFirst();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;findAny: 返回流中的任意元素 (但是该元素也是封装在 Optional 类中)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Optional&lt;T&gt; findAny();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&#34;非短路操作&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#非短路操作&#34;&gt;#&lt;/a&gt; 非短路操作&lt;/h4&gt;
&lt;h5 id=&#34;foreach&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#foreach&#34;&gt;#&lt;/a&gt; forEach()&lt;/h5&gt;
&lt;p&gt;该方法接收一个 lambda 表达式，然后在 Stream 的每一个元素上执行该表达式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;void forEach(Consumer&amp;lt;? super T&amp;gt; action);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h5 id=&#34;foreachordered&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#foreachordered&#34;&gt;#&lt;/a&gt; forEachOrdered()&lt;/h5&gt;
&lt;p&gt;该方法接收一个 Lambda 表达式，然后按顺序在 Stream 中的每一个元素上执行该表达式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;void forEachOrdered(Consumer&amp;lt;? super T&amp;gt; action);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该功能其实和 forEach 是很相似的，也是循环操作！那唯一的区别，就在于 forEachOrdered 是可以保证循环时元素是按原来的顺序逐个循环的！&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&#34;toarray&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#toarray&#34;&gt;#&lt;/a&gt; toArray()&lt;/h5&gt;
&lt;p&gt;返回包含此流元素的数组，当有参数时，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Object [] toArray();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;A&gt; A[] toArray(IntFunction&amp;lt;A[]&amp;gt; generator);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;

List&amp;lt;String&amp;gt; strList = Arrays.asList( &amp;quot;Jhonny&amp;quot;, &amp;quot;David&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Duke&amp;quot;, &amp;quot;Jill&amp;quot;,&amp;quot;Dany&amp;quot;,&amp;quot;Julia&amp;quot;,&amp;quot;Jenish&amp;quot;,&amp;quot;Divya&amp;quot;);
 
Object [] strAryNoArg = strList.stream().toArray();
String [] strAry = strList.stream().toArray(String[]::new);

&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Java8" />
        <updated>2023-08-10T08:29:50.064Z</updated>
    </entry>
</feed>
