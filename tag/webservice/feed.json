{
    "version": "https://jsonfeed.org/version/1",
    "title": "Live My Life • All posts by \"webservice\" tag",
    "description": "个人学习使用",
    "home_page_url": "http://1405904364.github.io",
    "items": [
        {
            "id": "http://1405904364.github.io/2023/08/30/webService/webService%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "http://1405904364.github.io/2023/08/30/webService/webService%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "webService的使用",
            "date_published": "2023-08-30T08:50:18.092Z",
            "content_html": "<h1 id=\"什么是webservice\"><a class=\"markdownIt-Anchor\" href=\"#什么是webservice\">#</a> 什么是 webService</h1>\n<blockquote>\n<p>webService 也称为 web 服务，它是一种跨编程语言和操作系统平台的远程调用技术。<br>\nWebService 采用标准的 SOAP 协议传输 (SOAP Simple Object Access Protocol 简单对象访问协议)，soap 属于 w3c 标准，并且 soap 协议是基于 http 的应用层协议传输 xml 数据。WebService 采用 WSDL 作为描述语言，也就是 WebService 的使用说明书。并且 W3C 为 WebService 制定了一套传输数据类型，使用 xml 进行描述，即 XSD (XML Schema Datatypes), 任何语言写的 webService 接口在发送数据的时候都要转成 webService 标准的 XSD 发送。</p>\n</blockquote>\n<h1 id=\"webservice的三要素\"><a class=\"markdownIt-Anchor\" href=\"#webservice的三要素\">#</a> WebService 的三要素</h1>\n<h2 id=\"soap\"><a class=\"markdownIt-Anchor\" href=\"#soap\">#</a> SOAP</h2>\n<blockquote>\n<p>SOAP 也叫做简单对象访问协议，是一种简单的基于 xml 的协议，它使应用程序通过 HTTP 来交换数据，可以简单的理解为 SOAP = http + xml 。 SOAP 协议目前的主流版本为 SOAP1.1 和 SOAP1.2（SOAP1.2 是被纳入 w3c 标准后的版本）。SOAP 也不是 WebService 的专有协议，其他的应用程序也是用 SOAP 传输数据，例如：tr069 也是使用 SOAP 协议来传输数据</p>\n</blockquote>\n<p>区分 http 请求和 SOAP (http + xml) 请求:<br>\n<img data-src=\"/image/webService/20180320112817939.png\" alt=\"图片\"></p>\n<p>SOAP 协议格式</p>\n<ol>\n<li>必须有 Envelope 元素，此元素将整个 xml 文档表示为一条 SOAP 消息。</li>\n<li>可选 Header 元素，包含头部信息。</li>\n<li>必须有 Body 元素，包含所有的调用和响应信息。</li>\n<li>可选的 Fault 元素，提供有关在处理此消息所发生的错误信息。</li>\n</ol>\n<p>SOAP1.1 和 SOAP1.2 的区别</p>\n<p>相同点：<br>\n1. 请求方式都是采用 POST 方式<br>\n 2. 协议内容相同，都有 Envelope 和 Body 标签</p>\n<p>不同点：<br>\n1. 数据格式不同：content-type 不同<br>\n - SOAP1.1:text/xml;charset=utf-8<br>\n- SOAP1.2:application/soap+xml;charset=utf-8<br>\n2. 命名空间不同<br>\n - SOAP1.1：<span class=\"exturl\" data-url=\"aHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvc29hcC9lbnZlbG9wZS8=\">http://schemas.xmlsoap.org/soap/envelope/</span><br>\n- SOAP1.2：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53My5vcmcvMjAwMy8wNS9zb2FwLWVudmVsb3Bl\">http://www.w3.org/2003/05/soap-envelope</span></p>\n<h2 id=\"wsdl\"><a class=\"markdownIt-Anchor\" href=\"#wsdl\">#</a> WSDL</h2>\n<blockquote>\n<p>WSDL 是基于 XML 的用于描述 WebService 及其函数（方法）、参数和返回值。也就是说 wsdl 是对发布出来的服务中的方法和返回值以及参数的描述（也可以说是 WebService 的使用说明书）</p>\n</blockquote>\n<p>WSDL 文档结构：</p>\n<p>WSDL 文档主要包括的 5 个标签</p>\n<ol>\n<li><service>: 服务视图，WebService 的服务节点，它包括服务端点</li>\n<li><binding>: 为每个服务端点定义消息格式和协议细节</li>\n<li><portType>: 服务端点，描述 WebService 可执行的操作方法，以及相关消息，通过 binging 指向 protType</li>\n<li><message>: 定义一个操作（方法）的数据参数（可有多个参数）</li>\n<li><types>: 定义 WebService 使用的全部数据类型</li>\n</ol>\n<h2 id=\"uddi\"><a class=\"markdownIt-Anchor\" href=\"#uddi\">#</a> UDDI</h2>\n<blockquote>\n<p>UDDI 是一种目录服务，通过它，企业可注册并搜集 Web Service。企业将自己提供的 Web Service 注册在 UDDI，也可以使用别的企业在 UDDI 注册 Web Service 服务，从而达到资源共享。UDDI 旨在将全球的 Web Service 资源进行共享</p>\n</blockquote>\n<h2 id=\"webservice开发规范\"><a class=\"markdownIt-Anchor\" href=\"#webservice开发规范\">#</a> WebService 开发规范</h2>\n<h3 id=\"jax-ws\"><a class=\"markdownIt-Anchor\" href=\"#jax-ws\">#</a> JAX-WS</h3>\n<blockquote>\n<p>JAX-WS (Java API for XML-Based Web Service): 一个远程调用可以转换基于 XML 协议 (例如：SOAP 协议), 在使用 JAX-WS 过程中，开发者不需要使用任何代码来编写生成和处理 SAOP。JAX-WS 运行时会自动将这些 API 调用转换为 SOAP 协议的消息。</p>\n</blockquote>\n<blockquote>\n<p>在服务端，用户只需要通过 JAVA 语言定义远程调用所需要实现的接口 (SEI: Service EndPoit Interface), 并对其提供相关的实现，通过调用 JAX-WS 的服务来调用接口，这样就可以发布 Web Service 接口了</p>\n</blockquote>\n<blockquote>\n<p>在客户端，用户可以通过 JAX-WS 的 API 创建一个代理来（用本地代理对象替代远程的服务对象）实现远程服务端调用。</p>\n</blockquote>\n<p>从 Java5 开始就支持 JAX-WS2.0 版本，Java6 以后的版本支持 JAX-WS2.1 版本，Java1.7 支持 JAX-WS2.2 的版本。</p>\n<h3 id=\"jaxmsaaj\"><a class=\"markdownIt-Anchor\" href=\"#jaxmsaaj\">#</a> JAXM&amp;SAAJ</h3>\n<blockquote>\n<p>JAXM（Java API for XML Message）：主要定义了包含接收信息和发送信息所需要的 API，SAAJ (SOAP With Attachment API For Java) 是与 JAXM 搭配使用的 API，为构建 SOAP 和解析 SOAP 包提供了重要的支持，支持附件传输等。</p>\n</blockquote>\n<h3 id=\"jax-rs\"><a class=\"markdownIt-Anchor\" href=\"#jax-rs\">#</a> JAX-RS</h3>\n<blockquote>\n<p>JAX-RS 是 Java 针对 REST（Representtation state Transfer）风格制定的一套 Web 服务规范，由于该规范推出来的较晚，因此该规范（JAX-WS 的版本为 1.0）并未随 Java6 一起发行。</p>\n</blockquote>\n<h2 id=\"webservice应用场景\"><a class=\"markdownIt-Anchor\" href=\"#webservice应用场景\">#</a> WebService 应用场景</h2>\n<p>适用场景：<br>\n1. 用于软件集成和复用<br>\n 2. 用于接口服务，不考虑客户端类型，不考虑性能<br>\n 3. 服务端已经确定使用了 WebService，客户端只能选择 WebService 使用</p>\n<p>不适用场景：<br>\n1. 对性能要求比较高 (因为 WebService 是采用 http 发送 soap 协议的数据，该协议迭代了太多标签，导致数据跟多，因此性能也有所降低)<br>\n 2. 同构程序之间不建议使用</p>\n<h2 id=\"wsimport命令介绍\"><a class=\"markdownIt-Anchor\" href=\"#wsimport命令介绍\">#</a> wsimport 命令介绍</h2>\n<blockquote>\n<p>wsimport 命令是 jdk 自带的 webService 客户端工具，可以根据 wsdl 文档生成对应服务代理类（客户端调用类），当然不管服务端用什么语言写的，都可以生成调用 WebService 的客户端代码，服务端通过客户端调用 WebService。</p>\n</blockquote>\n<p>wsimport 命令常用参数为：</p>\n<ul>\n<li>-d &lt;目录&gt;: 指定放置生成的输出文件的位置</li>\n<li>-s &lt;目录&gt;: 指定放置生成的源文件的位置</li>\n<li>-p &lt;包名&gt;: 指定目标程序包</li>\n</ul>\n<p>例如：在 com-&gt;test 文件夹中生成源文件</p>\n<blockquote>\n<p>wsimport -p com.test -s . <span class=\"exturl\" data-url=\"aHR0cDovL3dlYlNlcnZpY2Uud2VieG1sLmNvbS5jbi9XZWJTZXJ2aWNlL01vYmlsZUNPZGVXUy5hc214P3dzZGw=\">http://webService.webxml.com.cn/WebService/MobileCOdeWS.asmx?wsdl</span></p>\n</blockquote>\n<p>注意：-s .  表示在 -p 指定的文件夹下生成源文件</p>\n<h2 id=\"发布jax-ws的web-service服务\"><a class=\"markdownIt-Anchor\" href=\"#发布jax-ws的web-service服务\">#</a> 发布 JAX-WS 的 Web Service 服务</h2>\n<ol>\n<li>创建 SEI 接口 (本质上就是 Java 接口)</li>\n</ol>\n<pre><code class=\"language-Java\">public interface WeatherInterface &#123;\n    public String querryWeather(String cityName);\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>创建接口实现类</li>\n</ol>\n<blockquote>\n<ol>\n<li>\n<p>@WebService 注解：表示该实现类是一个 Web Service 服务。</p>\n<ul>\n<li>\n<p>targetNamespace 属性：指定命名空间。</p>\n</li>\n<li>\n<p>name 属性：指定 portType 的名称。</p>\n</li>\n<li>\n<p>serviceName 属性：服务名称。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>@WebMethod 注解：定义公共方法。</p>\n<ul>\n<li>\n<p>operationName 属性：方法的名称。（也就是 WSDL 中的 operation 的名称）</p>\n</li>\n<li>\n<p>exclude 属性：如果设置为 true 表示该方法不是 Web Service 服务中的方法。反之则是 WebService 中的方法。默认也是 &gt; false。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>@WebResult 注解：定义返回值。</p>\n<ul>\n<li>name 属性：返回结果值的名称</li>\n</ul>\n</li>\n<li>\n<p>@WebParam 注解：定义参数。</p>\n<ul>\n<li>name 属性：指定参数的名称</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"language-Java\">\n@WebService(targetNamespace=&quot;http://service.cn_lc&quot;,name=&quot;WeatherWSSoap&quot;,portName=&quot;WeatherWSSoapPort&quot;,serviceName=&quot;WeatherWS&quot;\n)//只加这个注解就只能生成SAOP1.1的WSDL\n//@BindingType(SOAPBinding.SOAP12HTTP_BINDING)\npublic class WeatherInterfaceImpl implements WeatherInterface &#123;\n    @WebMethod(operationName=&quot;getWeather&quot;,exclude=false)\n    @Override\n    @WebResult(name=&quot;resultWeather&quot;)\n    public  String querryWeather(@WebParam(name=&quot;cityName&quot;)String cityName) &#123;\n        System.out.println(&quot;form client ...&quot; + cityName);\n        String weather = &quot;晴&quot;;\n        return weather;\n    &#125;\n&#125;\n\n</code></pre>\n<ol start=\"3\">\n<li>通过 EndPoint 发布 WebService 服务 (EndPoint 只能发布实现类，不能发布接口)</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class WeatherServer &#123;\n    public static void main(String[] args) &#123;\n        /*** 参数解释：* address：服务器地址* implementor:实现类*/\n        Endpoint.publish(&quot;http://127.0.0.1:12345/weather&quot;,new WeatherInterfaceImpl());\n        System.out.println(&quot;http://127.0.0.1:12345/weather?wsdl&quot;);\n        &#125;\n&#125;\n\n</code></pre>\n<p><img data-src=\"/image/webService/20180320145116683.png\" alt=\"图片\"><br>\n<img data-src=\"/image/webService/20180320145359572.png\" alt=\"图片\"></p>\n<h2 id=\"webservice的四种客户端调用方式\"><a class=\"markdownIt-Anchor\" href=\"#webservice的四种客户端调用方式\">#</a> WebService 的四种客户端调用方式</h2>\n<p>第一种：通过 wsimport 生成客户端方式调用<br>\n 1. 通过 wsimport 生成客户端代码<br>\n wsimport -p com.test jaxws -s <span class=\"exturl\" data-url=\"aHR0cDovLzEyNy4wLjAuMToxMjM0NS93ZWF0aGVyP3dzZGw=\">http://127.0.0.1:12345/weather?wsdl</span><br>\n2. 阅读使用说明书 WSDL，使用生成客户端代码调用服务端</p>\n<pre><code class=\"language-Java\">\npublic class WeatherClient &#123;\n    public static void main(String[] args) &#123;\n        //创建服务视图\n        WeatherWS weatherInterfaceImplService = new WeatherWS();\n        //通过服务视图对象获取服务实现类\n        WeatherWSSoap weatherInterfaceImpl = weatherInterfaceImplService.getPort(WeatherWSSoap.class);\n        //通过服务实现对象调用查询方法\n        System.out.println(weatherInterfaceImpl.getWeather(&quot;北京&quot;));\n    &#125;\n&#125;\n\n</code></pre>\n<p>采用 wsimport 生成客户端代码方式的特点：这种方式使用简单，但是一些关键的元素 (比如 wsdl 地址、命名空间、服务类名等都写死在生成的客户端代码中) 不方便维护</p>\n<hr>\n<p>第二种：通过 Service 编程调用方式<br>\n 1. 通过 wsimport 生成客户端代码<br>\n wsimport -p com.test jaxws -s <span class=\"exturl\" data-url=\"aHR0cDovLzEyNy4wLjAuMToxMjM0NS93ZWF0aGVyP3dzZGw=\">http://127.0.0.1:12345/weather?wsdl</span><br>\n2. 自己编写服务视图类，并通过该服务视图类来获取服务实现类实例</p>\n<pre><code class=\"language-Java\">\npublic class WeatherClient &#123;\n    public static void main(String[] args) &#123;\n        //创建WSDL的URL，注意不是服务地址\n        URL url = new URL(&quot;http://127.0.0.1:12345/weather?wsdl&quot;);\n        // 创建服务名称//namespaceURI:命名空间地址。//localPart：服务视图名。\n        QName qname = new QName(&quot;http://service.cn_lc&quot;, &quot;WeatherWS&quot;);\n        //创建服务视图//1.wsdlDocumentLocation - wsdl地址//2.serviceName - 服务名称\n        Service service = Service.create(url, qname);\n        WeatherWSSoap weatherWSSoap = service.getPort(WeatherWSSoap.class);\n        String result = weatherWSSoap.getWeather(&quot;成都&quot;);\n        System.out.println(result);\n    &#125;\n&#125;\n\n</code></pre>\n<hr>\n<p>第三种：通过 HttpURLConnection 调用方式<br>\n 1. 创建服务地址<br>\n 2. 打开一个通向服务地址的连接<br>\n 3. 设置参数（例如请求方式为 POST）<br>\n4. 组织 SOAP 数据发送数据<br>\n 5. 接收服务端相应，并打印</p>\n<pre><code class=\"language-Java\">\npublic class WeatherClient &#123;\n    public static void main(String[] args) throws IOException &#123;\n        //第一步：创建服务地址\n        URL url = new URL(&quot;http://127.0.0.1:54321/weather&quot;);\n        // 第二步：打开一个通向服务端地址的连接\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        //设置参数\n        connection.setRequestMethod(&quot;POST&quot;);\n        connection.setRequestProperty(&quot;content-type&quot;, &quot;text/xml;charset=utf-8&quot;);\n        //设置输入输出\n        connection.setDoOutput(true);\n        connection.setDoInput(true);\n        //准备SOAP数据，发送请求\n        String soapxml = getXML(&quot;成都&quot;);\n        OutputStream out = connection.getOutputStream();\n        OutputStreamWriter writer = new OutputStreamWriter(out, &quot;utf-8&quot;);\n        writer.write(soapxml);\n        writer.close();\n        out.close();\n        //第五步接收服务端响应并打印\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) &#123;\n            InputStream input = connection.getInputStream();\n            InputStreamReader reader = new InputStreamReader(input, &quot;utf-8&quot;);\n            BufferedReader buffered = new BufferedReader(reader);\n            String temp = null;\n            StringBuilder sb = new StringBuilder();\n            while ((temp = buffered.readLine()) != null) &#123;\n                sb.append(temp);\n            &#125;\n            buffered.close();\n            reader.close();\n            input.close();\n            System.out.println(sb.toString());\n        &#125;\n    &#125;\n\n    public static String getXML(String cityName) &#123;\n        return &quot;&lt;?xml version=\\&quot;1.0\\&quot; ?&gt;&quot; + &quot;&lt;S:Envelope xmlns:S=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot;&gt;&quot; + &quot;&lt;S:Body&gt;&quot; + &quot;&lt;ns2:getWeather xmlns:ns2=\\&quot;http://service.cn_lc\\&quot;&gt;&quot; + &quot;&lt;cityName&gt;&quot; + cityName + &quot;&lt;/cityName&gt;&quot; + &quot;&lt;/ns2:getWeather&gt;&quot; + &quot;&lt;/S:Body&gt;&quot; + &quot;&lt;/S:Envelope&gt;&quot;;\n    &#125;\n&#125;\n\n</code></pre>\n<hr>\n<p>第四种：通过 ajax 方式调用服务端</p>\n<pre><code class=\"language-Html\">\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;title&gt;查询天气&lt;/title&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;function querryWeather() &#123;\n            var xhr = new XMLHttpRequest(); xhr.open(&quot;post&quot;, &quot;http://127.0.0.1:12345/weather&quot;, true);\n            //设置数据类型\n            xhr.setRequestHeader(&quot;content-type&quot;, &quot;text/xml;charset=utf-8&quot;);\n            //设置回调函数\n            if (4 == xhr.readState &amp;&amp; 200 == xhr.status) &#123;\n                alert(xhr.responseText);\n            &#125;\n            //组织数据\n            var soapXml = &quot;&lt;?xml version=\\&quot;1.0\\&quot; ?&gt;&quot; + &quot;&lt;S:Envelope xmlns:S=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot;&gt;&quot; + &quot;&lt;S:Body&gt;&quot; + &quot;&lt;ns2:getWeather xmlns:ns2=\\&quot;http://service.cn_lc\\&quot;&gt;&quot; + &quot;&lt;cityName&gt;&quot; + document.getElementById(&quot;cityName&quot;).value + &quot;&lt;/cityName&gt;&quot; + &quot;&lt;/ns2:getWeather&gt;&quot; + &quot;&lt;/S:Body&gt;&quot; + &quot;&lt;/S:Envelope&gt;&quot;; alert(soapXml);\n            //发送数据\n            xhr.send(soapXml);\n        &#125;\n    &lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;center&gt;天气查询：&lt;input type=&quot;text&quot; id=&quot;cityName&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;查询&quot;\n            οnclick=&quot;javascript:querryWeather();&quot; /&gt;&lt;/center&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"cxf\"><a class=\"markdownIt-Anchor\" href=\"#cxf\">#</a> CXF</h2>\n<blockquote>\n<p>CXF 是一个开源的 WebService 框架，提供了很多完善的功能<br>\n CXF 支持的协议有 SOAP1.1/SOAP1.2,REST<br>\nCXF 支持的数据格式有 XML，JSON (仅在 REST 方式下支持，不再 SOAP 方式下支持，因为 SOAP 使 http+xml)</p>\n</blockquote>\n",
            "tags": [
                "webService"
            ]
        }
    ]
}