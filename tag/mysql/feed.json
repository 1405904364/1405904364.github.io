{
    "version": "https://jsonfeed.org/version/1",
    "title": "Live My Life • All posts by \"mysql\" tag",
    "description": "个人学习使用",
    "home_page_url": "http://1405904364.github.io",
    "items": [
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/9.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/9.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql分组查询",
            "date_published": "2024-02-18T08:13:45.079Z",
            "content_html": "<h2 id=\"分组查询\"><a class=\"markdownIt-Anchor\" href=\"#分组查询\">#</a> 分组查询</h2>\n<h3 id=\"sql语句各个关键字的执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#sql语句各个关键字的执行顺序\">#</a> SQL 语句各个关键字的执行顺序</h3>\n<pre><code>select\n    ...         5\nfrom\n    ...         1\nwhere\n    ...         2\ngroup by\n    ...         3\nhaving\n    ...         4\norder by\n    ...         6\n</code></pre>\n<p>执行顺序：<br>\n1. from<br>\n2. where<br>\n3. group by<br>\n4. having<br>\n5. select<br>\n6. order by</p>\n<h3 id=\"重点结论\"><a class=\"markdownIt-Anchor\" href=\"#重点结论\">#</a> 重点结论</h3>\n<pre><code>在一条select语句当中，如果有group by语句的话，select后面只能跟分组函数，以及参加分组的字段。其他的一律不能跟。（Mysql可以执行，但没有意义，Oracle数据库当中会报错）\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/8.%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E8%A1%8C%E6%95%B0/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/8.%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E8%A1%8C%E6%95%B0/",
            "title": "Mysql多行处理行数",
            "date_published": "2024-02-18T08:13:45.071Z",
            "content_html": "<h2 id=\"多行处理行数分组函数\"><a class=\"markdownIt-Anchor\" href=\"#多行处理行数分组函数\">#</a> 多行处理行数（分组函数）</h2>\n<p>特点：输入多行、最终输出一行</p>\n<h4 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意：</h4>\n<pre><code>分组函数在使用时必须先进行分组，然后才能使用。\n如果你没有对数据进行分组，整张表默认为一组\n</code></pre>\n<h3 id=\"count-计数\"><a class=\"markdownIt-Anchor\" href=\"#count-计数\">#</a> count 计数</h3>\n<p>计算员工数量总和<br>\n select count (name) from emp;</p>\n<h3 id=\"sum-求和\"><a class=\"markdownIt-Anchor\" href=\"#sum-求和\">#</a> sum 求和</h3>\n<p>计算工资合<br>\n select sum (sal) from emp;</p>\n<h3 id=\"avg-平均值\"><a class=\"markdownIt-Anchor\" href=\"#avg-平均值\">#</a> avg 平均值</h3>\n<p>计算平均工资<br>\n select avg (sal) from emp;</p>\n<h3 id=\"max-最大值\"><a class=\"markdownIt-Anchor\" href=\"#max-最大值\">#</a> max 最大值</h3>\n<p>找出最高工资<br>\n select max (sal) from emp;</p>\n<h3 id=\"min-最小值\"><a class=\"markdownIt-Anchor\" href=\"#min-最小值\">#</a> min 最小值</h3>\n<p>找出最低工资<br>\n select min (sal) from emp;</p>\n<h2 id=\"分组函数使用时需要注意的地方\"><a class=\"markdownIt-Anchor\" href=\"#分组函数使用时需要注意的地方\">#</a> 分组函数使用时，需要注意的地方</h2>\n<pre><code>1. 分组函数自动忽略 NULL, 不需要提前处理。\n 例如：求所有员工津贴/补助的总和。\n    select sum(comm) from emp;//不需要加where comm is not null条件。\n2. 分组函数count(*) 和 count(具体字段)的区别。\n   1. count(具体字段)：表示统计该字段下所有不为 NULL 的元素的总数。\n   2. count(*)：统计表中所有行数。\n3. 分组函数不能直接用在where子句中。\n 例如：找出比最低工资高的员工信息。\n select ename, sal from emp where sal &gt; min(sal);// 错误SQL语句\n4. 所有分组函数可以组合起来一起使用。\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/7.%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/7.%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/",
            "title": "Mysql单行处理函数",
            "date_published": "2024-02-18T08:13:45.062Z",
            "content_html": "<p>单行处理函数也叫做数据处理函数</p>\n<p>单行处理函数的特点：</p>\n<p>​\t一个输入对应一个输出</p>\n<p>和单行处理函数相对的是：</p>\n<p>​\t多行处理函数（特点：多个输入，对应一个输出）</p>\n<p>常见的单行处理函数</p>\n<ol>\n<li>\n<p>lower 转换小写</p>\n<p>select  lower(name)  from city;</p>\n</li>\n<li>\n<p>upper 转换大写</p>\n<p>select  upper(name)  from city;</p>\n</li>\n<li>\n<p>substr 取子串</p>\n<p>substr (被截取的字符串，起始下标，截取的长度)// 注意起始下标从 1 开始，没有 0</p>\n<p>select  substr(name, 1, length(name))  from city;</p>\n</li>\n<li>\n<p>concat 进行字符串拼接</p>\n<p>select concat(name, countrycode) from city;</p>\n</li>\n<li>\n<p>length 取长度</p>\n<p>select length(name) from city;</p>\n</li>\n<li>\n<p>trim 去除空格</p>\n<p>select * from city where name = trim (’   King   ');// 将查询条件中的前后空格去除</p>\n</li>\n<li>\n<p>round 四舍五入</p>\n<p>select 字段 from 表名；</p>\n<p>select name from city;</p>\n<p>select ‘abc’ from city;//select 后面直接跟 “字面量”/“字面值”</p>\n<p><strong>结论：select 后面可以跟某个表的字段名（可以等同看作变量名），也可以跟字面量 / 字面值（数据）</strong></p>\n<p>例如：</p>\n<p>select round (1276.567, 2) from city;// 保留二位小数 1276.57</p>\n<p>select round (1276.567, 1) from city;// 保留一位小数 1276.6</p>\n<p>select round (1276.567, 0) from city;// 保留整数 1277</p>\n<p>select round (1276.567, -1) from city;// 保留到十位 1270</p>\n<p>select round (1276.567, -2) from city;// 保留到百位 1280</p>\n</li>\n<li>\n<p>rand 生成随机数</p>\n<p>select rand() from city;</p>\n<p>例如：生成 100 以内的随机数</p>\n<p>select round(rand() * 100, 0) from city;</p>\n</li>\n<li>\n<p>ifnull 可以将 null 转换成一个具体值。</p>\n<p>ifnull 是空处理函数。专门处理空的。（因为在所有数据库中，只要有 null 参与的数学运算，最终结果都为 null）</p>\n<p>ifnull 函数语法：ifnull (数据，被当作那个值)</p>\n<p>如果 “数据” 为 null 的时候，把这个数据当作那个值</p>\n</li>\n<li>\n<p>case when … then … when … then … else … end</p>\n<p>例如：当员工的岗位为 MANAGER 的时候，工资上调 %10，当工作岗位是 SALESMAN 的时候，工资上调 %50，其他正常。</p>\n<p>（注意：不修改数据库，只是将查询结果显示为工资上调）</p>\n<p>select</p>\n<p>ename,</p>\n<p>job,</p>\n<p>sal as oldsal,</p>\n<p>(case when ‘MANAGER’ then sal*1.1 when ‘SALESMAN’ then sal**1.5 else sal end) as newsal</p>\n<p>from emp;</p>\n</li>\n<li>\n<p>format 数字格式化<br>\n format (数字，‘格式’)</p>\n<p>select ename, (sal, ‘$999,999’) from emp;</p>\n</li>\n<li>\n<p>str_to_date</p>\n<p>字符串转换为 date 类型</p>\n<p>str_to_date (‘日期字符串’, ‘日期格式’)</p>\n<p>Mysql 中日期格式：<br>\n% Y 年<br>\n % m 月<br>\n % d 日<br>\n % h 时<br>\n % i 分<br>\n % s 秒</p>\n<p>Java 中日期格式：<br>\nyyyy-MM-dd HH:mm:ss SSS</p>\n</li>\n<li>\n<p>date_format</p>\n</li>\n</ol>\n<p>从 date 类型转换为具有一定格式的字符串类型</p>\n<p>date_format (日期值，‘日期格式’)</p>\n<p>insert into test values(1, ‘zhangsan’, str_to_date(‘10:13:20 11-11-1999’, ‘%h:%i:%s %d-%m-%Y’));</p>\n<p>insert into test values (1, ‘zhangsan’, str_to_date (‘11-1999’, ‘% m-% Y’));//date 类型为年月日，插入的值不完整，所以报错</p>\n<p>insert into test values(1, ‘zhangsan’, str_to_date(‘11-1999’, ‘11-%m-%Y’));</p>\n<p>insert into test values(1, ‘zhangsan’, str_to_date(‘10-11-1999’, ‘10-%m-%Y’));</p>\n<p>insert into test values (1, ‘zhangsan’, str_to_date (‘10-11-1999’, ‘% d-% m-% Y’));// 正确</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/6.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/6.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/",
            "title": "Mysql综合案例",
            "date_published": "2024-02-18T08:13:45.062Z",
            "content_html": "<ol>\n<li>\n<p>找出工资在 1250 到 3000 之间的员工信息，要求按照薪资降序排列。</p>\n<p>select ename, sal</p>\n<p>​\tfrom emp</p>\n<p>​\twhere sal between 1250 and 3000</p>\n<p>order by sal desc;</p>\n</li>\n</ol>\n<p>以上语句的执行顺序：</p>\n<ol>\n<li>from</li>\n<li>where</li>\n<li>select</li>\n<li>order by (排序总是在最后执行的！！！)</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/",
            "title": "简单的查询语句",
            "date_published": "2024-02-18T08:13:45.054Z",
            "content_html": "<ol>\n<li>\n<p>查询一个字段</p>\n<p>select 字段名 from 表名；</p>\n<p>其中要注意：</p>\n<p>​\tselect 和 from 都是关键字。</p>\n<p>​\t字段名和表名都是标识符。</p>\n<p><strong>强调：对于 SQL 语句来说，是通用的。所有的 SQL 语句以 &quot;;&quot; 结尾。另外 SQL 语句不区分大小写，都行。</strong></p>\n</li>\n<li>\n<p>查询多个字段</p>\n<p>使用逗号隔开 &quot;,&quot;</p>\n<p>select deptno,dname from dept;</p>\n</li>\n<li>\n<p>查询所有字段</p>\n<ol>\n<li>\n<p>可以把每个字段都写上</p>\n</li>\n<li>\n<p>可以使用 *</p>\n<ol>\n<li>\n<p>效率低</p>\n</li>\n<li>\n<p>可读性差</p>\n<p>在实际开发中不建议。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>给查询的列起别名</p>\n<ol>\n<li>\n<p>使用 as 关键字起别名。</p>\n<p>select deptno, dname as deptname from dept;</p>\n</li>\n<li>\n<p>省略 as 关键字。</p>\n<p>select deptno, dname deptname from dept;</p>\n</li>\n<li>\n<p>起别名的时候，别名中有空格，怎么办？</p>\n<p>例如：</p>\n<p>select deptno, dname dept name from dept;</p>\n<p>DBMS 会进行 SQL 编译，检查出不符合 SQL 语法，编译报错。</p>\n<p>解决:</p>\n<p>​\tselect deptno, dname ‘dept name’ from dept;// 加单引号</p>\n<p>​\tselect deptno, dname “dept name” from dept;// 加双引号</p>\n<p><strong>注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准。双引号在 oracle 数据库中用不了。但是在 mysql 中可以使用。</strong></p>\n<p><strong>再次强调：数据库中的字符串都是采用单引号括起来。这是标准的，双引号不标准。</strong></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"二列参与数学运算\"><a class=\"markdownIt-Anchor\" href=\"#二列参与数学运算\">#</a> 二：列参与数学运算</h2>\n<ol>\n<li>\n<p>计算员工年薪？sal * 12</p>\n<p>select ename, sal * 12 from emp;// 结论：列可以参与数学运算</p>\n<p>select ename, sal * 12 as ‘年薪’ from emp;// 别名是中文，用单引号括起来。</p>\n</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql条件查询",
            "date_published": "2024-02-18T08:13:45.054Z",
            "content_html": "<h2 id=\"条件查询\"><a class=\"markdownIt-Anchor\" href=\"#条件查询\">#</a> 条件查询</h2>\n<p>什么是条件查询？</p>\n<p>不是将表中所有数据都查出来。是查询出来符合条件的。</p>\n<p>语法格式：</p>\n<p>​\tselect 字段 1，字段 2，字段 3 from 表名 where 条件；</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">=</span> 等于</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">&lt;></span>或<span class=\"token operator\">!=</span> 不等于</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">&lt;</span> 小于</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">&lt;=</span> 小于等于</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token operator\">></span> 大于</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token operator\">>=</span> 大于等于</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token operator\">between</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token operator\">and</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> 两个值之间，等同于 <span class=\"token operator\">>=</span> <span class=\"token operator\">and</span> <span class=\"token operator\">&lt;=</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t注意：</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t在使用<span class=\"token operator\">between</span> <span class=\"token operator\">and</span> 时，必须要遵循左小右大。</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token operator\">between</span> <span class=\"token operator\">and</span> 是闭区间，包括两端的值。</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t例如： <span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename<span class=\"token punctuation\">,</span>sal <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> sal <span class=\"token operator\">between</span> <span class=\"token number\">2450</span> <span class=\"token operator\">and</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t错误写法：<span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename<span class=\"token punctuation\">,</span>sal <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> sal <span class=\"token operator\">between</span> <span class=\"token number\">3000</span> <span class=\"token operator\">and</span> <span class=\"token number\">2450</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token operator\">is</span> <span class=\"token boolean\">null</span> 为 <span class=\"token boolean\">null</span> （<span class=\"token operator\">is</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span> 不为空）</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>查询那些员工的津贴<span class=\"token operator\">/</span>补助为<span class=\"token boolean\">null</span>？</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>错误查询：<span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> comm <span class=\"token operator\">=</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>正确写法：<span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> comm <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token operator\">and</span> 并且</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>查询工作岗位是MANAGER并且工资大于<span class=\"token number\">2500</span>的员工信息？</pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename<span class=\"token punctuation\">,</span>job<span class=\"token punctuation\">,</span>sal <span class=\"token keyword\">from</span> emp <span class=\"token keyword\">where</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'MANAGER'</span> <span class=\"token operator\">and</span> sal<span class=\"token operator\">></span><span class=\"token number\">2500</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token operator\">or</span> 或者</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>查询工作岗位是MANAGER或SALESMAN的员工信息？</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token keyword\">select</span> empno<span class=\"token punctuation\">,</span>ename<span class=\"token punctuation\">,</span>job<span class=\"token punctuation\">,</span>sal <span class=\"token keyword\">from</span> emo <span class=\"token keyword\">where</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'MANAGER'</span> <span class=\"token operator\">or</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'SALESMAN'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token operator\">in</span> 包含，相当于多个 <span class=\"token operator\">or</span> （<span class=\"token operator\">not</span> <span class=\"token operator\">in</span> 不在这个范围中）</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>注意：<span class=\"token operator\">in</span>不是一个区间。<span class=\"token operator\">in</span>后面跟的是具体的值。</pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token operator\">not</span> <span class=\"token operator\">not</span>可以取非，主要用在<span class=\"token operator\">is</span> 或 <span class=\"token operator\">in</span> 中</pre></td></tr><tr><td data-num=\"37\"></td><td><pre>相当于多个 <span class=\"token operator\">or</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token operator\">like</span> <span class=\"token operator\">like</span>称为模糊匹配查询，支持<span class=\"token operator\">%</span> 或下划线匹配</pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token operator\">%</span> 匹配任意个字符</pre></td></tr><tr><td data-num=\"41\"></td><td><pre>下划线，一个下划线只匹配一个字符</pre></td></tr><tr><td data-num=\"42\"></td><td><pre>找出名字中有下划线的</pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token keyword\">select</span> name <span class=\"token keyword\">from</span> t_student <span class=\"token keyword\">where</span> name <span class=\"token operator\">like</span> <span class=\"token string\">\"%\\_%\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 使用 \\ 转义字符</span></pre></td></tr></table></figure><p>注意： 在数据库中 null 不能使用等号进行衡量。需要使用 is null。因为数据库中的 null 代表什么也没有，它不是一个值，所以不能用等号衡量。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/5.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/5.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/",
            "title": "Mysql排序",
            "date_published": "2024-02-18T08:13:45.054Z",
            "content_html": "<ol>\n<li>\n<p>查询所有员工薪资，排序</p>\n<p>select ename,sal from emp order by sal;// 默认升序</p>\n<p>select ename,sal from emp order by sal asc;// 指定 ASC 升序</p>\n<p>select ename,sal from emp order by sal desc;// 指定 DESC 降序</p>\n</li>\n<li>\n<p>多个字段进行排序</p>\n<p>例如：查询员工名字和薪资，要求按照薪资升序，如果薪资相同，再按照名字升序排列。</p>\n<p>select ename, sal from emp order by sal asc, ename asc;</p>\n</li>\n<li>\n<p>根据字段位置进行排序</p>\n<p>例如：按照查询结果的第 2 列 sal 进行排序。</p>\n<p>select ename, sal from emp order by 2;</p>\n<p>注意：不建议在开发中这样写，因为不健壮。</p>\n<p>因为列的顺序很容易发生改变，列顺序修改之后，2 就废了。</p>\n<p><strong>排序采用 order by 子句，order by 后面跟上排序字段，排序可以放多个，多个可以采用逗号（,）间隔，order by 默认采用升序，如果存在 where 子句那么 order by 必须放到最后面。</strong></p>\n</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/3.%E7%90%86%E8%A7%A3Sql/%E7%90%86%E8%A7%A3Sql/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/3.%E7%90%86%E8%A7%A3Sql/%E7%90%86%E8%A7%A3Sql/",
            "title": "理解Sql",
            "date_published": "2024-02-18T08:13:45.046Z",
            "content_html": "<ol>\n<li>数据库当中最近基本的单元是表：table</li>\n</ol>\n<p>数据库当中是以表格的形式表示数据的。因为比较直观。</p>\n<p>任何一张表都有行和列：</p>\n<p>​\t行（row）：被称为数据 / 记录。</p>\n<p>​\t列（column）：被称为字段。</p>\n<p>每个字段都有：字段名，数据类型，约束等属性。</p>\n<ol start=\"2\">\n<li>\n<p>关于 SQL 语句的分类</p>\n<p>SQL 语句有很多，最好进行分门别类，这样更容易记忆。</p>\n<p>分为：</p>\n<ol>\n<li>\n<p>DQL：数据查询语言（凡是带 select 关键字的都是查询语句）</p>\n</li>\n<li>\n<p>DML：数据操作语言（凡是对表中的数据进行增删改查的都是 DML）</p>\n<ol>\n<li>\n<p>insert：增</p>\n</li>\n<li>\n<p>update：改</p>\n</li>\n<li>\n<p>delete：删</p>\n<p><strong>！！！主要操作表中的数据 data。</strong></p>\n</li>\n</ol>\n</li>\n<li>\n<p>DDL：数据定义语言（凡是带有 create，drop，alter 的都是 DDL），DDL 主要操作的是表结构。不是表中的数据。</p>\n<ol>\n<li>\n<p>alter：修改</p>\n</li>\n<li>\n<p>create：新建，等同于增</p>\n</li>\n<li>\n<p>drop：删除</p>\n<p><strong>！！！主要对表结构进行操作。</strong></p>\n</li>\n</ol>\n</li>\n<li>\n<p>TCL：事务控制语言。</p>\n<p>包括：</p>\n<ol>\n<li>事务提交：commit;</li>\n<li>事务回滚：rollback;</li>\n</ol>\n</li>\n<li>\n<p>DCL：是数据控制语言。</p>\n<p>例如：授权 grant，撤销权限 revoke…</p>\n</li>\n</ol>\n</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/23.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/23.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/",
            "title": "数据库范式",
            "date_published": "2024-02-18T08:13:45.038Z",
            "content_html": "<h1 id=\"数据库设计三范式\"><a class=\"markdownIt-Anchor\" href=\"#数据库设计三范式\">#</a> 数据库设计三范式</h1>\n<p>什么是数据库设计范式？<br>\n数据库表的设计依据。</p>\n<h2 id=\"第一范式\"><a class=\"markdownIt-Anchor\" href=\"#第一范式\">#</a> 第一范式</h2>\n<pre><code>要求任何一张表必须有主键，每一个字段原子性不可再分\n\n案例：\n学生编号    学生姓名    联系方式\n1001        张三        zs@gmail.com,135999999\n1002        李四        li@gmail.com,136999999\n1003        王五        ww@gmail.com,137999999\n\n以上表设计不满足第一范式--没有主键，联系方式可拆分\n\n修改：\n学生编号(pk)    学生姓名        邮箱                联系电话\n1001            张三        zs@gmail.com       135999999\n1002            李四        li@gmail.com       136999999\n1003            王五        ww@gmail.com       137999999\n</code></pre>\n<h2 id=\"第二范式\"><a class=\"markdownIt-Anchor\" href=\"#第二范式\">#</a> 第二范式</h2>\n<pre><code>建立在第一范式基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖\n\n案例：\n学生编号        学生姓名        教师编号        教师姓名\n1001            张三            001             王老师\n1002            李四            002             赵老师\n1002            李四            002             王老师\n1001            张三            001             赵老师\n\n以上表设计不满足第一范式--没有主键\n\n修改：\n学生编号    +    教师编号（pk）        学生姓名          教师姓名\n1001            001             张三               王老师\n1002            002             李四               赵老师\n1002            002             李四               王老师\n1001            001             张三               赵老师\n\n学生编号和教师编号连个字段做复合主键\n以上修改完之后表不满足第二范式--非主键字段，产生部分依赖(学生和教师关系产生多对多关系)\n    导致：数据冗余，空间浪费\n\n修改：\n学生编号    学生姓名\n1001        张三\n1002        李四\n\n教师编号    教师姓名\n001         王老师\n002         赵老师\n\n学生教师联合表\nid(pk)      学生编号(fk)   教师编号(fk)\n1            1001          001\n2            1002          001\n3            1001          002\n4            1002          002\n</code></pre>\n<h2 id=\"第三范式\"><a class=\"markdownIt-Anchor\" href=\"#第三范式\">#</a> 第三范式</h2>\n<pre><code>建立在第二范式基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖\n\n案例：\n学生编号（PK）        学生姓名        班级编号         班级名称\n1001                   张三            01             一班\n1002                   李四            02             二班\n1003                   王五            03             三班\n1004                   赵六            03             四班\n\n以上表的设计满足第一范式--有主键\n以上表的设计满足第二范式--主键是单一主键，不是复合主键，没有产生部分依赖（表中学生和班级是一对多关系）\n\n以上表不满足第三范式--传递性依赖（班级名称依赖班级编号，产生了传递依赖，不符合第三范式，产生了数据冗余）\n\n修改：\n班级表\n班级编号（pk）      班级名称\n01                  一班\n02                  二班\n...\n\n学生表\n学生编号（pk）      学生姓名        班级编号\n1001                张三            01\n...\n</code></pre>\n<p>作用：避免数据冗余，空间的浪费</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<pre><code>一对多：\n    一对多，两张表，多的表加外键\n\n多对多：\n    多对多，三张表，关系表两个外键\n\n一对一：\n    在一对一中，可能存在表字段太多，太庞大，需要拆分表\n    \n    案例：\n    id      login_name      login_pwd       real_name       email\n    1           admin       admin           张三            zs@gmail.com\n\n\n    修改：\n    登录信息表：\n    id      login_name      login_pwd\n    1       admin           admin\n\n    用户详细信息表：\n    id      real_name       email           login_id(fk+unique)\n    100        admin        zs@gmail.com        1\n\n    在一对一拆分表时，可以使用 外键+唯一性约束 设计表\n</code></pre>\n<h2 id=\"重点\"><a class=\"markdownIt-Anchor\" href=\"#重点\">#</a> 重点</h2>\n<pre><code>数据库设计三范式是理论上的。\n实践和理论有时候有偏差。\n最终的目的都是为了满足客户的需求，有的时候会拿数据冗余换速度。因为Sql中，表和表之间的连接次数过多，效率越低（笛卡尔积）\n有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的。\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/24.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/24.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/",
            "title": "主从同步机制",
            "date_published": "2024-02-18T08:13:45.038Z",
            "content_html": "<h1 id=\"主从同步机制\"><a class=\"markdownIt-Anchor\" href=\"#主从同步机制\">#</a> 主从同步机制</h1>\n<p>作用</p>\n<ul>\n<li>可以用作一种备份机制，相当于热备份</li>\n<li>可以用做读写分离，均衡数据库负载</li>\n</ul>\n<p>概述</p>\n<p>MySQL 主从复制也能够称为 MySQL 主从同步，它是构建数据库高可用集群架构的基础。它经过将一台主机的数据复制到其余一台或多台主机上，并从新应用 relay log 中的 SQL 语句来实现复制功能。MySQL 支持单向、双向、链式级联、异步复制，5.5 版本以后加入的半同步复制，5.6 版本以后的 GTID 复制，MySQL5.7 的多源复制、并行复制、loss-less 复制。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/",
            "title": "Mysql存储过程",
            "date_published": "2024-02-18T08:13:45.038Z",
            "content_html": "<h1 id=\"mysql存储过程\"><a class=\"markdownIt-Anchor\" href=\"#mysql存储过程\">#</a> Mysql 存储过程</h1>\n<p>存储过程是在数据库中定义一些 SQL 语句的集合，可以直接去调用这些存储过程来执行已经定义好的 SQL 语句。</p>\n<p>触发器和存储过程相似，都是嵌入到 MySql 中的一段程序。触发器是由事件来触发某个操作。当数据库执行这些事件时，就会激活触发器来执行相应的操作。</p>\n<p><strong>优点：</strong></p>\n<blockquote>\n<ul>\n<li>存储过程可封装，并隐藏复杂的商业逻辑。</li>\n<li>存储过程可以回传值，并可以接受参数。</li>\n<li>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li>\n<li>存储过程可以用在数据检验，强制实行商业逻辑等。</li>\n</ul>\n</blockquote>\n<p><strong>缺点：</strong></p>\n<blockquote>\n<ul>\n<li>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</li>\n<li>存储过程的性能调校与撰写，受限于各种数据库系统。</li>\n</ul>\n</blockquote>\n<h2 id=\"存储过程\"><a class=\"markdownIt-Anchor\" href=\"#存储过程\">#</a> 存储过程</h2>\n<p>数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。例如，为了确认学生能否毕业，需要同时查询学生档案、成绩表和从何表，此时就需要使用多条 SQL 语句来针对这几个数据表完成处理要求。存储过程就是这样一组为了完成特定功能的 SQL 语句的集合。</p>\n<p>使用存储过程的目的是将经常或复杂的工作预先使用 SQL 语句写好，并用一个指定的名称存储起来，这个过程经编译和优化由存储在数据库服务器中，因此成为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需要调用 “CALL 存储过程名字” 即可自动完成。</p>\n<p>常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。</p>\n<p>一个存储过程即一个可编程的函数，它可以在数据库中创建并保存，一般由 SQL 语句和一些特殊控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。</p>\n<pre><code>MySql5.0版本以前并不支持存储过程。\n</code></pre>\n<p>存储过程时数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以被调用，完成指定的功能操作。</p>\n<p>使用存储过程不仅可以提高数据的访问效率，同时也可以提高数据库使用的安全性。</p>\n<p>对于调用者来说，存储过程封装了 SQL 语句，调用者无需考虑逻辑功能的具体实现过程。只是简单调用即可，它可以被 Java 和 C# 等编程语言调用。</p>\n<h3 id=\"创建存储过程\"><a class=\"markdownIt-Anchor\" href=\"#创建存储过程\">#</a> 创建存储过程</h3>\n<p>创建存储过程使用 create procedure 语句，语法格式如下</p>\n<pre><code>create procedure &lt;过程名&gt; ([过程参数[,...]]) &lt;过程体&gt;\n</code></pre>\n<pre><code class=\"language-Sql\">\nCREATE\n    [DEFINER = &#123; user | CURRENT_USER &#125;]\n　PROCEDURE sp_name ([proc_parameter[,...]])\n    [characteristic ...] routine_body\n \nproc_parameter:\n    [ IN | OUT | INOUT ] param_name type\n \ncharacteristic:\n    COMMENT 'string'\n  | LANGUAGE SQL\n  | [NOT] DETERMINISTIC\n  | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;\n  | SQL SECURITY &#123; DEFINER | INVOKER &#125;\n \nroutine_body:\n　　Valid SQL routine statement\n \n[begin_label:] BEGIN\n　　[statement_list]\n　　　　……\nEND [end_label]\n\n</code></pre>\n<p><strong>Mysql 存储过程中的关键语法</strong></p>\n<p>声明语句结束符，可以自定义</p>\n<blockquote>\n<p>DELIMTER &amp;&amp;<br>\n 或<br>\n DELIMTER //</p>\n<p>在 Mysql 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符号，那么 MySQL 服务器在处理存储过程时，会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的额结束符，而不再去处理存储过程体后面的 SQL 语句，这样显然不行。为了解决以上问题，通常使用 <strong>DELIMITER</strong> 命令将结束命令修改为其他字符。</p>\n<p>语法说明如下：<br>\n'$$' 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个 “？” 或两个 “￥“ 等。<br>\n当使用 DELIMITER 命令时，应该避免使用反斜杠 &quot;&quot; 字符，因为它是 MySQL 的转义字符。</p>\n<p>在 MySQL 命令行客户端使用：<br>\nmysql&gt; DELIMITER ??<br>\n 执行该命令后，任何命令、语句或程序的结束标志就换为两个问号 &quot;??“了。<br>\n注意：DELIMITER 和分号 “;” 之间一定要有一个空格（使用分号”;&quot; 作为 MySQL 语句结束符）。</p>\n</blockquote>\n<p>声明存储过程</p>\n<blockquote>\n<p>create procedure demo_in_parameter(IN pin int)</p>\n</blockquote>\n<p>存储过程开始和结束符号</p>\n<blockquote>\n<p>BEGIN<br>\n…<br>\nEND</p>\n<p>过程体是存储过程的主体部分，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 <strong>BEGIN</strong> 开始，以关键字 <strong>END</strong> 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。</p>\n</blockquote>\n<p>变量赋值</p>\n<blockquote>\n<p>SET @pin=1</p>\n</blockquote>\n<p>变量定义</p>\n<blockquote>\n<p>declare l_int int unsigned default 400;</p>\n</blockquote>\n<p>创建 Mysql 存储过程</p>\n<blockquote>\n<p>create procedure 存储过程名 (参数)</p>\n</blockquote>\n<p>创建存储过程体</p>\n<blockquote>\n<p>create function 存储函数名 (参数)</p>\n</blockquote>\n<pre><code>默认情况下，存储过程和默认数据库相关联，如果想指定存储过程创建在某个特定的数据库下，那么在过程名前面加数据库名做前缀。\n</code></pre>\n<h3 id=\"存储过程的参数\"><a class=\"markdownIt-Anchor\" href=\"#存储过程的参数\">#</a> 存储过程的参数</h3>\n<p>其中，过程参数是存储过程的参数列表。MySQL 存储过程支持三种类型的参数，即输入参数，输出参数和输入 / 输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输出 / 输出参数既可以充当输入参数也可以充当输出参数。格式如下</p>\n<pre><code>[ IN | OUT | INOUT ] &lt;参出名&gt; &lt;类型&gt;\n</code></pre>\n<p>在创建存储过程时，必须具有 create routine 权限。</p>\n<p>例如：<br>\nmysql&gt; DELIMITER //<br>\nmysql&gt; CREATE PROCEDURE GetScoreByStu<br>\n-&gt; (IN name VARCHAR(30))<br>\n-&gt; BEGIN<br>\n-&gt; SELECT student_score FROM tb_students_score<br>\n-&gt; WHERE student_name=name;<br>\n-&gt; END //<br>\nQuery OK, 0 rows affected (0.01 sec)</p>\n<h2 id=\"12-查看存储过程\"><a class=\"markdownIt-Anchor\" href=\"#12-查看存储过程\">#</a> 1.2 查看存储过程</h2>\n<pre><code>SHOW PROCEDURE STATUS LIKE 存储过程名;\n</code></pre>\n<p>也可以查看存储过程的定义，语法格式如下</p>\n<pre><code>SHOW CREATE PROCEDURE 存储过程名\n</code></pre>\n<h2 id=\"13修改存储过程\"><a class=\"markdownIt-Anchor\" href=\"#13修改存储过程\">#</a> 1.3 修改存储过程</h2>\n<h2 id=\"14-执行sql语句\"><a class=\"markdownIt-Anchor\" href=\"#14-执行sql语句\">#</a> 1.4 执行 Sql 语句</h2>\n<pre><code class=\"language-Sql\">\nPREPARE statement_name FROM sql_statement -- 使用 PREPARE 语句准备要执行的SQL语句，statement_name 是语句的名称， sql_statement 是要执行的SQL语句。\n\nEXECUTE statement_name USING @variable_name -- 使用 EXECUTE 语句执行准备好的SQL语句，statement_name 是语句的名称， @variable_name 是要传递给SQL语句的参数。\n\nDEALLOCATE PREPARE statement_name -- 使用 DEALLOCATE PREPARE 语句释放已准备的SQL语句，statement_name 是要释放的语句的名称。\n\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/21.%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/21.%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/",
            "title": "视图",
            "date_published": "2024-02-18T08:13:45.029Z",
            "content_html": "<h1 id=\"视图\"><a class=\"markdownIt-Anchor\" href=\"#视图\">#</a> 视图</h1>\n<p>什么是视图？<br>\nview：站在不同的角度，去看待同一份数据</p>\n<h2 id=\"创建视图\"><a class=\"markdownIt-Anchor\" href=\"#创建视图\">#</a> 创建视图</h2>\n<pre><code>create view 视图名 as DQL语句;\n\ncreate view emp_view as select * from emp;\n</code></pre>\n<p>注意：只有 DQL 语句才能以 view 的形式创建</p>\n<h2 id=\"删除视图\"><a class=\"markdownIt-Anchor\" href=\"#删除视图\">#</a> 删除视图</h2>\n<pre><code>drop view emp_view;\n</code></pre>\n<h2 id=\"视图作用可以干什么方便-简化开发-利于维护\"><a class=\"markdownIt-Anchor\" href=\"#视图作用可以干什么方便-简化开发-利于维护\">#</a> 视图作用（可以干什么）–方便、简化开发、利于维护</h2>\n<pre><code>可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作\n\n特点：对视图的操作，会影响到原表数据\n\nselect * from dept2_view;\n\ninsert into dept2_view(deptno, dname, loc) vlaues(60, 'SALES', 'BJ');// （insert、delete、update）操作会影响到原表\n</code></pre>\n<p>视图对象在实际开发中，到底有什么作用？<br>\n假设有一条 SQL 语句，需要在不同位置反复使用，每次使用需要重新编写，可以把这条复杂的 SQL 语句以视图对象的形式创建出来<br>\n在需要编写这条 SQL 语句的位置直接使用视图对象。可以简化开发，并且利于后期维护。因为只需要修改一个位置就行了，只需要修改视图对象所映射的 SQL 语句</p>\n<p>使用视图开发的时候，可以像使用 table 一样，可以对视图进行增删改查等操作。<br>\n视图对象是存储在硬盘上的，不会消失</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/22.DBA%E5%91%BD%E4%BB%A4/DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/22.DBA%E5%91%BD%E4%BB%A4/DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "title": "DBA命令",
            "date_published": "2024-02-18T08:13:45.029Z",
            "content_html": "<h1 id=\"dba命令\"><a class=\"markdownIt-Anchor\" href=\"#dba命令\">#</a> DBA 命令</h1>\n<p><strong>必须超级管理员操作</strong></p>\n<h2 id=\"新建用户\"><a class=\"markdownIt-Anchor\" href=\"#新建用户\">#</a> 新建用户</h2>\n<pre><code>create USER username IDENTIFIED by 'password';\n\ncreate USER 'username'@'host' IDENTIFIED by 'password';\n</code></pre>\n<p>username：创建的用户名。</p>\n<p>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符 %</p>\n<p>password：该用户的登陆密码。密码可以为空，如果为空则该用户可以不需要密码登陆服务器。</p>\n<h2 id=\"授权\"><a class=\"markdownIt-Anchor\" href=\"#授权\">#</a> 授权</h2>\n<pre><code>GRANT SELECT,INSERT on *.* to 'guest'@'%';\n</code></pre>\n<p><em>.</em>：表示表示所有库的所有表</p>\n<pre><code>grant all privileges on 数据库 to '用户名'@'IP地址';\n</code></pre>\n<h2 id=\"回收权限\"><a class=\"markdownIt-Anchor\" href=\"#回收权限\">#</a> 回收权限</h2>\n<pre><code>revoke all privileges from 数据库 to '用户名'@'IP地址';\n</code></pre>\n<p>all privileges 指除了 grant 之外的所有权限，也可以自己设置权限</p>\n<p>例如：grant insert on world.* to ‘用户名’@‘IP 地址’;(只能对 world 数据库做插入操作，world.* 表示对 world 中所有表）</p>\n<h2 id=\"导出导入\"><a class=\"markdownIt-Anchor\" href=\"#导出导入\">#</a> 导出导入</h2>\n<pre><code>导出\n    在windows的dos命令窗口中：\n    mysqldump nk&gt;D:\\nk.sql -uroot -proot\n\n    导出指定的表:导出nk数据库中 student表\n    mysqldump nk student&gt;D:\\nk.sql -uroot -proot\n\n\n导入\n    登录到mysql中，创建数据库 create database nk;\n    然后导入sql文件\n    source D:\\nk.sql\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95/",
            "title": "索引",
            "date_published": "2024-02-18T08:13:45.021Z",
            "content_html": "<h1 id=\"索引\"><a class=\"markdownIt-Anchor\" href=\"#索引\">#</a> 索引</h1>\n<p>什么是索引？<br>\n索引在数据库表的字段上添加的，是为了提高检索（查询）效率存在的一种机制</p>\n<pre><code>一张表的一个字段可以添加一个索引，多个字段可以联合起来添加索引\n\n索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制\n</code></pre>\n<p>举例：<br>\n查字典：<br>\n1. 一页一页查找，直到找到为止。这种查找属于全表扫描，效率低</p>\n<pre><code>    3. 通过目录（索引），去定位一个大概的位置，然后直接定位到该位置，做局域性扫描，缩小扫描的范围，快速的查找。这种方式属于索引检索，效率高\n\nMysql中查询的两种方式：\n    1. 全表扫描\n    2. 根据索引检索\n</code></pre>\n<p>注意：<br>\n在 Mysql 数据库当中索引也是需要排序的，并且这个索引的排序和 TreeSet 数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！<br>\n在 Mysq 中索引是一个 B-Tree 数据结构。</p>\n<pre><code>遵循左小右大原则存放，采用中序遍历方式遍历取数据\n</code></pre>\n<p><strong>在任何数据库当中，主键都会自动添加索引对象</strong></p>\n<p><strong>在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号</strong></p>\n<p><strong>在 Mysql 中，一个字段上如果右 unique 约束的话，也会自动创建索引对象</strong></p>\n<p><strong>在 Mysql 当中，索引是一个单独的对象，不同的存储引擎以不同形式存在。</strong><br>\n1. 在 MyISAM 存储引擎中，索引存储在一个.MYI 文件中<br>\n 2. 在 InnoDB 存储引擎当中，索引存储在一个叫 tablespace 当中。<br>\n3. 在 Memory 存储引擎当中，被存储在内存当中<br>\n不管索引存储在哪里，索引在 Mysql 中都是一个树的形式存在。（自平衡二叉树：B-Tree）</p>\n<h2 id=\"在mysql中主键以及unique字段上都会自动添加索引\"><a class=\"markdownIt-Anchor\" href=\"#在mysql中主键以及unique字段上都会自动添加索引\">#</a> 在 Mysql 中，主键以及 unique 字段上都会自动添加索引</h2>\n<p>什么条件下，需要考虑给字段添加索引？<br>\n1. 数据量庞大（需要测试）<br>\n2. 该字段经常出现在 where 查询条件中<br>\n 3. 该字段很少的 DML 操作（因为 DML 之后，索引经常需要重新排序）<br>\n注意：<br>\n建议不要随意添加索引，因为索引也是需要维护的，太多反而会降低系统性能<br>\n建议通过主键查询，建议通过 unique 约束字段进行查询，效率是比较高的</p>\n<h2 id=\"创建和删除索引\"><a class=\"markdownIt-Anchor\" href=\"#创建和删除索引\">#</a> 创建和删除索引</h2>\n<h3 id=\"创建索引\"><a class=\"markdownIt-Anchor\" href=\"#创建索引\">#</a> 创建索引</h3>\n<pre><code>create index 索引名 on 表名(要添加索引的字段名);\n\ncreate index emp_ename_index on emp(ename);\n</code></pre>\n<h3 id=\"删除索引\"><a class=\"markdownIt-Anchor\" href=\"#删除索引\">#</a> 删除索引</h3>\n<pre><code>drop index 索引名 on 表名;\n\ndrop index emp_ename_index on emp;\n\n\n在Mysql中查看一个SQL语句是否使用了索引进行检索\nexplain select * from t_user where name = 'zhangsan6';\n</code></pre>\n<p>举例：<br>\n## 查看 sql 语句执行详情<br>\n mysql&gt; explain select * from t_user where name = ‘zhangsan6’;<br>\n±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+<br>\n| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>\n±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+<br>\n|  1 | SIMPLE      | t_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   12 |    10.00 | Using where |<br>\n±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+<br>\n1 row in set, 1 warning (0.00 sec)</p>\n<pre><code>## 为name字段创建索引\ncreate index user_name_index on t_user(name);\n\n## 在索引创建后，重新执行sql语句，查看sql执行情况\nmysql&gt; explain select * from t_user where name = 'zhangsan6';\n+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+\n| id | select_type | table  | partitions | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+\n|  1 | SIMPLE      | t_user | NULL       | ref  | user_name_index | user_name_index | 1023    | const |    1 |   100.00 | Using index |\n+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<p>性能分析：</p>\n<blockquote>\n<p>1）、id 列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id 列为 null 的就表是这是一个结果集，不需要使用它来进行查询。</p>\n<p>2）、select_type 列常见的有：<br>\nA：simple：表示不需要 union 操作或者不包含子查询的简单 select 查询。有连接查询时，外层的查询为 simple，且只有一个<br>\n B：primary：一个需要 union 操作或者含有子查询的 select，位于最外层的单位查询的 select_type 即为 primary。且只有一个<br>\n C：union：union 连接的两个 select 查询，第一个查询是 dervied 派生表，除了第一个表外，第二个以后的表 select_type 都是 union<br>\nD：dependent union：与 union 一样，出现在 union 或 union all 语句中，但是这个查询要受到外部查询的影响<br>\n E：union result：包含 union 的结果集，在 union 和 union all 语句中，因为它不需要参与查询，所以 id 字段为 null<br>\nF：subquery：除了 from 字句中包含的子查询外，其他地方出现的子查询都可能是 subquery<br>\nG：dependent subquery：与 dependent union 类似，表示这个 subquery 的查询要受到外部表查询的影响<br>\n H：derived：from 字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套 select</p>\n<p>3）、table<br>\n 显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为 null，如果显示为尖括号括起来的<derived N>就表示这个是临时表，&gt; 后边的 N 就是执行计划中的 id，表示结果来自于这个查询产生。如果是尖括号括起来的 &lt;union M,N&gt;，与<derived N>类似，也是一个临时表，表示这个结果来自于 union 查询的 id 为 M,&gt; N 的结果集。</p>\n<p>4）、type<br>\n 依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了 all 之外，其他的 type 都 &gt; 可以使用到索引，除了 index_merge 之外，其他的 type 只可以用到一个索引<br>\n A：system：表中只有一行数据或者是空表，且只能用于 myisam 和 memory 表。如果是 Innodb 引擎表，type 列在这个情况通常都是 all 或者 index<br>\nB：const：使用唯一索引或者主键，返回记录一定是 1 行记录的等值 where 条件时，通常 type 是 const。其他数据库也叫做唯一索引扫描<br>\n C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为 not null，唯一索引和主键是多列时，只有所有的 &gt; 列都用作比较时才会出现 eq_ref<br>\nD：ref：不像 eq_ref 那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一 &gt; 个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。<br>\nE：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql 不管代价，优先选择使用全文索引<br>\n F：ref_or_null：与 ref 方法类似，只是增加了 null 值的比较。实际用的不多。<br>\nG：unique_subquery：用于 where 中的 in 形式子查询，子查询返回不重复值唯一值<br>\n H：index_subquery：用于 in 形式子查询使用到了辅助索引或者 in 常数列表，子查询可能返回重复值，可以使用索引将子查询去重。<br>\nI：range：索引范围扫描，常见于使用 &gt;,&lt;,is null,between ,in ,like 等运算符的查询中。<br>\nJ：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见 and ，or 的条件使用了不同的索引，官方排序这个在 ref_or_null 之后，但是实际上由于要读取所个 &gt; 索引，性能可能大部分时间都不如 range<br>\nK：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。<br>\nL：all：这个就是全表扫描数据文件，然后再在 server 层进行过滤返回符合要求的记录。</p>\n<p>5）、possible_keys<br>\n 查询可能使用到的索引都会在这里列出来</p>\n<p>6）、key<br>\n 查询真正使用到的索引，select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个。</p>\n<p>7）、key_len<br>\n 用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进 &gt; 去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql 的 ICP 特性使用到的索引不会计入其中。&gt; 另外，key_len 只计算 where 条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到 key_len 中。</p>\n<p>8）、ref<br>\n 如果是使用的常数等值查询，这里会显示 const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部 &gt; 隐式转换，这里可能显示为 func</p>\n<p>9）、rows<br>\n 这里是执行计划中估算的扫描行数，不是精确值</p>\n<p>10）、extra<br>\n 这个列可以显示的信息非常多，有几十种，常用的有<br>\n A：distinct：在 select 部分使用了 distinc 关键字<br>\n B：no tables used：不带 from 字句的查询或者 From dual 查询<br>\n C：使用 not in () 形式子查询或 not exists 运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。<br>\nD：using filesort：排序时无法使用到索引时，就会出现这个。常见于 order by 和 group by 语句中<br>\n E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。<br>\nF：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x 之后的版本优化关联查询的 BNL，BKA 特性。主要是减少内表的循环数量以及比 &gt; 较顺序地扫描查询。<br>\nG：using sort_union，using_union，using intersect，using sort_intersection：<br>\nusing intersect：表示使用 and 的各个索引的条件时，该信息表示是从处理结果获取交集<br>\n using union：表示使用 or 连接各个使用索引的条件时，该信息表示从处理结果获取并集<br>\n using sort_union 和 using sort_intersection：与前面两个对应的类似，只是他们是出现在用 and 和 or 查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返 &gt; 回。<br>\nH：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看 status 变量，used_tmp_table，&gt; used_tmp_disk_table 才能看出来。<br>\nI：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在 server 层进行过滤。查询条件中分为限制条件和检查条件，5.6 之前，存储引擎只能根据限制条件 &gt; 扫描数据并返回，然后 server 层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x 之后支持 ICP 特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数 &gt; 据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra 列显示 using index condition<br>\nJ：firstmatch (tb_name)：5.6.x 开始引入的优化子查询的新特性之一，常见于 where 字句含有 in () 类型的子查询。如果内表的数据量比较大，就可能出现这个<br>\n K：loosescan (m…n)：5.6.x 之后引入的优化子查询的新特性之一，在 in () 类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p>\n<p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</p>\n<p>11）、filtered<br>\n 使用 explain extended 时会出现这个列，5.7 之后的版本默认就有这个字段，不需要使用 explain extended 了。这个字段表示存储引擎返回的数据在 server 层过滤后，剩下多少满足 &gt; 查询的记录数量的比例，注意是百分比，不是具体记录数。</p>\n</blockquote>\n<h3 id=\"性能分析2-explain-analyze\"><a class=\"markdownIt-Anchor\" href=\"#性能分析2-explain-analyze\">#</a> 性能分析 2 Explain Analyze</h3>\n<pre><code class=\"language-Sql\">\n-- auto-generated definition\ncreate table eps_working_rec\n(\n    RecNo      int auto_increment comment '记录编号'\n        primary key,\n    ShiftNo    varchar(20)    null,\n    WorkDate   datetime       null comment '生产日期',\n    LineFK     varchar(50)    null comment '包装线编号',\n    EqutFK     varchar(20)    not null comment '设备编号',\n    Rec_Type   int            not null comment '记录类型',\n    StopReason varchar(50)    null comment '停机类型：A—交接班，B—工艺清洗，C—更换品种，D—外部原因，E—故障停机',\n    BeginTime  datetime       null comment '开始时间',\n    EndTime    datetime       null comment '结束时间',\n    Time_Cum   int            null comment '时长',\n    BBQty      decimal(18, 4) null comment '清酒量(单位：KL)',\n    FinalBot   int            null comment '成品瓶数（单位：瓶）',\n    IsValid    tinyint        null comment '数据是否有效',\n    DataSrouce varchar(10)    null comment '数据来源：数据采集Automatic，人工维护Manual',\n    CreateBy   varchar(20)    null comment '创建者（默认值：数据采集）',\n    CreateOn   datetime       null comment '创建时间（记录插入时的系统时间）',\n    UpdateBy   varchar(20)    null comment '修改人',\n    UpdateOn   datetime       null comment '修改时间',\n    StopClass  varchar(50)    null,\n    Qty_Bottle int            null,\n    Qty_Box    int            null,\n    Qty_Stack  int            null,\n    IsFillStop tinyint        null,\n    Classes    varchar(20)    null,\n    StopNature varchar(50)    null\n)\n    charset = utf8mb3;\n\ncreate index PK_EPS_VBT\n    on eps_working_rec (IsValid, BeginTime, Time_Cum);\n\ncreate index PK_LineFK_EqutFk\n    on eps_working_rec (LineFK, EqutFK);\n\ncreate index dta_index_EPS_Working_Rec\n    on eps_working_rec (EqutFK, StopReason, BeginTime, EndTime, Time_Cum, Rec_Type, RecNo);\n\n\n# 执行的sql语句\nexplain analyze\nselect sum(Time_Cum)\nfrom eps_working_rec\nwhere Rec_Type = 1\n  and EqutFK = 'EQPK21004'\n\n# 执行sql返回的结果\n-&gt; Aggregate: sum(eps_working_rec.Time_Cum)  (cost=3496.35 rows=1) (actual time=15.869..15.869 rows=1 loops=1)\n    -&gt; Filter: (eps_working_rec.Rec_Type = 1)  (cost=2762.65 rows=7337) (actual time=0.054..14.458 rows=20016 loops=1)\n        -&gt; Covering index lookup on eps_working_rec using dta_index_EPS_Working_Rec (EqutFK='EQPK21004')  (cost=2762.65 rows=73370) (actual time=0.053..12.303 rows=40293 loops=1)\n\n</code></pre>\n<blockquote>\n<p>(cost=3496.35 rows=1) cost 预计执行时间、rows 预计返回记录条数</p>\n<p>(cost=2762.65 rows=7337) (actual time=0.054…14.458 rows=20016 loops=1)<br>\n 实际执行结果情况：<br>\ntime 分为两部分: 0.054 返回第一条记录的时间  14.458 返回所有记录耗时<br>\n row 返回准确的记录数<br>\n loops 是当前过滤迭代器所执行的循环的数量。</p>\n</blockquote>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/",
            "title": "索引失效",
            "date_published": "2024-02-18T08:13:45.021Z",
            "content_html": "<h1 id=\"索引失效\"><a class=\"markdownIt-Anchor\" href=\"#索引失效\">#</a> 索引失效</h1>\n<p>什么时候索引会失效？</p>\n<pre><code>第一种情况：\n select * from t_user where name like '%z';\n\n 因为模糊匹配中以 '%' 开头了，索引失效（存在索引，但不走索引）\n\n\n第二种情况：\n 使用or的时候会失效，如果使用or，那么要求or两边字段条件都要有索引，才会走索引。如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效\n\n\n第三种情况：\n 使用复合索引的时候，没有使用左侧的列查找，索引失效( 最左原则 )\n create index emp_job_sal_index on emp(job, sal);\n\n explain select * from emp where job = 'MANAGER';// 走索引\n explain select * from emp where sal = 1000;// 索引失效\n\n\n第四种情况：\n 在where当中，索引参与了数学运算，索引失效\n\n create index emp_sal_index on emp(sal);\n\n explain select * from emp where sal = 800;// 走索引\n explain select * from emp where sal = 800 + 100;// 走索引\n\n explain select * from emp where sal + 100 = 800;// 索引失效\n\n\n第五种情况：\n 在where当中，索引列使用了函数，索引失效\n\n create index emp_ename_index on emp(ename);\n\n explain select * from emp where ename = 'SIMTH';// 走索引\n\n explain select * from emp where lower(ename) = 'simth';// 索引失效\n\n\n第六种情况：....\n第七种情况：....\n...\n\n\n\n索引是数据库优化的重要手段，优化的时候，优先考虑的因素就是索引。\n</code></pre>\n<p>索引分类：<br>\n单一索引：<br>\n复合索引：<br>\n主键索引：<br>\n唯一性索引：<br>\n…</p>\n<p>注意：唯一性比较弱的字段上添加索引用处不大。（可能存在大量重复数据，这个时候索引起不到什么作用，越唯一，效率越高）</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/",
            "title": "事务隔离",
            "date_published": "2024-02-18T08:13:45.013Z",
            "content_html": "<h1 id=\"事务隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#事务隔离级别\">#</a> 事务隔离级别</h1>\n<h2 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类</h2>\n<h3 id=\"读未提交read-uncommitted\"><a class=\"markdownIt-Anchor\" href=\"#读未提交read-uncommitted\">#</a> 读未提交：read uncommitted</h3>\n<pre><code>概念：\n    事务A可以读取到事务B未提交的数据\n\n存在脏读现象（Dirty Rread）：称读到脏数据\n</code></pre>\n<h3 id=\"读已提交readcommitted\"><a class=\"markdownIt-Anchor\" href=\"#读已提交readcommitted\">#</a> 读已提交：readcommitted</h3>\n<pre><code>概念：\n    事务A只能读取到事务B提交之后的数据\n这种隔离级别解决了脏读现象\n\n存在‘不可重复读取数据’问题：在事务开启后，每次读取到的数据可能不一致。比如A开始事务循环读取数据的过程中，B事务不断修改数据并提交，导致A事务在后续的数据读取过程中，数据产生不一致的现象\n\n这种隔离级别是比较真实的数据，每一次读到的数据绝对真实\n注意：Oracle数据库默认的隔离级别是： read committed\n</code></pre>\n<h3 id=\"可重复读repeatable-read\"><a class=\"markdownIt-Anchor\" href=\"#可重复读repeatable-read\">#</a> 可重复读：repeatable read</h3>\n<pre><code>概念：\n    事务A开启后，不管多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据修改，并且提交了。事务A读取到的数据还是没有发生改变，这就是可重复读\n解决了不可重复读的现象\n\n存在幻读现象：每一次读取到的数据都是幻象，不够真实\n\nMysql默认隔离级别\n</code></pre>\n<h3 id=\"序列化串行化serializable\"><a class=\"markdownIt-Anchor\" href=\"#序列化串行化serializable\">#</a> 序列化 / 串行化：serializable</h3>\n<pre><code>概念：\n\n隔离级别最高，效率最低。解决了所有问题\n不能并发\n</code></pre>\n<h2 id=\"测试隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#测试隔离级别\">#</a> 测试隔离级别</h2>\n<pre><code>查看变量：\nshow variables;\n通过like 通配符查询\nshow variables like '%isolation%';\n\n查看隔离级别：\nselect @@transaction_isolation; \n\n设置全局事务等级\nset global transaction isolation level read committed;\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/2.Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/2.Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "title": "Mysql常用命令",
            "date_published": "2024-02-18T08:13:45.013Z",
            "content_html": "<ol>\n<li>在 windows 操作系统中，怎么使用命令行来启动 Mysql 和关闭 Mysql 服务？</li>\n</ol>\n<p>语法：</p>\n<p>​\tnet stop 服务名称；</p>\n<p>​\tnet start 服务名称；</p>\n<ol start=\"2\">\n<li>\n<p>登录 Mysql 数据库</p>\n<p>明文密码登录：mysql -u [用户名] -p [密码]</p>\n<p>隐藏密码登录：mysql -u [用户名] -p + 回车键，然后输入密码</p>\n</li>\n<li>\n<p>退出 Mysql</p>\n<p>exit</p>\n</li>\n<li>\n<p>查看数据库有哪些数据库？mysql 默认自带了 4 个数据库</p>\n<p>show databases;</p>\n</li>\n<li>\n<p>怎么选择使用哪个数据库？</p>\n<p>use [数据库名]</p>\n</li>\n<li>\n<p>怎么创建数据库？</p>\n<p>create database [数据库名];</p>\n</li>\n<li>\n<p>怎么查看有哪些表？</p>\n<p>show tables;</p>\n</li>\n<li>\n<p>怎么查看表结构？</p>\n<p>desc [表名]</p>\n<p>全写为：</p>\n<p>​\tdescribe [表名]</p>\n</li>\n<li>\n<p>将 sql 文件中的数据导入？</p>\n<p>source [路径]</p>\n<p><strong>注意路径中不要有中文。</strong></p>\n<p>例如： source D:\\coure\\03-Mysql\\document\\bjpowernode.sql</p>\n</li>\n<li>\n<p>查看数据库版本号</p>\n<p>select version();</p>\n</li>\n<li>\n<p>查看当前使用的是那个数据库</p>\n<p>select database();</p>\n</li>\n<li>\n<p>中止输入的 mysql 命令（还未执行的命令）</p>\n<p>\\c 用来中止一条命令的输入。</p>\n<p>例如：</p>\n<p><em>mysql&gt; show</em><br>\n<em>-&gt;</em><br>\n<em>-&gt;</em><br>\n<em>-&gt;</em><br>\n<em>-&gt; \\c</em><br>\n<em>mysql&gt;</em></p>\n</li>\n<li>\n<p>查看 Mysql 支持那些存储引擎</p>\n</li>\n</ol>\n<p>show engines \\G;</p>\n<ol start=\"14\">\n<li>查看建表语句</li>\n</ol>\n<p>show create table 表名；</p>\n<p>！！！以上命令不区分大小写</p>\n<p>！！！注意：Mysql 中命令是不见分号；则不会执行命令。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/18.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/18.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/",
            "title": "存储引擎",
            "date_published": "2024-02-18T08:13:45.004Z",
            "content_html": "<h1 id=\"存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#存储引擎\">#</a> 存储引擎</h1>\n<p>什么是存储引擎？有什么用？</p>\n<pre><code>存储引擎是Mysql中特有的一个术语。其他数据库中没有（Oracle中也有，不叫这个名字）\n\n存储引擎实际上是一张表存储/组织数据的方式。\n\n不同的存储引擎，表存储的方式不同。\n</code></pre>\n<p>如何制定表的存储引擎？</p>\n<pre><code>可以在建表时，最后来指定表的存储引擎。\ncharset 来指定表的字符编码方式\n\nshow create table student;\n\nCREATE TABLE `student` (\n`id` int NOT NULL AUTO_INCREMENT,\n`name` varchar(255) DEFAULT NULL,\n`cno` int DEFAULT NULL,\nPRIMARY KEY (`id`),\nKEY `cno` (`cno`),\nCONSTRAINT `student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`t_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |\n</code></pre>\n<p>结论：<br>\nmysql 默认的存储引擎是 InnoDB<br>\nmysql 默认的字符编码方式： utf8mb4</p>\n<pre><code>create table test(\n    id int,\n    name varchar(10)\n) engine=InnoDB default CHARSET=utf8mb4;\n</code></pre>\n<h2 id=\"查看mysql支持哪些存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#查看mysql支持哪些存储引擎\">#</a> 查看 Mysql 支持哪些存储引擎</h2>\n<pre><code>show engines \\G;\n\nmysql&gt; show engines \\G;\n*************************** 1. row ***************************\n    Engine: MEMORY\n    Support: YES\n    Comment: Hash based, stored in memory, useful for temporary tables\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 2. row ***************************\n    Engine: MRG_MYISAM\n    Support: YES\n    Comment: Collection of identical MyISAM tables\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 3. row ***************************\n    Engine: CSV\n    Support: YES\n    Comment: CSV storage engine\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 4. row ***************************\n    Engine: FEDERATED\n    Support: NO\n    Comment: Federated MySQL storage engine\nTransactions: NULL\n        XA: NULL\nSavepoints: NULL\n*************************** 5. row ***************************\n    Engine: PERFORMANCE_SCHEMA\n    Support: YES\n    Comment: Performance Schema\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 6. row ***************************\n    Engine: MyISAM\n    Support: YES\n    Comment: MyISAM storage engine\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 7. row ***************************\n    Engine: InnoDB\n    Support: DEFAULT\n    Comment: Supports transactions, row-level locking, and foreign keys\nTransactions: YES\n        XA: YES\nSavepoints: YES\n*************************** 8. row ***************************\n    Engine: ndbinfo\n    Support: NO\n    Comment: MySQL Cluster system information storage engine\nTransactions: NULL\n        XA: NULL\nSavepoints: NULL\n*************************** 9. row ***************************\n    Engine: BLACKHOLE\n    Support: YES\n    Comment: /dev/null storage engine (anything you write to it disappears)\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 10. row ***************************\n    Engine: ARCHIVE\n    Support: YES\n    Comment: Archive storage engine\nTransactions: NO\n        XA: NO\nSavepoints: NO\n*************************** 11. row ***************************\n    Engine: ndbcluster\n    Support: NO\n    Comment: Clustered, fault-tolerant tables\nTransactions: NULL\n        XA: NULL\nSavepoints: NULL\n11 rows in set (0.00 sec)\n</code></pre>\n<h2 id=\"常用存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#常用存储引擎\">#</a> 常用存储引擎</h2>\n<h3 id=\"myisam\"><a class=\"markdownIt-Anchor\" href=\"#myisam\">#</a> MyISAM</h3>\n<pre><code>特征：\n    使用三个文件夹表示每个表\n        格式文件-存储表结构的定义（mytable.frm)\n        数据文件-存储表行的内容（mytable.MYD)\n        索引文件-存储表上的索引（mytable.MYI) ：索引是一本数的目录，缩小扫描范围，提高效率\n    可被转换为压缩、只读表来节省空间\n\n优点：可被转换为压缩、只读表来节省空间\n缺点：不支持事务机制，安全性低\n</code></pre>\n<h3 id=\"innodb\"><a class=\"markdownIt-Anchor\" href=\"#innodb\">#</a> InnoDB</h3>\n<pre><code>Mysql默认的存储引擎，同时也是一个重量级的存储引擎\n主要特点：非常安全\n    InnoDB支持事务\n    支持数据库崩溃后自动回复机制\n\n特征：\n    1. 每个InnoDB表在数据库目录中以.frm格式文件表示\n    2. InnoDB表空间tablespace被用于存储表的内容\n    3. 提供一组用于记录事务特性活动的日志文件\n    4. 用commit（提交）、savepoint 及 rollback（回滚）支持事务处理\n    5. 提供全ACID兼容\n    6. 在Mysql服务器崩溃后提供自动恢复\n    7. 多版本（MVCC）和行级锁定\n    8. 支持外键及引用的完整性，包括级联删除和更新\n    \n优点：支持事务\n    以保证数据的安全。\n缺点：\n    1. 效率不是很高\n    2. 不能压缩\n    3. 不能转换为只读\n    4. 不能很好的节省存储空间\n</code></pre>\n<h3 id=\"memory\"><a class=\"markdownIt-Anchor\" href=\"#memory\">#</a> MEMORY</h3>\n<pre><code>内存存储引擎（别名堆引擎）\n\n使用MEMORY存储引擎的表，其数据存储在内存中，且长度固定\n这俩个特点使得MEMORY存储引擎非常快\n\n特征：\n    1. 在数据库目录中，每个表都以.frm 格式的文件表示\n    2. 表数据和索引被存储在内存中（目的：查询快）\n    3. 表级锁机制\n    4. 不能包含 TEXT 或 BLOB 字段\n\nMEMORY 存储引擎以前被称为HEAP引擎。\n\n优点：查询效率最高\n缺点：不安全，关机后数据消失，因为数据和索引都是存储在内存当中\n</code></pre>\n<h2 id=\"注意对于一张表来说只要是主键或者加有unique约束的字段上会自动创建索引\"><a class=\"markdownIt-Anchor\" href=\"#注意对于一张表来说只要是主键或者加有unique约束的字段上会自动创建索引\">#</a> 注意：对于一张表来说，只要是主键，或者加有 unique 约束的字段上会自动创建索引。</h2>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/",
            "title": "事务",
            "date_published": "2024-02-18T08:13:45.004Z",
            "content_html": "<h1 id=\"事务\"><a class=\"markdownIt-Anchor\" href=\"#事务\">#</a> 事务</h1>\n<p>什么是事务？<br>\n一个事务就是一个完整的业务逻辑。<br>\n是一个最小的工作单元。</p>\n<pre><code>例如转账的业务逻辑，就是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。\n</code></pre>\n<p>本质：就是多条 DML 语句同时成功或者同时失败</p>\n<p><strong>只有 DML 语句和事务有关系，其他语句无关。</strong><br>\ninsert<br>\nupdate<br>\ndelete<br>\n 因为以上三个语句是操作数据库中数据的</p>\n<p>事务是怎么做到同时成功或者同时失败的？</p>\n<pre><code>InnoDB：提供一组用于记录事务特性活动的日志文件\n\n在事务执行的过程中，每一条DML的操作都会被记录到“事务特性活动的日志文件”中\n</code></pre>\n<p><strong>在事务执行的过程中，可以提交事务，也可以回滚事务</strong></p>\n<pre><code>提交事务： 清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中\n    标志着事务的结束，并且是一种全部成功的结束\n\n回滚事务： 将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件\n    回滚事务标志着事务的结束，并且是一种全部失败的结束\n</code></pre>\n<h2 id=\"提交事务-回滚事务\"><a class=\"markdownIt-Anchor\" href=\"#提交事务-回滚事务\">#</a> 提交事务、回滚事务</h2>\n<pre><code>提交事务：commit\n回滚事务：rollback (回滚只能回滚到上一次的提交点)\n\n事务对应的单词：transaction\n\nMysql中默认情况下是自动提交事务的（自动提交）\n\n开启事务\n    start transaction;\n</code></pre>\n<h2 id=\"事务特性\"><a class=\"markdownIt-Anchor\" href=\"#事务特性\">#</a> 事务特性</h2>\n<pre><code>A：原子性\n    说明事务是最小工作单元，不可再分\n\nC：一致性\n    所有事务要求，在同一个事务中，所有操作必须同时成功，或者同时失败，以保证数据的一致性\n\nI：隔离性\n    A事务和B事务之间具有一定的隔离\n\nD：持久性\n    事务最终结束的一个保障，事务提交，将没有保存到硬盘上的数据保存到硬盘上\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/15.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/15.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
            "title": "数据类型",
            "date_published": "2024-02-18T08:13:44.996Z",
            "content_html": "<h1 id=\"mysql-数据类型\"><a class=\"markdownIt-Anchor\" href=\"#mysql-数据类型\">#</a> Mysql 数据类型</h1>\n<pre><code>varchar\n    可变长度的字符串\n    比较智能，节省空间\n    会根据实际长度，动态的分配空间\n\n    缺点：需要动态分配空间，速度慢\n    优点：节省空间\n\nchar\n    定长字符串\n    不管实际长度是多少\n    分配固定长度的空间去存储数据\n    使用不恰当的时候，可能导致空间浪费\n\n    缺点：使用不当，可能导致空间浪费\n    优点：不需要动态分配空间，速度快\n\nint\n\nbigint\n\nfloat\n\ndouble\n\ndate\n    短日期类型\n\ndatetime\n    长日期类型\n\nclob\n    字符大对象\n    最多存储4g的字符串\n    比如：存储一篇文章\n    超过255个字符的，尽量都使用clob\n    Character Large Object: clob\n\nblob\n    存储二进制对象\n    图片，声音，视频，等流媒体数据\n    往blob字段中插入数据时，需要使用IO流。\n\ndate\n    短日期：只包括 年月日\n\n    Mysql默认格式：可以将该格式的时间字符串直接插入到date类型的字段中\n    %Y-%m-%d\n\n\ndatetime\n    长日期：包括 年月日时分秒\n\n    Mysql默认格式：可以将该格式的时间字符串直接插入到date类型的字段中\n    %Y-%m-%d %h:%i:%s\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/16.DML/DML/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/16.DML/DML/",
            "title": "DML",
            "date_published": "2024-02-18T08:13:44.996Z",
            "content_html": "<h1 id=\"insert\"><a class=\"markdownIt-Anchor\" href=\"#insert\">#</a> insert</h1>\n<pre><code>// 根据字段名，插入数据\n// 注意： 字段名和值要一一对应\ninsert into 表名(字段名1,字段名2...) values(值1,值2...);\n\n\n//表示插入所有字段\ninsert into 表名 values(值1,值2...);\n\n// 一次插入多条数据，用逗号隔开\ninsert into test values(1, '张三', '1999-12-13'), (2, '李四', '2000-01-02');\n</code></pre>\n<h2 id=\"将查询结果插入到一张表\"><a class=\"markdownIt-Anchor\" href=\"#将查询结果插入到一张表\">#</a> 将查询结果插入到一张表</h2>\n<pre><code>快速创建dept_bak表，同时数据也存入了dept_bak表中。\ncreate table dept_bak as select * from dept;\n\n将查询到的结果insert into到dept_bak表中\ninsert into dept_bak select * from dept;\n</code></pre>\n<h1 id=\"update\"><a class=\"markdownIt-Anchor\" href=\"#update\">#</a> update</h1>\n<pre><code>update 表名 set 字段名1 = 值1, 字段名2 = 值2 where 条件;\n</code></pre>\n<h1 id=\"delete\"><a class=\"markdownIt-Anchor\" href=\"#delete\">#</a> delete</h1>\n<pre><code>delete from 表名 where 条件;\n\n原理：\n表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放\n\n优点：支持回滚，可以恢复\n缺点：删除效率低\n</code></pre>\n<h2 id=\"快速删除表\"><a class=\"markdownIt-Anchor\" href=\"#快速删除表\">#</a> 快速删除表</h2>\n<pre><code>truncate 语句删除数据（属于DDL）\n    删除效率高，表被一次截断，物理删除\n\n    优点：效率高，快\n    缺点：不支持回滚\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/17.%E7%BA%A6%E6%9D%9F/%E7%BA%A6%E6%9D%9F/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/17.%E7%BA%A6%E6%9D%9F/%E7%BA%A6%E6%9D%9F/",
            "title": "约束",
            "date_published": "2024-02-18T08:13:44.996Z",
            "content_html": "<h1 id=\"约束\"><a class=\"markdownIt-Anchor\" href=\"#约束\">#</a> 约束</h1>\n<h2 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h2>\n<pre><code>constraint，在创建表的时候，创建一些约束，保证表中数据的完整性、有效性\n</code></pre>\n<h2 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用</h2>\n<pre><code>保证表中的数据有效。\n</code></pre>\n<h3 id=\"非空约束\"><a class=\"markdownIt-Anchor\" href=\"#非空约束\">#</a> 非空约束</h3>\n<pre><code>not null：字段值不能为NULL\n\ncreate table student(\n    id int,\n    name varchar(50) not null   // 只有列级 '非空约束'，没有表级 '非空约束'\n);\n</code></pre>\n<h3 id=\"唯一性约束\"><a class=\"markdownIt-Anchor\" href=\"#唯一性约束\">#</a> 唯一性约束</h3>\n<pre><code>unique:字段值不能重复，但可以为NULL（可以有多条NULL值）\n\ncreate table student(\n    id int,\n    name varchar(50) unique\n);\n\n案例：\nmysql&gt; select * from student;\n+------+------+\n| id   | name |\n+------+------+\n|    1 | z    |\n|    1 | NULL |\n|    1 | NULL |\n|    1 | NULL |\n|    1 | NULL |\n|    1 | NULL |\n+------+------+\n6 rows in set (0.00 sec)\n\nmysql&gt; desc student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int         | YES  |     | NULL    |       |\n| name  | varchar(50) | YES  | UNI | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n2 rows in set (0.00 sec)\n</code></pre>\n<h4 id=\"建立多个字段唯一性约束\"><a class=\"markdownIt-Anchor\" href=\"#建立多个字段唯一性约束\">#</a> 建立多个字段唯一性约束</h4>\n<pre><code>1. 多字段各自唯一性约束\ncreate table student(\n    id int unique,\n    name varchar(50) unique // 列级约束\n);\n上边的表，id 和 name 字段各自有唯一性约束，互不影响。\n\n2. 多字段组合后唯一性约束\ncreate table student(\n    id int,\n    name varchar(50),\n    unique(id, name)    // 表级约束\n);\n上边的表，id 和 name 字段联合起来唯一。\n</code></pre>\n<h3 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h3>\n<pre><code>在Mysql中，如果一个字段同时被 not null 和 unique 约束的话，该字段自动成为主键。（Oracle中不一样）\n</code></pre>\n<h3 id=\"主键约束\"><a class=\"markdownIt-Anchor\" href=\"#主键约束\">#</a> 主键约束</h3>\n<pre><code>primary key\n\n主键值是每一行的唯一标识\n主键特征：unique + not null\n\n写法一：列级约束\ncreate table student(\n    id int primary key,\n    name varchar(255)\n);\n\n写法二：表级约束\ncreate table student(\n    id int,\n    name varchar(255),\n    primary key(id)\n);\n</code></pre>\n<h4 id=\"多个字段建立主键约束\"><a class=\"markdownIt-Anchor\" href=\"#多个字段建立主键约束\">#</a> 多个字段建立主键约束</h4>\n<pre><code>// 复合主键\ncreate table student(\n    id int,\n    name varchar(255),\n    primary key(id, name)\n);\n\n//错误 一张表不能建立多个主键\n    create table student(\n    id int primary key,\n    name varchar(255) primary key\n);\n</code></pre>\n<h4 id=\"mysql中自然主键\"><a class=\"markdownIt-Anchor\" href=\"#mysql中自然主键\">#</a> Mysql 中自然主键</h4>\n<pre><code>create table student(\n    id int primary key auto_increment,  // 从 1 开始递增\n    name varchar(255)\n);\n</code></pre>\n<h3 id=\"外键约束\"><a class=\"markdownIt-Anchor\" href=\"#外键约束\">#</a> 外键约束</h3>\n<pre><code> foreign key\n\ncreate table t_class(\n    t_id int primary key auto_increment,\n    t_name varchar(50)\n);\n\ncreate table student(\n    id int primary key auto_increment,\n    name varchar(255),\n    cno int,\n    foreign key (cno) references t_class(t_id)\n);\n</code></pre>\n<p>注意：子表中的外键引用父表中的某个字段，被引用的这个字段不一定是主键，但是至少有 unique 约束。（否则，子表不能确定引用的是父表中的那条数据）</p>\n<p><strong>注意：外键可以为 NULL</strong></p>\n<h3 id=\"检查性约束\"><a class=\"markdownIt-Anchor\" href=\"#检查性约束\">#</a> 检查性约束</h3>\n<pre><code>check(Mysql 不支持， Oracle支持)\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/13.%E5%88%86%E9%A1%B5/limit/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/13.%E5%88%86%E9%A1%B5/limit/",
            "title": "Mysql中limit",
            "date_published": "2024-02-18T08:13:44.988Z",
            "content_html": "<h1 id=\"limit\"><a class=\"markdownIt-Anchor\" href=\"#limit\">#</a> limit</h1>\n<h2 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用</h2>\n<pre><code>将查询结果集的一部分取出来，通常用在分页中。\n</code></pre>\n<h2 id=\"语法\"><a class=\"markdownIt-Anchor\" href=\"#语法\">#</a> 语法</h2>\n<pre><code>limit startIndex, length\nstartIndex: 起始下标，从0开始\nlength: 长度\n\n缺省用法：limit length\nlength: 长度\n</code></pre>\n<p>案例：按照薪资降序，取出前五名员工。</p>\n<pre><code>\n缺省用法：\n\nselect\n    ename, sal\nfrom\n    emp\norder by\n    sal desc\nlimit 5;\n\n完整用法：\n\nselect\n    ename, sal\nfrom\n    emp\norder by\n    sal desc\nlimit 5;\n\n</code></pre>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<pre><code>在mysql中，limit是在order by之后执行的。\n</code></pre>\n<h1 id=\"分页\"><a class=\"markdownIt-Anchor\" href=\"#分页\">#</a> 分页</h1>\n<pre><code>limit (pageNum - 1) * pageSize, pageSize;\n</code></pre>\n<h2 id=\"offset\"><a class=\"markdownIt-Anchor\" href=\"#offset\">#</a> offset</h2>\n<pre><code>作用同limit，配合limit使用，注意：limit此时只能有一个参数\n\nlimit pageSize, offset (pageNum - 1) * pageSize;\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/14.DDL/DDL/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/14.DDL/DDL/",
            "title": "DDL",
            "date_published": "2024-02-18T08:13:44.988Z",
            "content_html": "<h1 id=\"ddl-语句\"><a class=\"markdownIt-Anchor\" href=\"#ddl-语句\">#</a> DDL 语句</h1>\n<pre><code>create、drop、alter\n</code></pre>\n<h2 id=\"create-建表\"><a class=\"markdownIt-Anchor\" href=\"#create-建表\">#</a> create 建表</h2>\n<pre><code>语法格式：\ncreate table 表名 (\n    字段名 数据类型,\n    字段名 数据类型,\n    ...\n    字段名 数据类型 //切记！！！   最后一句没有标点符号\n);\n</code></pre>\n<h3 id=\"快速创建表\"><a class=\"markdownIt-Anchor\" href=\"#快速创建表\">#</a> 快速创建表</h3>\n<pre><code>create table emp2 as select * from emp;\n原理：\n    将一个查询结果当作一张表新建\n    可以快速创建一张表，同时数据也存在。\n\ncreate table emp2 as select * from emp where ename = 'SMITH';\n注意：查询语句可以添加条件等。\n</code></pre>\n<h2 id=\"drop-删表\"><a class=\"markdownIt-Anchor\" href=\"#drop-删表\">#</a> drop 删表</h2>\n<pre><code>语法格式：\ndrop table 表名;    //当表不存在时，会报错\ndrop table if exists 表名;  // 当表存在的话，删除\n</code></pre>\n<h2 id=\"alter-对表结构修改\"><a class=\"markdownIt-Anchor\" href=\"#alter-对表结构修改\">#</a> alter 对表结构修改</h2>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql子查询",
            "date_published": "2024-02-18T08:13:44.979Z",
            "content_html": "<h1 id=\"子查询\"><a class=\"markdownIt-Anchor\" href=\"#子查询\">#</a> 子查询</h1>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<pre><code>select语句中嵌套select语句，被嵌套的select语句被称为子查询。\n</code></pre>\n<h2 id=\"子查询可以出现的位置\"><a class=\"markdownIt-Anchor\" href=\"#子查询可以出现的位置\">#</a> 子查询可以出现的位置</h2>\n<pre><code>select\n    ..(select子).\nfrom\n    ..(select子).\nwhere\n    ..(select子).\n</code></pre>\n<h2 id=\"where子句中的子查询\"><a class=\"markdownIt-Anchor\" href=\"#where子句中的子查询\">#</a> where 子句中的子查询</h2>\n<p>案例：找出比最低工资高的员工的姓名和薪资。</p>\n<pre><code>\nselect \n    ename, sal\nfrom\n    emp\nwhere\n    sal &gt; (select min(sal) from emp);\n\n</code></pre>\n<h2 id=\"from-子查询\"><a class=\"markdownIt-Anchor\" href=\"#from-子查询\">#</a> from 子查询</h2>\n<pre><code>from后边的子查询，可以当作一张临时的表。\n</code></pre>\n<p>案例：找出每个岗位的平均工资的薪资等级</p>\n<pre><code>\nselect\n    t.*, sg.grade\nfrom\n    (select job, avg(sal) as avgsal from emp group job) t\njoin\n    salgrade\non\n    t.avgsal between sg.losal and hisal;\n\n</code></pre>\n<h2 id=\"select-子查询\"><a class=\"markdownIt-Anchor\" href=\"#select-子查询\">#</a> select 子查询</h2>\n<p>案例：找出每个员工的部门名称，要求显示员工姓名，部门名称。</p>\n<pre><code>\nselect\n    e.ename, (select d.ename from dept e where e.deptno = d.deptno) as dname\nfrom\n    emp e;\n\n</code></pre>\n<h3 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h3>\n<pre><code>在select语句中的子查询，这个子查询语句只能一次返回一条结果，多于一条，就报错了。\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/3.%E5%A4%96%E8%BF%9E%E6%8E%A5/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/3.%E5%A4%96%E8%BF%9E%E6%8E%A5/",
            "title": "Mysql外连接",
            "date_published": "2024-02-18T08:13:44.979Z",
            "content_html": "<h1 id=\"外连接\"><a class=\"markdownIt-Anchor\" href=\"#外连接\">#</a> 外连接</h1>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<pre><code>外连接当中，两张表关联查询产生主次关系。\n左连接和右连接可以相互切换。（\n    1. 任何一个左连接都有一个右连接的写法。\n    2. 任何一个右连接都有一个左连接的写法。\n    ）\n</code></pre>\n<h2 id=\"右外连接\"><a class=\"markdownIt-Anchor\" href=\"#右外连接\">#</a> 右外连接</h2>\n<p>right 代表，将右边的表看作主表，主要是将这张主表的内容全部查出来，捎带着关联查询左边的表</p>\n<pre><code>\n                                          outer可以省略\nselect e.ename, d.ename from emp e right [outer] join dept d on e.deptno = e.deptno;\n\n</code></pre>\n<h2 id=\"左外连接\"><a class=\"markdownIt-Anchor\" href=\"#左外连接\">#</a> 左外连接</h2>\n<p>left 代表，将左边的表看作主表，和右外连接相反。</p>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<pre><code>外连接的查询结果条数一定是 &gt;= 内连接的查询结果条数\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/4.%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/4.%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql多表连接查询",
            "date_published": "2024-02-18T08:13:44.979Z",
            "content_html": "<h1 id=\"多表连接查询\"><a class=\"markdownIt-Anchor\" href=\"#多表连接查询\">#</a> 多表连接查询</h1>\n<pre><code>语法：\nselect\n    ...\nfrom\n    a\njoin                    // 内连接\n    b\non\n    a表和b表的连接条件\njoin                    // 内连接\n    c\non\n    a表和c表的连接条件\nright join              // 外连接\n    d\non\n    a和d的连接条件\n</code></pre>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<p><strong>一条 SQL 中内连接和外连接可以混合，都可以出现！</strong></p>\n<p>案例：找出每个员工的部门名称，以及工资等级，要求显示员工名，部门名，薪资，薪资等级。</p>\n<pre><code>\nselect \n    e.ename, d.ename, e.sal, sg.grade \nfrom \n    emp e \njoin \n    dept d \non \n    e.deptno = d.deptno \njoin \n    salgrade sg \non \n    e.sal between sg.losal and hisal;\n\n</code></pre>\n<p>案例：找出每个员工的部门名称，以及工资等级，要求显示员工名，领导名，部门名，薪资，薪资等级。</p>\n<pre><code>\nselect \n    e.ename, d.ename, e.sal, sg.grade \nfrom \n    emp e \njoin \n    dept d \non \n    e.deptno = d.deptno \njoin \n    salgrade sg \non \n    e.sal between sg.losal and hisal\nleft outer join\n    emp l\non\n    e.mgr = l.empno;\n\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/6.union/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/6.union/",
            "title": "Mysql中union",
            "date_published": "2024-02-18T08:13:44.979Z",
            "content_html": "<h1 id=\"union\"><a class=\"markdownIt-Anchor\" href=\"#union\">#</a> union</h1>\n<h2 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用</h2>\n<pre><code>合并查询结果集\n</code></pre>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<pre><code>union的效率更高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。\n但是union可以减少匹配次数。\n在减少匹配次数的情况下，还可以完成两个结果的拼接。\n\n例如：a 连接 b 连接 c\na: 10条记录\nb: 10条记录\nc: 10条记录\n匹配次数为 : 10*10*10 = 1000\n\n如果改为union\na 连接 b ： 10*10 = 100\na 连接 c ： 10*10 = 100\n100 + 100 = 200次（union把乘法变成了加法运算）\n</code></pre>\n<p>案例：查询工作岗位是 ‘MANAGER’ 和 ‘SALESMAN’ 的员工</p>\n<pre><code>\n第一种方法：or\n第二种方法：in\n第三种方法：union\nselect ename from emp where job = 'MANAGER'\nunion\nselect ename from emp where job = 'SALESMAN';\n\n</code></pre>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意：</h2>\n<p>在使用 union 需要注意：<br>\n1.  union 在结果集合并的时候，要求两个结果列数相同。<br>\n2.  MYSQL 中，对应列的数据类型可以不相同，Oracle 里会报错（会要求对应列的数据类型相同）。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/",
            "title": "Mysql中Distinct去重",
            "date_published": "2024-02-18T08:13:44.971Z",
            "content_html": "<h1 id=\"distinct-去重\"><a class=\"markdownIt-Anchor\" href=\"#distinct-去重\">#</a> Distinct 去重</h1>\n<p>把查询结果去除重复记录</p>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h2>\n<ol>\n<li>distinct 只能出现在所有字段的最前方。<br>\nselect name, distinct job from emp;// 错误<br>\n select distinct name, job from emp;// 正确<br>\n这样表示对 name 和 job 组合起来进行去重。</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/",
            "title": "Mysql连接查询",
            "date_published": "2024-02-18T08:13:44.971Z",
            "content_html": "<h1 id=\"什么是连接查询\"><a class=\"markdownIt-Anchor\" href=\"#什么是连接查询\">#</a> 什么是连接查询</h1>\n<pre><code>从一张表中单独查询，称为单表查询。\nemp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，称为连接查询。\n</code></pre>\n<h1 id=\"连接查询分类\"><a class=\"markdownIt-Anchor\" href=\"#连接查询分类\">#</a> 连接查询分类</h1>\n<pre><code>根据语法的年代分类：\n    1.  SQL92：1992年出现的语法。\n    2.  SQL99：1999年出现的语法。\n\n根据表连接的方式分类：\n    1. 内连接\n       1. 等值连接\n       2. 非等值连接\n       3. 自连接\n    2. 外连接\n       1. 左外连接（左连接）\n       2. 右外连接（右连接）\n    3. 全连接\n</code></pre>\n<h1 id=\"笛卡尔积现象\"><a class=\"markdownIt-Anchor\" href=\"#笛卡尔积现象\">#</a> 笛卡尔积现象</h1>\n<pre><code>当两张表进行连接查询，没有任何条件限制的时候，最终的查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。（一个数学现象）\n</code></pre>\n<pre><code>\n     select up.id uId, qd.id qId from user_profile up, question_detail qd;\n\n    +-----+-----+\n    | uId | qId |\n    +-----+-----+\n    |   7 |   1 |\n    |   6 |   1 |\n    |   5 |   1 |\n    |   4 |   1 |\n    |   3 |   1 |\n    |   2 |   1 |\n    |   1 |   1 |\n    |   7 |   2 |\n    ...\n     112 rows in set (0.00 sec)\n\n</code></pre>\n<h2 id=\"避免笛卡尔积现象\"><a class=\"markdownIt-Anchor\" href=\"#避免笛卡尔积现象\">#</a> 避免笛卡尔积现象</h2>\n<pre><code>增加表连接时的条件。\n</code></pre>\n<pre><code>\n    select up.id uId, qpd.id qId from user_profile up,  question_practice_detail qpd where up.device_id = qpd.device_id;\n\n    +-----+-----+\n    | uId | qId |\n    +-----+-----+\n    |   1 |   1 |\n    |   2 |   2 |\n    |   2 |   3 |\n    |   3 |   4 |\n    |   4 |   5 |\n    |   4 |   6 |\n    |   4 |   7 |\n    |   2 |   8 |\n    |   2 |   9 |\n    |   3 |  10 |\n    |   4 |  11 |\n    |   4 |  12 |\n    |   4 |  13 |\n    |   2 |  14 |\n    |   2 |  15 |\n    |   3 |  16 |\n    +-----+-----+\n    16 rows in set (0.00 sec)\n\n</code></pre>\n<pre><code>重点：最终查询结果是16条，但是在匹配中，匹配的次数没有减少，仍然是112次。只不过进行了筛除，匹配的次数并没有减少！！！\n</code></pre>\n<p>注意：通过观察笛卡尔积现场得出，表的连接次数越多（连接的表越多）程序执行效率越低，应避免表的连接次数过多。</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/2.%E5%86%85%E8%BF%9E%E6%8E%A5/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/2.%E5%86%85%E8%BF%9E%E6%8E%A5/",
            "title": "Mysql内连接",
            "date_published": "2024-02-18T08:13:44.971Z",
            "content_html": "<h1 id=\"内连接\"><a class=\"markdownIt-Anchor\" href=\"#内连接\">#</a> 内连接</h1>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<pre><code>完全能够匹配上这个条件的数据查询出来。\nA，B两张表连接查询，AB两张表没有主次关系，是平等的。\n</code></pre>\n<h2 id=\"等值连接\"><a class=\"markdownIt-Anchor\" href=\"#等值连接\">#</a> 等值连接</h2>\n<pre><code>\nSQL92语法：\n\nselect up.id uId, qpd.id qId from user_profile up, question_practice_detail qpd where up.device_id = qpd.device_id;\n\nSQL99语法：\n                                                  [inner] 单词可以省略\nselect up.id uId, qpd.id qId from user_profile up [inner] join question_practice_detail qpd on up.device_id = qpd.device_id;\n\n</code></pre>\n<p>SQL92 语法缺点：结构不清晰，表的连接条件和后期进一步的筛选条件，都放到了 where 后边。</p>\n<p>SQL99 语法有点：表连接的条件是独立的，连接之后如果还需要进一步筛选，可以继续添加 where 条件。</p>\n<h2 id=\"非等值连接\"><a class=\"markdownIt-Anchor\" href=\"#非等值连接\">#</a> 非等值连接</h2>\n<pre><code>条件不是一个等量关系，称为非等值连接\n</code></pre>\n<pre><code>\n案例：找出每个员工的薪资等级，要求显示员工名，薪资，薪资等级\n\n    select \n        e.ename, e.sal, s.grade \n    from\n        emp e\n    inner join \n        salgrade s\n    on \n        e.sal between s.losal and s.hisal;\n\n</code></pre>\n<h2 id=\"自连接\"><a class=\"markdownIt-Anchor\" href=\"#自连接\">#</a> 自连接</h2>\n<pre><code>一张表看作两张表\n</code></pre>\n<pre><code>\n案例：查询员工的上级领导，要求显示员工名和对应的领导名\n    select \n        a.ename as '员工名', b.ename as '领导名'\n    from\n        emp a \n    inner join\n        emp b\n    on\n        a.mgr = b.empno;\n\n\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/10.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/10.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/",
            "title": "Mysql执行顺序",
            "date_published": "2024-02-18T08:13:44.962Z",
            "content_html": "<h1 id=\"执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#执行顺序\">#</a> 执行顺序</h1>\n<pre><code>select\n    ...\nfrom \n    ...\nwhere\n    ...\ngroup by\n    ...\nhaving\n    ...\norder by\n    ...\n\n执行顺序：\n1.  from\n2.  where\n3.  group by\n4.  having\n5.  select\n6.  order by\n</code></pre>\n<p>从某张表查询数据，<br>\n先经过 where 条件筛选出有价值的数据，<br>\n对这些数据进行分组，<br>\n分组后可以使用 having 继续筛选数据<br>\n select 查询出来<br>\n最后排序输出</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/",
            "title": "Mysql概述",
            "date_published": "2024-02-18T08:13:44.962Z",
            "content_html": "<p>1. 什么是数据库？什么是数据库管理系统？什么是 SQL？他们之间的关系是什么？</p>\n<p>​\t数据库：</p>\n<p>​\t\t英文单词 DataBase，简称 DB。按照一定格式存储数据的一些文件的组合。</p>\n<p>​\t\t顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</p>\n<p>​\t数据库管理系统：</p>\n<p>​\t\tDataBaseManagement，简称 DBMS。</p>\n<p>​\t\t数据库管理系统是专门用来管理数据库中的数据，数据库管理系统可以对数据库当中的数据进行增删改查。</p>\n<p>​\t常见的数据库管理系统：</p>\n<p>​\t\tMysql，Oracle，MS，SqlServer，DB2，sybase 等。。。。。。</p>\n<p>​\tSQL:</p>\n<p>​\t\t结构化查询语言。程序员需要学习 SQL 语句，程序员通过编写 SQL 语句，然后 DBMS 负责执行 SQL 语句，最终来完成数据库中数据的增删改查操作。</p>\n<p>​\t\tSQL 是一套标准，主要学习的就是 SQL 语句。这个 SQL 在 mysql 中可以使用，同时在 Oracle 中也可以使用，在 DB2 中也可以使用。</p>\n<p>​\t三者之间的关系：</p>\n<p>​\t\tDBMS–&gt; 执行–&gt;SQL–&gt; 操作–&gt;DB</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/",
            "title": "Mysql实用技巧",
            "date_published": "2024-02-18T08:13:44.954Z",
            "content_html": "<h2 id=\"在sql中的应用\"><a class=\"markdownIt-Anchor\" href=\"#在sql中的应用\">#</a> @ 在 sql 中的应用</h2>\n<p>@ 是用户变量， @@ 是系统变量</p>\n<pre><code>select @a;\n</code></pre>\n<p>@变量名：定义一个用户变量</p>\n<p>= 对该用户变量进行赋值<br>\n用户变量的赋值有两种方式：</p>\n<ol>\n<li>直接使用 =</li>\n<li>使用 :=<br>\n 区别在于：使用 set 命令对用户变量进行赋值时，两种方式都适用，<br>\n使用 select 语句时，只能使用 ‘:=’ 方式，因为 select 语句中， '=' 被看作时比较操作符<br>\n (@i := @i + 1)</li>\n</ol>\n<h3 id=\"常量-的用法\"><a class=\"markdownIt-Anchor\" href=\"#常量-的用法\">#</a> 常量 @ 的用法</h3>\n<ol>\n<li>\n<p>赋值操作<br>\n select @i := 0 a, @c := 1 b, @b := @i + @c f;<br>\n<img data-src=\"/image/%E5%90%8E%E7%AB%AF/Mysql/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240126185135.png\" alt=\"赋值操作\"></p>\n</li>\n<li>\n<p>作为临时表使用<br>\n select *, (select @i := 0 s1) z1 from admin,(select @i := 0 s2) z2;<br>\n<img data-src=\"/image/%E5%90%8E%E7%AB%AF/Mysql/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240126185503.png\" alt=\"作为临时表使用\"></p>\n</li>\n<li>\n<p>数据累计计算<br>\n select *, (@i := @i + 1) as i from user,(select @i := 0) t;<br>\n<img data-src=\"/image/%E5%90%8E%E7%AB%AF/Mysql/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240126185916.png\" alt=\"数据累计计算\"><br>\n每行的行号通过 @i 展示了出来</p>\n</li>\n</ol>\n",
            "tags": [
                "Mysql"
            ]
        }
    ]
}