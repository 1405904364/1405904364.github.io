<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://1405904364.github.io</id>
    <title>Live My Life • Posts by &#34;mysql&#34; tag</title>
    <link href="http://1405904364.github.io" />
    <updated>2023-08-31T01:30:35.883Z</updated>
    <category term="Java" />
    <category term="webService" />
    <category term="maven" />
    <category term="Mysql" />
    <category term="Sql" />
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/6.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/</id>
        <title>Mysql综合案例</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/6.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找出工资在 1250 到 3000 之间的员工信息，要求按照薪资降序排列。&lt;/p&gt;
&lt;p&gt;select ename, sal&lt;/p&gt;
&lt;p&gt;​	from emp&lt;/p&gt;
&lt;p&gt;​	where sal between 1250 and 3000&lt;/p&gt;
&lt;p&gt;order by sal desc;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上语句的执行顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;from&lt;/li&gt;
&lt;li&gt;where&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;li&gt;order by (排序总是在最后执行的！！！)&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:30:35.883Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/5.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/</id>
        <title>Mysql排序</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/5.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询所有员工薪资，排序&lt;/p&gt;
&lt;p&gt;select ename,sal from emp order by sal;// 默认升序&lt;/p&gt;
&lt;p&gt;select ename,sal from emp order by sal asc;// 指定 ASC 升序&lt;/p&gt;
&lt;p&gt;select ename,sal from emp order by sal desc;// 指定 DESC 降序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个字段进行排序&lt;/p&gt;
&lt;p&gt;例如：查询员工名字和薪资，要求按照薪资升序，如果薪资相同，再按照名字升序排列。&lt;/p&gt;
&lt;p&gt;select ename, sal from emp order by sal asc, ename asc;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据字段位置进行排序&lt;/p&gt;
&lt;p&gt;例如：按照查询结果的第 2 列 sal 进行排序。&lt;/p&gt;
&lt;p&gt;select ename, sal from emp order by 2;&lt;/p&gt;
&lt;p&gt;注意：不建议在开发中这样写，因为不健壮。&lt;/p&gt;
&lt;p&gt;因为列的顺序很容易发生改变，列顺序修改之后，2 就废了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序采用 order by 子句，order by 后面跟上排序字段，排序可以放多个，多个可以采用逗号（,）间隔，order by 默认采用升序，如果存在 where 子句那么 order by 必须放到最后面。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:30:35.876Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</id>
        <title>简单的查询语句</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询一个字段&lt;/p&gt;
&lt;p&gt;select 字段名 from 表名；&lt;/p&gt;
&lt;p&gt;其中要注意：&lt;/p&gt;
&lt;p&gt;​	select 和 from 都是关键字。&lt;/p&gt;
&lt;p&gt;​	字段名和表名都是标识符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强调：对于 SQL 语句来说，是通用的。所有的 SQL 语句以 &amp;quot;;&amp;quot; 结尾。另外 SQL 语句不区分大小写，都行。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询多个字段&lt;/p&gt;
&lt;p&gt;使用逗号隔开 &amp;quot;,&amp;quot;&lt;/p&gt;
&lt;p&gt;select deptno,dname from dept;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询所有字段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以把每个字段都写上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用 *&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;效率低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可读性差&lt;/p&gt;
&lt;p&gt;在实际开发中不建议。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给查询的列起别名&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 as 关键字起别名。&lt;/p&gt;
&lt;p&gt;select deptno, dname as deptname from dept;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;省略 as 关键字。&lt;/p&gt;
&lt;p&gt;select deptno, dname deptname from dept;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;起别名的时候，别名中有空格，怎么办？&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;select deptno, dname dept name from dept;&lt;/p&gt;
&lt;p&gt;DBMS 会进行 SQL 编译，检查出不符合 SQL 语法，编译报错。&lt;/p&gt;
&lt;p&gt;解决:&lt;/p&gt;
&lt;p&gt;​	select deptno, dname ‘dept name’ from dept;// 加单引号&lt;/p&gt;
&lt;p&gt;​	select deptno, dname “dept name” from dept;// 加双引号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准。双引号在 oracle 数据库中用不了。但是在 mysql 中可以使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再次强调：数据库中的字符串都是采用单引号括起来。这是标准的，双引号不标准。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二列参与数学运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#二列参与数学运算&#34;&gt;#&lt;/a&gt; 二：列参与数学运算&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算员工年薪？sal * 12&lt;/p&gt;
&lt;p&gt;select ename, sal * 12 from emp;// 结论：列可以参与数学运算&lt;/p&gt;
&lt;p&gt;select ename, sal * 12 as ‘年薪’ from emp;// 别名是中文，用单引号括起来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:30:35.869Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql条件查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h2 id=&#34;条件查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#条件查询&#34;&gt;#&lt;/a&gt; 条件查询&lt;/h2&gt;
&lt;p&gt;什么是条件查询？&lt;/p&gt;
&lt;p&gt;不是将表中所有数据都查出来。是查询出来符合条件的。&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;p&gt;​	select 字段 1，字段 2，字段 3 from 表名 where 条件；&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;figcaption data-lang=&#34;SQL&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; 等于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&gt;&lt;/span&gt;或&lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; 不等于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; 小于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;=&lt;/span&gt; 小于等于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; 大于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;=&lt;/span&gt; 大于等于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt; 两个值之间，等同于 &lt;span class=&#34;token operator&#34;&gt;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	注意：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		在使用&lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; 时，必须要遵循左小右大。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		&lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; 是闭区间，包括两端的值。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	例如： &lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;sal &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; sal &lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2450&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	错误写法：&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;sal &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; sal &lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;3000&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2450&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt; 为 &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt; （&lt;span class=&#34;token operator&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt; 不为空）&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;查询那些员工的津贴&lt;span class=&#34;token operator&#34;&gt;/&lt;/span&gt;补助为&lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt;？&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;错误查询：&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; comm &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;正确写法：&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; comm &lt;span class=&#34;token operator&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; 并且&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;查询工作岗位是MANAGER并且工资大于&lt;span class=&#34;token number&#34;&gt;2500&lt;/span&gt;的员工信息？&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;job&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;sal &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; job &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;MANAGER&#39;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; sal&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;2500&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;29&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;or&lt;/span&gt; 或者&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;30&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;查询工作岗位是MANAGER或SALESMAN的员工信息？&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;31&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;job&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;sal &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emo &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; job &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;MANAGER&#39;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;or&lt;/span&gt; job &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;SALESMAN&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;32&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;33&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt; 包含，相当于多个 &lt;span class=&#34;token operator&#34;&gt;or&lt;/span&gt; （&lt;span class=&#34;token operator&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt; 不在这个范围中）&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;34&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;注意：&lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt;不是一个区间。&lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt;后面跟的是具体的值。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;35&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;36&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;not&lt;/span&gt;可以取非，主要用在&lt;span class=&#34;token operator&#34;&gt;is&lt;/span&gt; 或 &lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt; 中&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;37&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;相当于多个 &lt;span class=&#34;token operator&#34;&gt;or&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;38&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;39&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;like&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;like&lt;/span&gt;称为模糊匹配查询，支持&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt; 或下划线匹配&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;40&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt; 匹配任意个字符&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;41&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;下划线，一个下划线只匹配一个字符&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;42&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;找出名字中有下划线的&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;43&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; name &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; t_student &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; name &lt;span class=&#34;token operator&#34;&gt;like&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;%\_%&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;// 使用 \ 转义字符&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;注意： 在数据库中 null 不能使用等号进行衡量。需要使用 is null。因为数据库中的 null 代表什么也没有，它不是一个值，所以不能用等号衡量。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:30:35.864Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/3.%E7%90%86%E8%A7%A3Sql/%E7%90%86%E8%A7%A3Sql/</id>
        <title>理解Sql</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/3.%E7%90%86%E8%A7%A3Sql/%E7%90%86%E8%A7%A3Sql/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;数据库当中最近基本的单元是表：table&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据库当中是以表格的形式表示数据的。因为比较直观。&lt;/p&gt;
&lt;p&gt;任何一张表都有行和列：&lt;/p&gt;
&lt;p&gt;​	行（row）：被称为数据 / 记录。&lt;/p&gt;
&lt;p&gt;​	列（column）：被称为字段。&lt;/p&gt;
&lt;p&gt;每个字段都有：字段名，数据类型，约束等属性。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;关于 SQL 语句的分类&lt;/p&gt;
&lt;p&gt;SQL 语句有很多，最好进行分门别类，这样更容易记忆。&lt;/p&gt;
&lt;p&gt;分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DQL：数据查询语言（凡是带 select 关键字的都是查询语句）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DML：数据操作语言（凡是对表中的数据进行增删改查的都是 DML）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;insert：增&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;update：改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete：删&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;！！！主要操作表中的数据 data。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DDL：数据定义语言（凡是带有 create，drop，alter 的都是 DDL），DDL 主要操作的是表结构。不是表中的数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;alter：修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create：新建，等同于增&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drop：删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;！！！主要对表结构进行操作。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCL：事务控制语言。&lt;/p&gt;
&lt;p&gt;包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务提交：commit;&lt;/li&gt;
&lt;li&gt;事务回滚：rollback;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCL：是数据控制语言。&lt;/p&gt;
&lt;p&gt;例如：授权 grant，撤销权限 revoke…&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:30:35.855Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/2.Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
        <title>Mysql常用命令</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/2.Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;在 windows 操作系统中，怎么使用命令行来启动 Mysql 和关闭 Mysql 服务？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;​	net stop 服务名称；&lt;/p&gt;
&lt;p&gt;​	net start 服务名称；&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;登录 Mysql 数据库&lt;/p&gt;
&lt;p&gt;明文密码登录：mysql -u [用户名] -p [密码]&lt;/p&gt;
&lt;p&gt;隐藏密码登录：mysql -u [用户名] -p + 回车键，然后输入密码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;退出 Mysql&lt;/p&gt;
&lt;p&gt;exit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看数据库有哪些数据库？mysql 默认自带了 4 个数据库&lt;/p&gt;
&lt;p&gt;show databases;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么选择使用哪个数据库？&lt;/p&gt;
&lt;p&gt;use [数据库名]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么创建数据库？&lt;/p&gt;
&lt;p&gt;create database [数据库名];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么查看有哪些表？&lt;/p&gt;
&lt;p&gt;show tables;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么查看表结构？&lt;/p&gt;
&lt;p&gt;desc [表名]&lt;/p&gt;
&lt;p&gt;全写为：&lt;/p&gt;
&lt;p&gt;​	describe [表名]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 sql 文件中的数据导入？&lt;/p&gt;
&lt;p&gt;source [路径]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意路径中不要有中文。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如： source D:\coure\03-Mysql\document\bjpowernode.sql&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看数据库版本号&lt;/p&gt;
&lt;p&gt;select version();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看当前使用的是那个数据库&lt;/p&gt;
&lt;p&gt;select database();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中止输入的 mysql 命令（还未执行的命令）&lt;/p&gt;
&lt;p&gt;\c 用来中止一条命令的输入。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mysql&amp;gt; show&lt;/em&gt;&lt;br&gt;
&lt;em&gt;-&amp;gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;-&amp;gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;-&amp;gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;-&amp;gt; \c&lt;/em&gt;&lt;br&gt;
&lt;em&gt;mysql&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 Mysql 支持那些存储引擎&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;show engines \G;&lt;/p&gt;
&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;查看建表语句&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;show create table 表名；&lt;/p&gt;
&lt;p&gt;！！！以上命令不区分大小写&lt;/p&gt;
&lt;p&gt;！！！注意：Mysql 中命令是不见分号；则不会执行命令。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:30:35.800Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/</id>
        <title>Mysql概述</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/"/>
        <content type="html">&lt;p&gt;1. 什么是数据库？什么是数据库管理系统？什么是 SQL？他们之间的关系是什么？&lt;/p&gt;
&lt;p&gt;​	数据库：&lt;/p&gt;
&lt;p&gt;​		英文单词 DataBase，简称 DB。按照一定格式存储数据的一些文件的组合。&lt;/p&gt;
&lt;p&gt;​		顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。&lt;/p&gt;
&lt;p&gt;​	数据库管理系统：&lt;/p&gt;
&lt;p&gt;​		DataBaseManagement，简称 DBMS。&lt;/p&gt;
&lt;p&gt;​		数据库管理系统是专门用来管理数据库中的数据，数据库管理系统可以对数据库当中的数据进行增删改查。&lt;/p&gt;
&lt;p&gt;​	常见的数据库管理系统：&lt;/p&gt;
&lt;p&gt;​		Mysql，Oracle，MS，SqlServer，DB2，sybase 等。。。。。。&lt;/p&gt;
&lt;p&gt;​	SQL:&lt;/p&gt;
&lt;p&gt;​		结构化查询语言。程序员需要学习 SQL 语句，程序员通过编写 SQL 语句，然后 DBMS 负责执行 SQL 语句，最终来完成数据库中数据的增删改查操作。&lt;/p&gt;
&lt;p&gt;​		SQL 是一套标准，主要学习的就是 SQL 语句。这个 SQL 在 mysql 中可以使用，同时在 Oracle 中也可以使用，在 DB2 中也可以使用。&lt;/p&gt;
&lt;p&gt;​	三者之间的关系：&lt;/p&gt;
&lt;p&gt;​		DBMS–&amp;gt; 执行–&amp;gt;SQL–&amp;gt; 操作–&amp;gt;DB&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:30:35.714Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/9.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql分组查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/9.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h2 id=&#34;分组查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分组查询&#34;&gt;#&lt;/a&gt; 分组查询&lt;/h2&gt;
&lt;h3 id=&#34;sql语句各个关键字的执行顺序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#sql语句各个关键字的执行顺序&#34;&gt;#&lt;/a&gt; SQL 语句各个关键字的执行顺序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select
    ...         5
from
    ...         1
where
    ...         2
group by
    ...         3
having
    ...         4
order by
    ...         6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行顺序：&lt;br&gt;
1. from&lt;br&gt;
2. where&lt;br&gt;
3. group by&lt;br&gt;
4. having&lt;br&gt;
5. select&lt;br&gt;
6. order by&lt;/p&gt;
&lt;h3 id=&#34;重点结论&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#重点结论&#34;&gt;#&lt;/a&gt; 重点结论&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;在一条select语句当中，如果有group by语句的话，select后面只能跟分组函数，以及参加分组的字段。其他的一律不能跟。（Mysql可以执行，但没有意义，Oracle数据库当中会报错）
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.757Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/8.%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E8%A1%8C%E6%95%B0/</id>
        <title>Mysql多行处理行数</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/8.%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E8%A1%8C%E6%95%B0/"/>
        <content type="html">&lt;h2 id=&#34;多行处理行数分组函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多行处理行数分组函数&#34;&gt;#&lt;/a&gt; 多行处理行数（分组函数）&lt;/h2&gt;
&lt;p&gt;特点：输入多行、最终输出一行&lt;/p&gt;
&lt;h4 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;分组函数在使用时必须先进行分组，然后才能使用。
如果你没有对数据进行分组，整张表默认为一组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;count-计数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#count-计数&#34;&gt;#&lt;/a&gt; count 计数&lt;/h3&gt;
&lt;p&gt;计算员工数量总和&lt;br&gt;
 select count (name) from emp;&lt;/p&gt;
&lt;h3 id=&#34;sum-求和&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#sum-求和&#34;&gt;#&lt;/a&gt; sum 求和&lt;/h3&gt;
&lt;p&gt;计算工资合&lt;br&gt;
 select sum (sal) from emp;&lt;/p&gt;
&lt;h3 id=&#34;avg-平均值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#avg-平均值&#34;&gt;#&lt;/a&gt; avg 平均值&lt;/h3&gt;
&lt;p&gt;计算平均工资&lt;br&gt;
 select avg (sal) from emp;&lt;/p&gt;
&lt;h3 id=&#34;max-最大值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#max-最大值&#34;&gt;#&lt;/a&gt; max 最大值&lt;/h3&gt;
&lt;p&gt;找出最高工资&lt;br&gt;
 select max (sal) from emp;&lt;/p&gt;
&lt;h3 id=&#34;min-最小值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#min-最小值&#34;&gt;#&lt;/a&gt; min 最小值&lt;/h3&gt;
&lt;p&gt;找出最低工资&lt;br&gt;
 select min (sal) from emp;&lt;/p&gt;
&lt;h2 id=&#34;分组函数使用时需要注意的地方&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分组函数使用时需要注意的地方&#34;&gt;#&lt;/a&gt; 分组函数使用时，需要注意的地方&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1. 分组函数自动忽略 NULL, 不需要提前处理。
 例如：求所有员工津贴/补助的总和。
    select sum(comm) from emp;//不需要加where comm is not null条件。
2. 分组函数count(*) 和 count(具体字段)的区别。
   1. count(具体字段)：表示统计该字段下所有不为 NULL 的元素的总数。
   2. count(*)：统计表中所有行数。
3. 分组函数不能直接用在where子句中。
 例如：找出比最低工资高的员工信息。
 select ename, sal from emp where sal &amp;gt; min(sal);// 错误SQL语句
4. 所有分组函数可以组合起来一起使用。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.754Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/7.%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</id>
        <title>Mysql单行处理函数</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/7.%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
        <content type="html">&lt;p&gt;单行处理函数也叫做数据处理函数&lt;/p&gt;
&lt;p&gt;单行处理函数的特点：&lt;/p&gt;
&lt;p&gt;​	一个输入对应一个输出&lt;/p&gt;
&lt;p&gt;和单行处理函数相对的是：&lt;/p&gt;
&lt;p&gt;​	多行处理函数（特点：多个输入，对应一个输出）&lt;/p&gt;
&lt;p&gt;常见的单行处理函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;lower 转换小写&lt;/p&gt;
&lt;p&gt;select  lower(name)  from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;upper 转换大写&lt;/p&gt;
&lt;p&gt;select  upper(name)  from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;substr 取子串&lt;/p&gt;
&lt;p&gt;substr (被截取的字符串，起始下标，截取的长度)// 注意起始下标从 1 开始，没有 0&lt;/p&gt;
&lt;p&gt;select  substr(name, 1, length(name))  from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;concat 进行字符串拼接&lt;/p&gt;
&lt;p&gt;select concat(name, countrycode) from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;length 取长度&lt;/p&gt;
&lt;p&gt;select length(name) from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;trim 去除空格&lt;/p&gt;
&lt;p&gt;select * from city where name = trim (’   King   &#39;);// 将查询条件中的前后空格去除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;round 四舍五入&lt;/p&gt;
&lt;p&gt;select 字段 from 表名；&lt;/p&gt;
&lt;p&gt;select name from city;&lt;/p&gt;
&lt;p&gt;select ‘abc’ from city;//select 后面直接跟 “字面量”/“字面值”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：select 后面可以跟某个表的字段名（可以等同看作变量名），也可以跟字面量 / 字面值（数据）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;select round (1276.567, 2) from city;// 保留二位小数 1276.57&lt;/p&gt;
&lt;p&gt;select round (1276.567, 1) from city;// 保留一位小数 1276.6&lt;/p&gt;
&lt;p&gt;select round (1276.567, 0) from city;// 保留整数 1277&lt;/p&gt;
&lt;p&gt;select round (1276.567, -1) from city;// 保留到十位 1270&lt;/p&gt;
&lt;p&gt;select round (1276.567, -2) from city;// 保留到百位 1280&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rand 生成随机数&lt;/p&gt;
&lt;p&gt;select rand() from city;&lt;/p&gt;
&lt;p&gt;例如：生成 100 以内的随机数&lt;/p&gt;
&lt;p&gt;select round(rand() * 100, 0) from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ifnull 可以将 null 转换成一个具体值。&lt;/p&gt;
&lt;p&gt;ifnull 是空处理函数。专门处理空的。（因为在所有数据库中，只要有 null 参与的数学运算，最终结果都为 null）&lt;/p&gt;
&lt;p&gt;ifnull 函数语法：ifnull (数据，被当作那个值)&lt;/p&gt;
&lt;p&gt;如果 “数据” 为 null 的时候，把这个数据当作那个值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;case when … then … when … then … else … end&lt;/p&gt;
&lt;p&gt;例如：当员工的岗位为 MANAGER 的时候，工资上调 %10，当工作岗位是 SALESMAN 的时候，工资上调 %50，其他正常。&lt;/p&gt;
&lt;p&gt;（注意：不修改数据库，只是将查询结果显示为工资上调）&lt;/p&gt;
&lt;p&gt;select&lt;/p&gt;
&lt;p&gt;ename,&lt;/p&gt;
&lt;p&gt;job,&lt;/p&gt;
&lt;p&gt;sal as oldsal,&lt;/p&gt;
&lt;p&gt;(case when ‘MANAGER’ then sal*1.1 when ‘SALESMAN’ then sal**1.5 else sal end) as newsal&lt;/p&gt;
&lt;p&gt;from emp;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;format 数字格式化&lt;br&gt;
 format (数字，‘格式’)&lt;/p&gt;
&lt;p&gt;select ename, (sal, ‘$999,999’) from emp;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;str_to_date&lt;/p&gt;
&lt;p&gt;字符串转换为 date 类型&lt;/p&gt;
&lt;p&gt;str_to_date (‘日期字符串’, ‘日期格式’)&lt;/p&gt;
&lt;p&gt;Mysql 中日期格式：&lt;br&gt;
% Y 年&lt;br&gt;
 % m 月&lt;br&gt;
 % d 日&lt;br&gt;
 % h 时&lt;br&gt;
 % i 分&lt;br&gt;
 % s 秒&lt;/p&gt;
&lt;p&gt;Java 中日期格式：&lt;br&gt;
yyyy-MM-dd HH:mm:ss SSS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;date_format&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从 date 类型转换为具有一定格式的字符串类型&lt;/p&gt;
&lt;p&gt;date_format (日期值，‘日期格式’)&lt;/p&gt;
&lt;p&gt;insert into test values(1, ‘zhangsan’, str_to_date(‘10:13:20 11-11-1999’, ‘%h:%i:%s %d-%m-%Y’));&lt;/p&gt;
&lt;p&gt;insert into test values (1, ‘zhangsan’, str_to_date (‘11-1999’, ‘% m-% Y’));//date 类型为年月日，插入的值不完整，所以报错&lt;/p&gt;
&lt;p&gt;insert into test values(1, ‘zhangsan’, str_to_date(‘11-1999’, ‘11-%m-%Y’));&lt;/p&gt;
&lt;p&gt;insert into test values(1, ‘zhangsan’, str_to_date(‘10-11-1999’, ‘10-%m-%Y’));&lt;/p&gt;
&lt;p&gt;insert into test values (1, ‘zhangsan’, str_to_date (‘10-11-1999’, ‘% d-% m-% Y’));// 正确&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.751Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/6.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/</id>
        <title>Mysql综合案例</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/6.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找出工资在 1250 到 3000 之间的员工信息，要求按照薪资降序排列。&lt;/p&gt;
&lt;p&gt;select ename, sal&lt;/p&gt;
&lt;p&gt;​	from emp&lt;/p&gt;
&lt;p&gt;​	where sal between 1250 and 3000&lt;/p&gt;
&lt;p&gt;order by sal desc;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上语句的执行顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;from&lt;/li&gt;
&lt;li&gt;where&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;li&gt;order by (排序总是在最后执行的！！！)&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.748Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/5.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/</id>
        <title>Mysql排序</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/5.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询所有员工薪资，排序&lt;/p&gt;
&lt;p&gt;select ename,sal from emp order by sal;// 默认升序&lt;/p&gt;
&lt;p&gt;select ename,sal from emp order by sal asc;// 指定 ASC 升序&lt;/p&gt;
&lt;p&gt;select ename,sal from emp order by sal desc;// 指定 DESC 降序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个字段进行排序&lt;/p&gt;
&lt;p&gt;例如：查询员工名字和薪资，要求按照薪资升序，如果薪资相同，再按照名字升序排列。&lt;/p&gt;
&lt;p&gt;select ename, sal from emp order by sal asc, ename asc;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据字段位置进行排序&lt;/p&gt;
&lt;p&gt;例如：按照查询结果的第 2 列 sal 进行排序。&lt;/p&gt;
&lt;p&gt;select ename, sal from emp order by 2;&lt;/p&gt;
&lt;p&gt;注意：不建议在开发中这样写，因为不健壮。&lt;/p&gt;
&lt;p&gt;因为列的顺序很容易发生改变，列顺序修改之后，2 就废了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序采用 order by 子句，order by 后面跟上排序字段，排序可以放多个，多个可以采用逗号（,）间隔，order by 默认采用升序，如果存在 where 子句那么 order by 必须放到最后面。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.745Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql条件查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h2 id=&#34;条件查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#条件查询&#34;&gt;#&lt;/a&gt; 条件查询&lt;/h2&gt;
&lt;p&gt;什么是条件查询？&lt;/p&gt;
&lt;p&gt;不是将表中所有数据都查出来。是查询出来符合条件的。&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;p&gt;​	select 字段 1，字段 2，字段 3 from 表名 where 条件；&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;figcaption data-lang=&#34;SQL&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; 等于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&gt;&lt;/span&gt;或&lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; 不等于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; 小于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;=&lt;/span&gt; 小于等于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; 大于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;=&lt;/span&gt; 大于等于&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt; 两个值之间，等同于 &lt;span class=&#34;token operator&#34;&gt;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	注意：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		在使用&lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; 时，必须要遵循左小右大。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		&lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; 是闭区间，包括两端的值。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	例如： &lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;sal &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; sal &lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2450&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	错误写法：&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;sal &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; sal &lt;span class=&#34;token operator&#34;&gt;between&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;3000&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2450&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt; 为 &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt; （&lt;span class=&#34;token operator&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt; 不为空）&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;查询那些员工的津贴&lt;span class=&#34;token operator&#34;&gt;/&lt;/span&gt;补助为&lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt;？&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;错误查询：&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; comm &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;正确写法：&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; comm &lt;span class=&#34;token operator&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; 并且&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;查询工作岗位是MANAGER并且工资大于&lt;span class=&#34;token number&#34;&gt;2500&lt;/span&gt;的员工信息？&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;job&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;sal &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emp &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; job &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;MANAGER&#39;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; sal&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;2500&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;29&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;or&lt;/span&gt; 或者&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;30&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;查询工作岗位是MANAGER或SALESMAN的员工信息？&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;31&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; empno&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;ename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;job&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;sal &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; emo &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; job &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;MANAGER&#39;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;or&lt;/span&gt; job &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;SALESMAN&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;32&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;33&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt; 包含，相当于多个 &lt;span class=&#34;token operator&#34;&gt;or&lt;/span&gt; （&lt;span class=&#34;token operator&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt; 不在这个范围中）&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;34&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;注意：&lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt;不是一个区间。&lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt;后面跟的是具体的值。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;35&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;36&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;not&lt;/span&gt;可以取非，主要用在&lt;span class=&#34;token operator&#34;&gt;is&lt;/span&gt; 或 &lt;span class=&#34;token operator&#34;&gt;in&lt;/span&gt; 中&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;37&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;相当于多个 &lt;span class=&#34;token operator&#34;&gt;or&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;38&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;39&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;like&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;like&lt;/span&gt;称为模糊匹配查询，支持&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt; 或下划线匹配&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;40&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt; 匹配任意个字符&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;41&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;下划线，一个下划线只匹配一个字符&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;42&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;找出名字中有下划线的&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;43&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; name &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; t_student &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; name &lt;span class=&#34;token operator&#34;&gt;like&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;%\_%&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;// 使用 \ 转义字符&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;注意： 在数据库中 null 不能使用等号进行衡量。需要使用 is null。因为数据库中的 null 代表什么也没有，它不是一个值，所以不能用等号衡量。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.742Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</id>
        <title>简单的查询语句</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/4.%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询一个字段&lt;/p&gt;
&lt;p&gt;select 字段名 from 表名；&lt;/p&gt;
&lt;p&gt;其中要注意：&lt;/p&gt;
&lt;p&gt;​	select 和 from 都是关键字。&lt;/p&gt;
&lt;p&gt;​	字段名和表名都是标识符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强调：对于 SQL 语句来说，是通用的。所有的 SQL 语句以 &amp;quot;;&amp;quot; 结尾。另外 SQL 语句不区分大小写，都行。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询多个字段&lt;/p&gt;
&lt;p&gt;使用逗号隔开 &amp;quot;,&amp;quot;&lt;/p&gt;
&lt;p&gt;select deptno,dname from dept;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询所有字段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以把每个字段都写上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用 *&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;效率低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可读性差&lt;/p&gt;
&lt;p&gt;在实际开发中不建议。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给查询的列起别名&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 as 关键字起别名。&lt;/p&gt;
&lt;p&gt;select deptno, dname as deptname from dept;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;省略 as 关键字。&lt;/p&gt;
&lt;p&gt;select deptno, dname deptname from dept;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;起别名的时候，别名中有空格，怎么办？&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;select deptno, dname dept name from dept;&lt;/p&gt;
&lt;p&gt;DBMS 会进行 SQL 编译，检查出不符合 SQL 语法，编译报错。&lt;/p&gt;
&lt;p&gt;解决:&lt;/p&gt;
&lt;p&gt;​	select deptno, dname ‘dept name’ from dept;// 加单引号&lt;/p&gt;
&lt;p&gt;​	select deptno, dname “dept name” from dept;// 加双引号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准。双引号在 oracle 数据库中用不了。但是在 mysql 中可以使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再次强调：数据库中的字符串都是采用单引号括起来。这是标准的，双引号不标准。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二列参与数学运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#二列参与数学运算&#34;&gt;#&lt;/a&gt; 二：列参与数学运算&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算员工年薪？sal * 12&lt;/p&gt;
&lt;p&gt;select ename, sal * 12 from emp;// 结论：列可以参与数学运算&lt;/p&gt;
&lt;p&gt;select ename, sal * 12 as ‘年薪’ from emp;// 别名是中文，用单引号括起来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.742Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/3.%E7%90%86%E8%A7%A3Sql/%E7%90%86%E8%A7%A3Sql/</id>
        <title>理解Sql</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/3.%E7%90%86%E8%A7%A3Sql/%E7%90%86%E8%A7%A3Sql/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;数据库当中最近基本的单元是表：table&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据库当中是以表格的形式表示数据的。因为比较直观。&lt;/p&gt;
&lt;p&gt;任何一张表都有行和列：&lt;/p&gt;
&lt;p&gt;​	行（row）：被称为数据 / 记录。&lt;/p&gt;
&lt;p&gt;​	列（column）：被称为字段。&lt;/p&gt;
&lt;p&gt;每个字段都有：字段名，数据类型，约束等属性。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;关于 SQL 语句的分类&lt;/p&gt;
&lt;p&gt;SQL 语句有很多，最好进行分门别类，这样更容易记忆。&lt;/p&gt;
&lt;p&gt;分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DQL：数据查询语言（凡是带 select 关键字的都是查询语句）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DML：数据操作语言（凡是对表中的数据进行增删改查的都是 DML）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;insert：增&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;update：改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete：删&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;！！！主要操作表中的数据 data。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DDL：数据定义语言（凡是带有 create，drop，alter 的都是 DDL），DDL 主要操作的是表结构。不是表中的数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;alter：修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create：新建，等同于增&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drop：删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;！！！主要对表结构进行操作。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCL：事务控制语言。&lt;/p&gt;
&lt;p&gt;包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务提交：commit;&lt;/li&gt;
&lt;li&gt;事务回滚：rollback;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCL：是数据控制语言。&lt;/p&gt;
&lt;p&gt;例如：授权 grant，撤销权限 revoke…&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.738Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
        <title>存储过程</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
        <content type="html">&lt;h1 id=&#34;mysql存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql存储过程&#34;&gt;#&lt;/a&gt; Mysql 存储过程&lt;/h1&gt;
&lt;p&gt;存储过程是在数据库中定义一些 SQL 语句的集合，可以直接去调用这些存储过程来执行已经定义好的 SQL 语句。&lt;/p&gt;
&lt;p&gt;触发器和存储过程相似，都是嵌入到 MySql 中的一段儿程序。触发器是由事件来触发某个操作。当数据库执行这些事件时，就会激活触发器来执行相应的操作。&lt;/p&gt;
&lt;h2 id=&#34;存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#存储过程&#34;&gt;#&lt;/a&gt; 存储过程&lt;/h2&gt;
&lt;p&gt;数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。例如，为了确认学生能否毕业，需要同时查询学生档案、成绩表和从何表，此时就需要使用多条 SQL 语句来针对这几个数据表完成处理要求。存储过程就是这样一组为了完成特定功能的 SQL 语句的集合。&lt;/p&gt;
&lt;p&gt;使用存储过程的目的是将经常或复杂的工作预先使用 SQL 语句写好，并用一个指定的名称存储起来，这个过程经编译和优化由存储在数据库服务器中，因此成为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需要调用 “CALL 存储过程名字” 即可自动完成。&lt;/p&gt;
&lt;p&gt;常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。&lt;/p&gt;
&lt;p&gt;一个存储过程即一个可编程的函数，它可以在数据库中创建并保存，一般由 SQL 语句和一些特殊控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySql5.0版本以前并不支持存储过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存储过程时数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以被调用，完成指定的功能操作。&lt;/p&gt;
&lt;p&gt;使用存储过程不仅可以提高数据的访问效率，同时也可以提高数据库使用的安全性。&lt;/p&gt;
&lt;p&gt;对于调用者来说，存储过程封装了 SQL 语句，调用者无需考虑逻辑功能的具体实现过程。只是简单调用即可，它可以被 Java 和 C# 等编程语言调用。&lt;/p&gt;
&lt;h2 id=&#34;创建存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建存储过程&#34;&gt;#&lt;/a&gt; 创建存储过程&lt;/h2&gt;
&lt;p&gt;创建存储过程使用 create procedure 语句，语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create procedure &amp;lt;过程名&amp;gt; ([过程参数[,...]]) &amp;lt;过程体&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，过程参数是存储过程的参数列表。MySQL 存储过程支持三种类型的参数，即输入参数，输出参数和输入 / 输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输出 / 输出参数既可以充当输入参数也可以充当输出参数。格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ IN | OUT | INOUT ] &amp;lt;参出名&amp;gt; &amp;lt;类型&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过程体是存储过程的主体部分，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 &lt;strong&gt;BEGIN&lt;/strong&gt; 开始，以关键字 &lt;strong&gt;END&lt;/strong&gt; 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。&lt;/p&gt;
&lt;p&gt;在 Mysql 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符号，那么 MySQL 服务器在处理存储过程时，会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的额结束符，而不再去处理存储过程体后面的 SQL 语句，这样显然不行。为了解决以上问题，通常使用 &lt;strong&gt;DELIMITER&lt;/strong&gt; 命令将结束命令修改为其他字符。语法格式如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELIMITER $$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;语法说明如下：&lt;br&gt;
$$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个 “？” 或两个 “￥“ 等。&lt;br&gt;
当使用 DELIMITER 命令时，应该避免使用反斜杠 &amp;quot;&amp;quot; 字符，因为它是 MySQL 的转义字符。&lt;/p&gt;
&lt;p&gt;在 MySQL 命令行客户端使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; DELIMITER ??
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行该命令后，任何命令、语句或程序的结束标志就换为两个问号 &amp;quot;??&amp;quot; 了。&lt;/p&gt;
&lt;p&gt;注意：DELIMITER 和分号 “;” 之间一定要有一个空格（使用分号 &amp;quot;;&amp;quot; 作为 MySQL 语句结束符）。&lt;/p&gt;
&lt;p&gt;在创建存储过程时，必须具有 create routine 权限。&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;
mysql&amp;gt; DELIMITER //&lt;br&gt;
mysql&amp;gt; CREATE PROCEDURE GetScoreByStu&lt;br&gt;
-&amp;gt; (IN name VARCHAR(30))&lt;br&gt;
-&amp;gt; BEGIN&lt;br&gt;
-&amp;gt; SELECT student_score FROM tb_students_score&lt;br&gt;
-&amp;gt; WHERE student_name=name;&lt;br&gt;
-&amp;gt; END //&lt;br&gt;
Query OK, 0 rows affected (0.01 sec)&lt;/p&gt;
&lt;h2 id=&#34;12-查看存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#12-查看存储过程&#34;&gt;#&lt;/a&gt; 1.2 查看存储过程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;SHOW PROCEDURE STATUS LIKE 存储过程名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以查看存储过程的定义，语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW CREATE PROCEDURE 存储过程名
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13修改存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#13修改存储过程&#34;&gt;#&lt;/a&gt; 1.3 修改存储过程&lt;/h2&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.736Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/24.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</id>
        <title>主从同步机制</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/24.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
        <content type="html">&lt;h1 id=&#34;主从同步机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#主从同步机制&#34;&gt;#&lt;/a&gt; 主从同步机制&lt;/h1&gt;
&lt;p&gt;作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以用作一种备份机制，相当于热备份&lt;/li&gt;
&lt;li&gt;可以用做读写分离，均衡数据库负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;概述&lt;/p&gt;
&lt;p&gt;MySQL 主从复制也能够称为 MySQL 主从同步，它是构建数据库高可用集群架构的基础。它经过将一台主机的数据复制到其余一台或多台主机上，并从新应用 relay log 中的 SQL 语句来实现复制功能。MySQL 支持单向、双向、链式级联、异步复制，5.5 版本以后加入的半同步复制，5.6 版本以后的 GTID 复制，MySQL5.7 的多源复制、并行复制、loss-less 复制。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.733Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/23.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</id>
        <title>数据库范式</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/23.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
        <content type="html">&lt;h1 id=&#34;数据库设计三范式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数据库设计三范式&#34;&gt;#&lt;/a&gt; 数据库设计三范式&lt;/h1&gt;
&lt;p&gt;什么是数据库设计范式？&lt;br&gt;
数据库表的设计依据。&lt;/p&gt;
&lt;h2 id=&#34;第一范式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第一范式&#34;&gt;#&lt;/a&gt; 第一范式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;要求任何一张表必须有主键，每一个字段原子性不可再分

案例：
学生编号    学生姓名    联系方式
1001        张三        zs@gmail.com,135999999
1002        李四        li@gmail.com,136999999
1003        王五        ww@gmail.com,137999999

以上表设计不满足第一范式--没有主键，联系方式可拆分

修改：
学生编号(pk)    学生姓名        邮箱                联系电话
1001            张三        zs@gmail.com       135999999
1002            李四        li@gmail.com       136999999
1003            王五        ww@gmail.com       137999999
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第二范式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第二范式&#34;&gt;#&lt;/a&gt; 第二范式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;建立在第一范式基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖

案例：
学生编号        学生姓名        教师编号        教师姓名
1001            张三            001             王老师
1002            李四            002             赵老师
1002            李四            002             王老师
1001            张三            001             赵老师

以上表设计不满足第一范式--没有主键

修改：
学生编号    +    教师编号（pk）        学生姓名          教师姓名
1001            001             张三               王老师
1002            002             李四               赵老师
1002            002             李四               王老师
1001            001             张三               赵老师

学生编号和教师编号连个字段做复合主键
以上修改完之后表不满足第二范式--非主键字段，产生部分依赖(学生和教师关系产生多对多关系)
    导致：数据冗余，空间浪费

修改：
学生编号    学生姓名
1001        张三
1002        李四

教师编号    教师姓名
001         王老师
002         赵老师

学生教师联合表
id(pk)      学生编号(fk)   教师编号(fk)
1            1001          001
2            1002          001
3            1001          002
4            1002          002
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第三范式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第三范式&#34;&gt;#&lt;/a&gt; 第三范式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;建立在第二范式基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖

案例：
学生编号（PK）        学生姓名        班级编号         班级名称
1001                   张三            01             一班
1002                   李四            02             二班
1003                   王五            03             三班
1004                   赵六            03             四班

以上表的设计满足第一范式--有主键
以上表的设计满足第二范式--主键是单一主键，不是复合主键，没有产生部分依赖（表中学生和班级是一对多关系）

以上表不满足第三范式--传递性依赖（班级名称依赖班级编号，产生了传递依赖，不符合第三范式，产生了数据冗余）

修改：
班级表
班级编号（pk）      班级名称
01                  一班
02                  二班
...

学生表
学生编号（pk）      学生姓名        班级编号
1001                张三            01
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用：避免数据冗余，空间的浪费&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#总结&#34;&gt;#&lt;/a&gt; 总结&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;一对多：
    一对多，两张表，多的表加外键

多对多：
    多对多，三张表，关系表两个外键

一对一：
    在一对一中，可能存在表字段太多，太庞大，需要拆分表
    
    案例：
    id      login_name      login_pwd       real_name       email
    1           admin       admin           张三            zs@gmail.com


    修改：
    登录信息表：
    id      login_name      login_pwd
    1       admin           admin

    用户详细信息表：
    id      real_name       email           login_id(fk+unique)
    100        admin        zs@gmail.com        1

    在一对一拆分表时，可以使用 外键+唯一性约束 设计表
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;重点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#重点&#34;&gt;#&lt;/a&gt; 重点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;数据库设计三范式是理论上的。
实践和理论有时候有偏差。
最终的目的都是为了满足客户的需求，有的时候会拿数据冗余换速度。因为Sql中，表和表之间的连接次数过多，效率越低（笛卡尔积）
有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.731Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/22.DBA%E5%91%BD%E4%BB%A4/DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
        <title>DBA命令</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/22.DBA%E5%91%BD%E4%BB%A4/DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
        <content type="html">&lt;h1 id=&#34;dba命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dba命令&#34;&gt;#&lt;/a&gt; DBA 命令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;必须超级管理员操作&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;新建用户&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#新建用户&#34;&gt;#&lt;/a&gt; 新建用户&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create USER username IDENTIFIED by &#39;password&#39;;

create USER &#39;username&#39;@&#39;host&#39; IDENTIFIED by &#39;password&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;username：创建的用户名。&lt;/p&gt;
&lt;p&gt;host：指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符 %&lt;/p&gt;
&lt;p&gt;password：该用户的登陆密码。密码可以为空，如果为空则该用户可以不需要密码登陆服务器。&lt;/p&gt;
&lt;h2 id=&#34;授权&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#授权&#34;&gt;#&lt;/a&gt; 授权&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;GRANT SELECT,INSERT on *.* to &#39;guest&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;.&lt;/em&gt;：表示表示所有库的所有表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant all privileges on 数据库 to &#39;用户名&#39;@&#39;IP地址&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;回收权限&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#回收权限&#34;&gt;#&lt;/a&gt; 回收权限&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;revoke all privileges from 数据库 to &#39;用户名&#39;@&#39;IP地址&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;all privileges 指除了 grant 之外的所有权限，也可以自己设置权限&lt;/p&gt;
&lt;p&gt;例如：grant insert on world.* to ‘用户名’@‘IP 地址’;(只能对 world 数据库做插入操作，world.* 表示对 world 中所有表）&lt;/p&gt;
&lt;h2 id=&#34;导出导入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#导出导入&#34;&gt;#&lt;/a&gt; 导出导入&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;导出
    在windows的dos命令窗口中：
    mysqldump nk&amp;gt;D:\nk.sql -uroot -proot

    导出指定的表:导出nk数据库中 student表
    mysqldump nk student&amp;gt;D:\nk.sql -uroot -proot


导入
    登录到mysql中，创建数据库 create database nk;
    然后导入sql文件
    source D:\nk.sql
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.728Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/21.%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/</id>
        <title>视图</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/21.%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/"/>
        <content type="html">&lt;h1 id=&#34;视图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#视图&#34;&gt;#&lt;/a&gt; 视图&lt;/h1&gt;
&lt;p&gt;什么是视图？&lt;br&gt;
view：站在不同的角度，去看待同一份数据&lt;/p&gt;
&lt;h2 id=&#34;创建视图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建视图&#34;&gt;#&lt;/a&gt; 创建视图&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create view 视图名 as DQL语句;

create view emp_view as select * from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：只有 DQL 语句才能以 view 的形式创建&lt;/p&gt;
&lt;h2 id=&#34;删除视图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#删除视图&#34;&gt;#&lt;/a&gt; 删除视图&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;drop view emp_view;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;视图作用可以干什么方便-简化开发-利于维护&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#视图作用可以干什么方便-简化开发-利于维护&#34;&gt;#&lt;/a&gt; 视图作用（可以干什么）–方便、简化开发、利于维护&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作

特点：对视图的操作，会影响到原表数据

select * from dept2_view;

insert into dept2_view(deptno, dname, loc) vlaues(60, &#39;SALES&#39;, &#39;BJ&#39;);// （insert、delete、update）操作会影响到原表
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;视图对象在实际开发中，到底有什么作用？&lt;br&gt;
假设有一条 SQL 语句，需要在不同位置反复使用，每次使用需要重新编写，可以把这条复杂的 SQL 语句以视图对象的形式创建出来&lt;br&gt;
在需要编写这条 SQL 语句的位置直接使用视图对象。可以简化开发，并且利于后期维护。因为只需要修改一个位置就行了，只需要修改视图对象所映射的 SQL 语句&lt;/p&gt;
&lt;p&gt;使用视图开发的时候，可以像使用 table 一样，可以对视图进行增删改查等操作。&lt;br&gt;
视图对象是存储在硬盘上的，不会消失&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.725Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</id>
        <title>索引失效</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
        <content type="html">&lt;h1 id=&#34;索引失效&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#索引失效&#34;&gt;#&lt;/a&gt; 索引失效&lt;/h1&gt;
&lt;p&gt;什么时候索引会失效？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一种情况：
 select * from t_user where name like &#39;%z&#39;;

 因为模糊匹配中以 &#39;%&#39; 开头了，索引失效（存在索引，但不走索引）


第二种情况：
 使用or的时候会失效，如果使用or，那么要求or两边字段条件都要有索引，才会走索引。如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效


第三种情况：
 使用复合索引的时候，没有使用左侧的列查找，索引失效( 最左原则 )
 create index emp_job_sal_index on emp(job, sal);

 explain select * from emp where job = &#39;MANAGER&#39;;// 走索引
 explain select * from emp where sal = 1000;// 索引失效


第四种情况：
 在where当中，索引参与了数学运算，索引失效

 create index emp_sal_index on emp(sal);

 explain select * from emp where sal = 800;// 走索引
 explain select * from emp where sal = 800 + 100;// 走索引

 explain select * from emp where sal + 100 = 800;// 索引失效


第五种情况：
 在where当中，索引列使用了函数，索引失效

 create index emp_ename_index on emp(ename);

 explain select * from emp where ename = &#39;SIMTH&#39;;// 走索引

 explain select * from emp where lower(ename) = &#39;simth&#39;;// 索引失效


第六种情况：....
第七种情况：....
...



索引是数据库优化的重要手段，优化的时候，优先考虑的因素就是索引。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;索引分类：&lt;br&gt;
单一索引：&lt;br&gt;
复合索引：&lt;br&gt;
主键索引：&lt;br&gt;
唯一性索引：&lt;br&gt;
…&lt;/p&gt;
&lt;p&gt;注意：唯一性比较弱的字段上添加索引用处不大。（可能存在大量重复数据，这个时候索引起不到什么作用，越唯一，效率越高）&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.723Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95/</id>
        <title>索引</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95/"/>
        <content type="html">&lt;h1 id=&#34;索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#索引&#34;&gt;#&lt;/a&gt; 索引&lt;/h1&gt;
&lt;p&gt;什么是索引？&lt;br&gt;
索引在数据库表的字段上添加的，是为了提高检索（查询）效率存在的一种机制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一张表的一个字段可以添加一个索引，多个字段可以联合起来添加索引

索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举例：&lt;br&gt;
查字典：&lt;br&gt;
1. 一页一页查找，直到找到为止。这种查找属于全表扫描，效率低&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3. 通过目录（索引），去定位一个大概的位置，然后直接定位到该位置，做局域性扫描，缩小扫描的范围，快速的查找。这种方式属于索引检索，效率高

Mysql中查询的两种方式：
    1. 全表扫描
    2. 根据索引检索
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;br&gt;
在 Mysql 数据库当中索引也是需要排序的，并且这个索引的排序和 TreeSet 数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！&lt;br&gt;
在 Mysq 中索引是一个 B-Tree 数据结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;遵循左小右大原则存放，采用中序遍历方式遍历取数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在任何数据库当中，主键都会自动添加索引对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Mysql 中，一个字段上如果右 unique 约束的话，也会自动创建索引对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Mysql 当中，索引是一个单独的对象，不同的存储引擎以不同形式存在。&lt;/strong&gt;&lt;br&gt;
1. 在 MyISAM 存储引擎中，索引存储在一个.MYI 文件中&lt;br&gt;
 2. 在 InnoDB 存储引擎当中，索引存储在一个叫 tablespace 当中。&lt;br&gt;
3. 在 Memory 存储引擎当中，被存储在内存当中&lt;br&gt;
不管索引存储在哪里，索引在 Mysql 中都是一个树的形式存在。（自平衡二叉树：B-Tree）&lt;/p&gt;
&lt;h2 id=&#34;在mysql中主键以及unique字段上都会自动添加索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#在mysql中主键以及unique字段上都会自动添加索引&#34;&gt;#&lt;/a&gt; 在 Mysql 中，主键以及 unique 字段上都会自动添加索引&lt;/h2&gt;
&lt;p&gt;什么条件下，需要考虑给字段添加索引？&lt;br&gt;
1. 数据量庞大（需要测试）&lt;br&gt;
2. 该字段经常出现在 where 查询条件中&lt;br&gt;
 3. 该字段很少的 DML 操作（因为 DML 之后，索引经常需要重新排序）&lt;br&gt;
注意：&lt;br&gt;
建议不要随意添加索引，因为索引也是需要维护的，太多反而会降低系统性能&lt;br&gt;
建议通过主键查询，建议通过 unique 约束字段进行查询，效率是比较高的&lt;/p&gt;
&lt;h2 id=&#34;创建和删除索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建和删除索引&#34;&gt;#&lt;/a&gt; 创建和删除索引&lt;/h2&gt;
&lt;h3 id=&#34;创建索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建索引&#34;&gt;#&lt;/a&gt; 创建索引&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;create index 索引名 on 表名(要添加索引的字段名);

create index emp_ename_index on emp(ename);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#删除索引&#34;&gt;#&lt;/a&gt; 删除索引&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;drop index 索引名 on 表名;

drop index emp_ename_index on emp;


在Mysql中查看一个SQL语句是否使用了索引进行检索
explain select * from t_user where name = &#39;zhangsan6&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举例：&lt;br&gt;
## 查看 sql 语句执行详情&lt;br&gt;
 mysql&amp;gt; explain select * from t_user where name = ‘zhangsan6’;&lt;br&gt;
±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+&lt;br&gt;
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |&lt;br&gt;
±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+&lt;br&gt;
|  1 | SIMPLE      | t_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   12 |    10.00 | Using where |&lt;br&gt;
±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+&lt;br&gt;
1 row in set, 1 warning (0.00 sec)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## 为name字段创建索引
create index user_name_index on t_user(name);

## 在索引创建后，重新执行sql语句，查看sql执行情况
mysql&amp;gt; explain select * from t_user where name = &#39;zhangsan6&#39;;
+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | t_user | NULL       | ref  | user_name_index | user_name_index | 1023    | const |    1 |   100.00 | Using index |
+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.721Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/2.Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
        <title>Mysql常用命令</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/2.Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;在 windows 操作系统中，怎么使用命令行来启动 Mysql 和关闭 Mysql 服务？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;​	net stop 服务名称；&lt;/p&gt;
&lt;p&gt;​	net start 服务名称；&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;登录 Mysql 数据库&lt;/p&gt;
&lt;p&gt;明文密码登录：mysql -u [用户名] -p [密码]&lt;/p&gt;
&lt;p&gt;隐藏密码登录：mysql -u [用户名] -p + 回车键，然后输入密码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;退出 Mysql&lt;/p&gt;
&lt;p&gt;exit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看数据库有哪些数据库？mysql 默认自带了 4 个数据库&lt;/p&gt;
&lt;p&gt;show databases;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么选择使用哪个数据库？&lt;/p&gt;
&lt;p&gt;use [数据库名]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么创建数据库？&lt;/p&gt;
&lt;p&gt;create database [数据库名];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么查看有哪些表？&lt;/p&gt;
&lt;p&gt;show tables;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么查看表结构？&lt;/p&gt;
&lt;p&gt;desc [表名]&lt;/p&gt;
&lt;p&gt;全写为：&lt;/p&gt;
&lt;p&gt;​	describe [表名]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 sql 文件中的数据导入？&lt;/p&gt;
&lt;p&gt;source [路径]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意路径中不要有中文。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如： source D:\coure\03-Mysql\document\bjpowernode.sql&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看数据库版本号&lt;/p&gt;
&lt;p&gt;select version();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看当前使用的是那个数据库&lt;/p&gt;
&lt;p&gt;select database();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中止输入的 mysql 命令（还未执行的命令）&lt;/p&gt;
&lt;p&gt;\c 用来中止一条命令的输入。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mysql&amp;gt; show&lt;/em&gt;&lt;br&gt;
&lt;em&gt;-&amp;gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;-&amp;gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;-&amp;gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;-&amp;gt; \c&lt;/em&gt;&lt;br&gt;
&lt;em&gt;mysql&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 Mysql 支持那些存储引擎&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;show engines \G;&lt;/p&gt;
&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;查看建表语句&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;show create table 表名；&lt;/p&gt;
&lt;p&gt;！！！以上命令不区分大小写&lt;/p&gt;
&lt;p&gt;！！！注意：Mysql 中命令是不见分号；则不会执行命令。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.718Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
        <title>事务隔离</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
        <content type="html">&lt;h1 id=&#34;事务隔离级别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务隔离级别&#34;&gt;#&lt;/a&gt; 事务隔离级别&lt;/h1&gt;
&lt;h2 id=&#34;分类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分类&#34;&gt;#&lt;/a&gt; 分类&lt;/h2&gt;
&lt;h3 id=&#34;读未提交read-uncommitted&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#读未提交read-uncommitted&#34;&gt;#&lt;/a&gt; 读未提交：read uncommitted&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;概念：
    事务A可以读取到事务B未提交的数据

存在脏读现象（Dirty Rread）：称读到脏数据
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;读已提交readcommitted&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#读已提交readcommitted&#34;&gt;#&lt;/a&gt; 读已提交：readcommitted&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;概念：
    事务A只能读取到事务B提交之后的数据
这种隔离级别解决了脏读现象

存在‘不可重复读取数据’问题：在事务开启后，每次读取到的数据可能不一致。比如A开始事务循环读取数据的过程中，B事务不断修改数据并提交，导致A事务在后续的数据读取过程中，数据产生不一致的现象

这种隔离级别是比较真实的数据，每一次读到的数据绝对真实
注意：Oracle数据库默认的隔离级别是： read committed
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;可重复读repeatable-read&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#可重复读repeatable-read&#34;&gt;#&lt;/a&gt; 可重复读：repeatable read&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;概念：
    事务A开启后，不管多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据修改，并且提交了。事务A读取到的数据还是没有发生改变，这就是可重复读
解决了不可重复读的现象

存在幻读现象：每一次读取到的数据都是幻象，不够真实

Mysql默认隔离级别
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;序列化串行化serializable&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#序列化串行化serializable&#34;&gt;#&lt;/a&gt; 序列化 / 串行化：serializable&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;概念：

隔离级别最高，效率最低。解决了所有问题
不能并发
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试隔离级别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#测试隔离级别&#34;&gt;#&lt;/a&gt; 测试隔离级别&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;查看变量：
show variables;
通过like 通配符查询
show variables like &#39;%isolation%&#39;;

查看隔离级别：
select @@transaction_isolation; 

设置全局事务等级
set global transaction isolation level read committed;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.716Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/</id>
        <title>事务</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/"/>
        <content type="html">&lt;h1 id=&#34;事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务&#34;&gt;#&lt;/a&gt; 事务&lt;/h1&gt;
&lt;p&gt;什么是事务？&lt;br&gt;
一个事务就是一个完整的业务逻辑。&lt;br&gt;
是一个最小的工作单元。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如转账的业务逻辑，就是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本质：就是多条 DML 语句同时成功或者同时失败&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只有 DML 语句和事务有关系，其他语句无关。&lt;/strong&gt;&lt;br&gt;
insert&lt;br&gt;
update&lt;br&gt;
delete&lt;br&gt;
 因为以上三个语句是操作数据库中数据的&lt;/p&gt;
&lt;p&gt;事务是怎么做到同时成功或者同时失败的？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InnoDB：提供一组用于记录事务特性活动的日志文件

在事务执行的过程中，每一条DML的操作都会被记录到“事务特性活动的日志文件”中
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在事务执行的过程中，可以提交事务，也可以回滚事务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;提交事务： 清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中
    标志着事务的结束，并且是一种全部成功的结束

回滚事务： 将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件
    回滚事务标志着事务的结束，并且是一种全部失败的结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;提交事务-回滚事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#提交事务-回滚事务&#34;&gt;#&lt;/a&gt; 提交事务、回滚事务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;提交事务：commit
回滚事务：rollback (回滚只能回滚到上一次的提交点)

事务对应的单词：transaction

Mysql中默认情况下是自动提交事务的（自动提交）

开启事务
    start transaction;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事务特性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务特性&#34;&gt;#&lt;/a&gt; 事务特性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;A：原子性
    说明事务是最小工作单元，不可再分

C：一致性
    所有事务要求，在同一个事务中，所有操作必须同时成功，或者同时失败，以保证数据的一致性

I：隔离性
    A事务和B事务之间具有一定的隔离

D：持久性
    事务最终结束的一个保障，事务提交，将没有保存到硬盘上的数据保存到硬盘上
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.714Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/18.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
        <title>存储引擎</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/18.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
        <content type="html">&lt;h1 id=&#34;存储引擎&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#存储引擎&#34;&gt;#&lt;/a&gt; 存储引擎&lt;/h1&gt;
&lt;p&gt;什么是存储引擎？有什么用？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;存储引擎是Mysql中特有的一个术语。其他数据库中没有（Oracle中也有，不叫这个名字）

存储引擎实际上是一张表存储/组织数据的方式。

不同的存储引擎，表存储的方式不同。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何制定表的存储引擎？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可以在建表时，最后来指定表的存储引擎。
charset 来指定表的字符编码方式

show create table student;

CREATE TABLE `student` (
`id` int NOT NULL AUTO_INCREMENT,
`name` varchar(255) DEFAULT NULL,
`cno` int DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `cno` (`cno`),
CONSTRAINT `student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`t_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结论：&lt;br&gt;
mysql 默认的存储引擎是 InnoDB&lt;br&gt;
mysql 默认的字符编码方式： utf8mb4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table test(
    id int,
    name varchar(10)
) engine=InnoDB default CHARSET=utf8mb4;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看mysql支持哪些存储引擎&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看mysql支持哪些存储引擎&#34;&gt;#&lt;/a&gt; 查看 Mysql 支持哪些存储引擎&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;show engines \G;

mysql&amp;gt; show engines \G;
*************************** 1. row ***************************
    Engine: MEMORY
    Support: YES
    Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 2. row ***************************
    Engine: MRG_MYISAM
    Support: YES
    Comment: Collection of identical MyISAM tables
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 3. row ***************************
    Engine: CSV
    Support: YES
    Comment: CSV storage engine
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 4. row ***************************
    Engine: FEDERATED
    Support: NO
    Comment: Federated MySQL storage engine
Transactions: NULL
        XA: NULL
Savepoints: NULL
*************************** 5. row ***************************
    Engine: PERFORMANCE_SCHEMA
    Support: YES
    Comment: Performance Schema
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 6. row ***************************
    Engine: MyISAM
    Support: YES
    Comment: MyISAM storage engine
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 7. row ***************************
    Engine: InnoDB
    Support: DEFAULT
    Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
        XA: YES
Savepoints: YES
*************************** 8. row ***************************
    Engine: ndbinfo
    Support: NO
    Comment: MySQL Cluster system information storage engine
Transactions: NULL
        XA: NULL
Savepoints: NULL
*************************** 9. row ***************************
    Engine: BLACKHOLE
    Support: YES
    Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 10. row ***************************
    Engine: ARCHIVE
    Support: YES
    Comment: Archive storage engine
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 11. row ***************************
    Engine: ndbcluster
    Support: NO
    Comment: Clustered, fault-tolerant tables
Transactions: NULL
        XA: NULL
Savepoints: NULL
11 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用存储引擎&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常用存储引擎&#34;&gt;#&lt;/a&gt; 常用存储引擎&lt;/h2&gt;
&lt;h3 id=&#34;myisam&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#myisam&#34;&gt;#&lt;/a&gt; MyISAM&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;特征：
    使用三个文件夹表示每个表
        格式文件-存储表结构的定义（mytable.frm)
        数据文件-存储表行的内容（mytable.MYD)
        索引文件-存储表上的索引（mytable.MYI) ：索引是一本数的目录，缩小扫描范围，提高效率
    可被转换为压缩、只读表来节省空间

优点：可被转换为压缩、只读表来节省空间
缺点：不支持事务机制，安全性低
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;innodb&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#innodb&#34;&gt;#&lt;/a&gt; InnoDB&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Mysql默认的存储引擎，同时也是一个重量级的存储引擎
主要特点：非常安全
    InnoDB支持事务
    支持数据库崩溃后自动回复机制

特征：
    1. 每个InnoDB表在数据库目录中以.frm格式文件表示
    2. InnoDB表空间tablespace被用于存储表的内容
    3. 提供一组用于记录事务特性活动的日志文件
    4. 用commit（提交）、savepoint 及 rollback（回滚）支持事务处理
    5. 提供全ACID兼容
    6. 在Mysql服务器崩溃后提供自动恢复
    7. 多版本（MVCC）和行级锁定
    8. 支持外键及引用的完整性，包括级联删除和更新
    
优点：支持事务
    以保证数据的安全。
缺点：
    1. 效率不是很高
    2. 不能压缩
    3. 不能转换为只读
    4. 不能很好的节省存储空间
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;memory&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#memory&#34;&gt;#&lt;/a&gt; MEMORY&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;内存存储引擎（别名堆引擎）

使用MEMORY存储引擎的表，其数据存储在内存中，且长度固定
这俩个特点使得MEMORY存储引擎非常快

特征：
    1. 在数据库目录中，每个表都以.frm 格式的文件表示
    2. 表数据和索引被存储在内存中（目的：查询快）
    3. 表级锁机制
    4. 不能包含 TEXT 或 BLOB 字段

MEMORY 存储引擎以前被称为HEAP引擎。

优点：查询效率最高
缺点：不安全，关机后数据消失，因为数据和索引都是存储在内存当中
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意对于一张表来说只要是主键或者加有unique约束的字段上会自动创建索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意对于一张表来说只要是主键或者加有unique约束的字段上会自动创建索引&#34;&gt;#&lt;/a&gt; 注意：对于一张表来说，只要是主键，或者加有 unique 约束的字段上会自动创建索引。&lt;/h2&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.712Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/17.%E7%BA%A6%E6%9D%9F/%E7%BA%A6%E6%9D%9F/</id>
        <title>约束</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/17.%E7%BA%A6%E6%9D%9F/%E7%BA%A6%E6%9D%9F/"/>
        <content type="html">&lt;h1 id=&#34;约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#约束&#34;&gt;#&lt;/a&gt; 约束&lt;/h1&gt;
&lt;h2 id=&#34;概念&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概念&#34;&gt;#&lt;/a&gt; 概念&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;constraint，在创建表的时候，创建一些约束，保证表中数据的完整性、有效性
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#作用&#34;&gt;#&lt;/a&gt; 作用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;保证表中的数据有效。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;非空约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#非空约束&#34;&gt;#&lt;/a&gt; 非空约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;not null：字段值不能为NULL

create table student(
    id int,
    name varchar(50) not null   // 只有列级 &#39;非空约束&#39;，没有表级 &#39;非空约束&#39;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;唯一性约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#唯一性约束&#34;&gt;#&lt;/a&gt; 唯一性约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;unique:字段值不能重复，但可以为NULL（可以有多条NULL值）

create table student(
    id int,
    name varchar(50) unique
);

案例：
mysql&amp;gt; select * from student;
+------+------+
| id   | name |
+------+------+
|    1 | z    |
|    1 | NULL |
|    1 | NULL |
|    1 | NULL |
|    1 | NULL |
|    1 | NULL |
+------+------+
6 rows in set (0.00 sec)

mysql&amp;gt; desc student;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | YES  |     | NULL    |       |
| name  | varchar(50) | YES  | UNI | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;建立多个字段唯一性约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#建立多个字段唯一性约束&#34;&gt;#&lt;/a&gt; 建立多个字段唯一性约束&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1. 多字段各自唯一性约束
create table student(
    id int unique,
    name varchar(50) unique // 列级约束
);
上边的表，id 和 name 字段各自有唯一性约束，互不影响。

2. 多字段组合后唯一性约束
create table student(
    id int,
    name varchar(50),
    unique(id, name)    // 表级约束
);
上边的表，id 和 name 字段联合起来唯一。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;在Mysql中，如果一个字段同时被 not null 和 unique 约束的话，该字段自动成为主键。（Oracle中不一样）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;主键约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#主键约束&#34;&gt;#&lt;/a&gt; 主键约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;primary key

主键值是每一行的唯一标识
主键特征：unique + not null

写法一：列级约束
create table student(
    id int primary key,
    name varchar(255)
);

写法二：表级约束
create table student(
    id int,
    name varchar(255),
    primary key(id)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;多个字段建立主键约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多个字段建立主键约束&#34;&gt;#&lt;/a&gt; 多个字段建立主键约束&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 复合主键
create table student(
    id int,
    name varchar(255),
    primary key(id, name)
);

//错误 一张表不能建立多个主键
    create table student(
    id int primary key,
    name varchar(255) primary key
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;mysql中自然主键&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql中自然主键&#34;&gt;#&lt;/a&gt; Mysql 中自然主键&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;create table student(
    id int primary key auto_increment,  // 从 1 开始递增
    name varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;外键约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#外键约束&#34;&gt;#&lt;/a&gt; 外键约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; foreign key

create table t_class(
    t_id int primary key auto_increment,
    t_name varchar(50)
);

create table student(
    id int primary key auto_increment,
    name varchar(255),
    cno int,
    foreign key (cno) references t_class(t_id)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：子表中的外键引用父表中的某个字段，被引用的这个字段不一定是主键，但是至少有 unique 约束。（否则，子表不能确定引用的是父表中的那条数据）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：外键可以为 NULL&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;检查性约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#检查性约束&#34;&gt;#&lt;/a&gt; 检查性约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;check(Mysql 不支持， Oracle支持)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.709Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/16.DML/DML/</id>
        <title>DML</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/16.DML/DML/"/>
        <content type="html">&lt;h1 id=&#34;insert&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#insert&#34;&gt;#&lt;/a&gt; insert&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;// 根据字段名，插入数据
// 注意： 字段名和值要一一对应
insert into 表名(字段名1,字段名2...) values(值1,值2...);


//表示插入所有字段
insert into 表名 values(值1,值2...);

// 一次插入多条数据，用逗号隔开
insert into test values(1, &#39;张三&#39;, &#39;1999-12-13&#39;), (2, &#39;李四&#39;, &#39;2000-01-02&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;将查询结果插入到一张表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#将查询结果插入到一张表&#34;&gt;#&lt;/a&gt; 将查询结果插入到一张表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;快速创建dept_bak表，同时数据也存入了dept_bak表中。
create table dept_bak as select * from dept;

将查询到的结果insert into到dept_bak表中
insert into dept_bak select * from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;update&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#update&#34;&gt;#&lt;/a&gt; update&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;update 表名 set 字段名1 = 值1, 字段名2 = 值2 where 条件;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;delete&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#delete&#34;&gt;#&lt;/a&gt; delete&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;delete from 表名 where 条件;

原理：
表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放

优点：支持回滚，可以恢复
缺点：删除效率低
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;快速删除表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#快速删除表&#34;&gt;#&lt;/a&gt; 快速删除表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;truncate 语句删除数据（属于DDL）
    删除效率高，表被一次截断，物理删除

    优点：效率高，快
    缺点：不支持回滚
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.707Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/15.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
        <title>数据类型</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/15.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
        <content type="html">&lt;h1 id=&#34;mysql-数据类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql-数据类型&#34;&gt;#&lt;/a&gt; Mysql 数据类型&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;varchar
    可变长度的字符串
    比较智能，节省空间
    会根据实际长度，动态的分配空间

    缺点：需要动态分配空间，速度慢
    优点：节省空间

char
    定长字符串
    不管实际长度是多少
    分配固定长度的空间去存储数据
    使用不恰当的时候，可能导致空间浪费

    缺点：使用不当，可能导致空间浪费
    优点：不需要动态分配空间，速度快

int

bigint

float

double

date
    短日期类型

datetime
    长日期类型

clob
    字符大对象
    最多存储4g的字符串
    比如：存储一篇文章
    超过255个字符的，尽量都使用clob
    Character Large Object: clob

blob
    存储二进制对象
    图片，声音，视频，等流媒体数据
    往blob字段中插入数据时，需要使用IO流。

date
    短日期：只包括 年月日

    Mysql默认格式：可以将该格式的时间字符串直接插入到date类型的字段中
    %Y-%m-%d


datetime
    长日期：包括 年月日时分秒

    Mysql默认格式：可以将该格式的时间字符串直接插入到date类型的字段中
    %Y-%m-%d %h:%i:%s
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.704Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/14.DDL/DDL/</id>
        <title>DDL</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/14.DDL/DDL/"/>
        <content type="html">&lt;h1 id=&#34;ddl-语句&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ddl-语句&#34;&gt;#&lt;/a&gt; DDL 语句&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;create、drop、alter
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;create-建表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#create-建表&#34;&gt;#&lt;/a&gt; create 建表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;语法格式：
create table 表名 (
    字段名 数据类型,
    字段名 数据类型,
    ...
    字段名 数据类型 //切记！！！   最后一句没有标点符号
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;快速创建表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#快速创建表&#34;&gt;#&lt;/a&gt; 快速创建表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;create table emp2 as select * from emp;
原理：
    将一个查询结果当作一张表新建
    可以快速创建一张表，同时数据也存在。

create table emp2 as select * from emp where ename = &#39;SMITH&#39;;
注意：查询语句可以添加条件等。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;drop-删表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#drop-删表&#34;&gt;#&lt;/a&gt; drop 删表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;语法格式：
drop table 表名;    //当表不存在时，会报错
drop table if exists 表名;  // 当表存在的话，删除
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;alter-对表结构修改&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#alter-对表结构修改&#34;&gt;#&lt;/a&gt; alter 对表结构修改&lt;/h2&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.701Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/13.%E5%88%86%E9%A1%B5/limit/</id>
        <title>Mysql中limit</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/13.%E5%88%86%E9%A1%B5/limit/"/>
        <content type="html">&lt;h1 id=&#34;limit&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#limit&#34;&gt;#&lt;/a&gt; limit&lt;/h1&gt;
&lt;h2 id=&#34;作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#作用&#34;&gt;#&lt;/a&gt; 作用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;将查询结果集的一部分取出来，通常用在分页中。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;语法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#语法&#34;&gt;#&lt;/a&gt; 语法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;limit startIndex, length
startIndex: 起始下标，从0开始
length: 长度

缺省用法：limit length
length: 长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例：按照薪资降序，取出前五名员工。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
缺省用法：

select
    ename, sal
from
    emp
order by
    sal desc
limit 5;

完整用法：

select
    ename, sal
from
    emp
order by
    sal desc
limit 5;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;在mysql中，limit是在order by之后执行的。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;分页&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分页&#34;&gt;#&lt;/a&gt; 分页&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;limit (pageNum - 1) * pageSize, pageSize;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;offset&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#offset&#34;&gt;#&lt;/a&gt; offset&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;作用同limit，配合limit使用，注意：limit此时只能有一个参数

limit pageSize, offset (pageNum - 1) * pageSize;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.698Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/6.union/</id>
        <title>Mysql中union</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/6.union/"/>
        <content type="html">&lt;h1 id=&#34;union&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#union&#34;&gt;#&lt;/a&gt; union&lt;/h1&gt;
&lt;h2 id=&#34;作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#作用&#34;&gt;#&lt;/a&gt; 作用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;合并查询结果集
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;union的效率更高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。
但是union可以减少匹配次数。
在减少匹配次数的情况下，还可以完成两个结果的拼接。

例如：a 连接 b 连接 c
a: 10条记录
b: 10条记录
c: 10条记录
匹配次数为 : 10*10*10 = 1000

如果改为union
a 连接 b ： 10*10 = 100
a 连接 c ： 10*10 = 100
100 + 100 = 200次（union把乘法变成了加法运算）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例：查询工作岗位是 ‘MANAGER’ 和 ‘SALESMAN’ 的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
第一种方法：or
第二种方法：in
第三种方法：union
select ename from emp where job = &#39;MANAGER&#39;
union
select ename from emp where job = &#39;SALESMAN&#39;;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意：&lt;/h2&gt;
&lt;p&gt;在使用 union 需要注意：&lt;br&gt;
1.  union 在结果集合并的时候，要求两个结果列数相同。&lt;br&gt;
2.  MYSQL 中，对应列的数据类型可以不相同，Oracle 里会报错（会要求对应列的数据类型相同）。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.695Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql子查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h1 id=&#34;子查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#子查询&#34;&gt;#&lt;/a&gt; 子查询&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select语句中嵌套select语句，被嵌套的select语句被称为子查询。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;子查询可以出现的位置&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#子查询可以出现的位置&#34;&gt;#&lt;/a&gt; 子查询可以出现的位置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select
    ..(select子).
from
    ..(select子).
where
    ..(select子).
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;where子句中的子查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#where子句中的子查询&#34;&gt;#&lt;/a&gt; where 子句中的子查询&lt;/h2&gt;
&lt;p&gt;案例：找出比最低工资高的员工的姓名和薪资。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select 
    ename, sal
from
    emp
where
    sal &amp;gt; (select min(sal) from emp);

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;from-子查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#from-子查询&#34;&gt;#&lt;/a&gt; from 子查询&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;from后边的子查询，可以当作一张临时的表。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例：找出每个岗位的平均工资的薪资等级&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select
    t.*, sg.grade
from
    (select job, avg(sal) as avgsal from emp group job) t
join
    salgrade
on
    t.avgsal between sg.losal and hisal;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;select-子查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#select-子查询&#34;&gt;#&lt;/a&gt; select 子查询&lt;/h2&gt;
&lt;p&gt;案例：找出每个员工的部门名称，要求显示员工姓名，部门名称。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select
    e.ename, (select d.ename from dept e where e.deptno = d.deptno) as dname
from
    emp e;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;在select语句中的子查询，这个子查询语句只能一次返回一条结果，多于一条，就报错了。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.694Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/4.%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql多表连接查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/4.%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h1 id=&#34;多表连接查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多表连接查询&#34;&gt;#&lt;/a&gt; 多表连接查询&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;语法：
select
    ...
from
    a
join                    // 内连接
    b
on
    a表和b表的连接条件
join                    // 内连接
    c
on
    a表和c表的连接条件
right join              // 外连接
    d
on
    a和d的连接条件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一条 SQL 中内连接和外连接可以混合，都可以出现！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;案例：找出每个员工的部门名称，以及工资等级，要求显示员工名，部门名，薪资，薪资等级。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select 
    e.ename, d.ename, e.sal, sg.grade 
from 
    emp e 
join 
    dept d 
on 
    e.deptno = d.deptno 
join 
    salgrade sg 
on 
    e.sal between sg.losal and hisal;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例：找出每个员工的部门名称，以及工资等级，要求显示员工名，领导名，部门名，薪资，薪资等级。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select 
    e.ename, d.ename, e.sal, sg.grade 
from 
    emp e 
join 
    dept d 
on 
    e.deptno = d.deptno 
join 
    salgrade sg 
on 
    e.sal between sg.losal and hisal
left outer join
    emp l
on
    e.mgr = l.empno;

&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.693Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/3.%E5%A4%96%E8%BF%9E%E6%8E%A5/</id>
        <title>Mysql外连接</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/3.%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
        <content type="html">&lt;h1 id=&#34;外连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#外连接&#34;&gt;#&lt;/a&gt; 外连接&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;外连接当中，两张表关联查询产生主次关系。
左连接和右连接可以相互切换。（
    1. 任何一个左连接都有一个右连接的写法。
    2. 任何一个右连接都有一个左连接的写法。
    ）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;右外连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#右外连接&#34;&gt;#&lt;/a&gt; 右外连接&lt;/h2&gt;
&lt;p&gt;right 代表，将右边的表看作主表，主要是将这张主表的内容全部查出来，捎带着关联查询左边的表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
                                          outer可以省略
select e.ename, d.ename from emp e right [outer] join dept d on e.deptno = e.deptno;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;左外连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#左外连接&#34;&gt;#&lt;/a&gt; 左外连接&lt;/h2&gt;
&lt;p&gt;left 代表，将左边的表看作主表，和右外连接相反。&lt;/p&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;外连接的查询结果条数一定是 &amp;gt;= 内连接的查询结果条数
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.691Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/2.%E5%86%85%E8%BF%9E%E6%8E%A5/</id>
        <title>Mysql内连接</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/2.%E5%86%85%E8%BF%9E%E6%8E%A5/"/>
        <content type="html">&lt;h1 id=&#34;内连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#内连接&#34;&gt;#&lt;/a&gt; 内连接&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;完全能够匹配上这个条件的数据查询出来。
A，B两张表连接查询，AB两张表没有主次关系，是平等的。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;等值连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#等值连接&#34;&gt;#&lt;/a&gt; 等值连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
SQL92语法：

select up.id uId, qpd.id qId from user_profile up, question_practice_detail qpd where up.device_id = qpd.device_id;

SQL99语法：
                                                  [inner] 单词可以省略
select up.id uId, qpd.id qId from user_profile up [inner] join question_practice_detail qpd on up.device_id = qpd.device_id;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SQL92 语法缺点：结构不清晰，表的连接条件和后期进一步的筛选条件，都放到了 where 后边。&lt;/p&gt;
&lt;p&gt;SQL99 语法有点：表连接的条件是独立的，连接之后如果还需要进一步筛选，可以继续添加 where 条件。&lt;/p&gt;
&lt;h2 id=&#34;非等值连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#非等值连接&#34;&gt;#&lt;/a&gt; 非等值连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;条件不是一个等量关系，称为非等值连接
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
案例：找出每个员工的薪资等级，要求显示员工名，薪资，薪资等级

    select 
        e.ename, e.sal, s.grade 
    from
        emp e
    inner join 
        salgrade s
    on 
        e.sal between s.losal and s.hisal;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#自连接&#34;&gt;#&lt;/a&gt; 自连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;一张表看作两张表
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
案例：查询员工的上级领导，要求显示员工名和对应的领导名
    select 
        a.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;
    from
        emp a 
    inner join
        emp b
    on
        a.mgr = b.empno;


&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.690Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql连接查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h1 id=&#34;什么是连接查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是连接查询&#34;&gt;#&lt;/a&gt; 什么是连接查询&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;从一张表中单独查询，称为单表查询。
emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，称为连接查询。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;连接查询分类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#连接查询分类&#34;&gt;#&lt;/a&gt; 连接查询分类&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;根据语法的年代分类：
    1.  SQL92：1992年出现的语法。
    2.  SQL99：1999年出现的语法。

根据表连接的方式分类：
    1. 内连接
       1. 等值连接
       2. 非等值连接
       3. 自连接
    2. 外连接
       1. 左外连接（左连接）
       2. 右外连接（右连接）
    3. 全连接
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;笛卡尔积现象&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#笛卡尔积现象&#34;&gt;#&lt;/a&gt; 笛卡尔积现象&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;当两张表进行连接查询，没有任何条件限制的时候，最终的查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。（一个数学现象）
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
     select up.id uId, qd.id qId from user_profile up, question_detail qd;

    +-----+-----+
    | uId | qId |
    +-----+-----+
    |   7 |   1 |
    |   6 |   1 |
    |   5 |   1 |
    |   4 |   1 |
    |   3 |   1 |
    |   2 |   1 |
    |   1 |   1 |
    |   7 |   2 |
    ...
     112 rows in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;避免笛卡尔积现象&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#避免笛卡尔积现象&#34;&gt;#&lt;/a&gt; 避免笛卡尔积现象&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;增加表连接时的条件。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
    select up.id uId, qpd.id qId from user_profile up,  question_practice_detail qpd where up.device_id = qpd.device_id;

    +-----+-----+
    | uId | qId |
    +-----+-----+
    |   1 |   1 |
    |   2 |   2 |
    |   2 |   3 |
    |   3 |   4 |
    |   4 |   5 |
    |   4 |   6 |
    |   4 |   7 |
    |   2 |   8 |
    |   2 |   9 |
    |   3 |  10 |
    |   4 |  11 |
    |   4 |  12 |
    |   4 |  13 |
    |   2 |  14 |
    |   2 |  15 |
    |   3 |  16 |
    +-----+-----+
    16 rows in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;重点：最终查询结果是16条，但是在匹配中，匹配的次数没有减少，仍然是112次。只不过进行了筛除，匹配的次数并没有减少！！！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：通过观察笛卡尔积现场得出，表的连接次数越多（连接的表越多）程序执行效率越低，应避免表的连接次数过多。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.689Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/</id>
        <title>Mysql中Distinct去重</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/"/>
        <content type="html">&lt;h1 id=&#34;distinct-去重&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#distinct-去重&#34;&gt;#&lt;/a&gt; Distinct 去重&lt;/h1&gt;
&lt;p&gt;把查询结果去除重复记录&lt;/p&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;distinct 只能出现在所有字段的最前方。&lt;br&gt;
select name, distinct job from emp;// 错误&lt;br&gt;
 select distinct name, job from emp;// 正确&lt;br&gt;
这样表示对 name 和 job 组合起来进行去重。&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.686Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/10.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/</id>
        <title>Mysql执行顺序</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/10.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;h1 id=&#34;执行顺序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#执行顺序&#34;&gt;#&lt;/a&gt; 执行顺序&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;select
    ...
from 
    ...
where
    ...
group by
    ...
having
    ...
order by
    ...

执行顺序：
1.  from
2.  where
3.  group by
4.  having
5.  select
6.  order by
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从某张表查询数据，&lt;br&gt;
先经过 where 条件筛选出有价值的数据，&lt;br&gt;
对这些数据进行分组，&lt;br&gt;
分组后可以使用 having 继续筛选数据&lt;br&gt;
 select 查询出来&lt;br&gt;
最后排序输出&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.683Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/</id>
        <title>Mysql概述</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/"/>
        <content type="html">&lt;p&gt;1. 什么是数据库？什么是数据库管理系统？什么是 SQL？他们之间的关系是什么？&lt;/p&gt;
&lt;p&gt;​	数据库：&lt;/p&gt;
&lt;p&gt;​		英文单词 DataBase，简称 DB。按照一定格式存储数据的一些文件的组合。&lt;/p&gt;
&lt;p&gt;​		顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。&lt;/p&gt;
&lt;p&gt;​	数据库管理系统：&lt;/p&gt;
&lt;p&gt;​		DataBaseManagement，简称 DBMS。&lt;/p&gt;
&lt;p&gt;​		数据库管理系统是专门用来管理数据库中的数据，数据库管理系统可以对数据库当中的数据进行增删改查。&lt;/p&gt;
&lt;p&gt;​	常见的数据库管理系统：&lt;/p&gt;
&lt;p&gt;​		Mysql，Oracle，MS，SqlServer，DB2，sybase 等。。。。。。&lt;/p&gt;
&lt;p&gt;​	SQL:&lt;/p&gt;
&lt;p&gt;​		结构化查询语言。程序员需要学习 SQL 语句，程序员通过编写 SQL 语句，然后 DBMS 负责执行 SQL 语句，最终来完成数据库中数据的增删改查操作。&lt;/p&gt;
&lt;p&gt;​		SQL 是一套标准，主要学习的就是 SQL 语句。这个 SQL 在 mysql 中可以使用，同时在 Oracle 中也可以使用，在 DB2 中也可以使用。&lt;/p&gt;
&lt;p&gt;​	三者之间的关系：&lt;/p&gt;
&lt;p&gt;​		DBMS–&amp;gt; 执行–&amp;gt;SQL–&amp;gt; 操作–&amp;gt;DB&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.680Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/9.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql分组查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/9.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h2 id=&#34;分组查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分组查询&#34;&gt;#&lt;/a&gt; 分组查询&lt;/h2&gt;
&lt;h3 id=&#34;sql语句各个关键字的执行顺序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#sql语句各个关键字的执行顺序&#34;&gt;#&lt;/a&gt; SQL 语句各个关键字的执行顺序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select
    ...         5
from
    ...         1
where
    ...         2
group by
    ...         3
having
    ...         4
order by
    ...         6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行顺序：&lt;br&gt;
1. from&lt;br&gt;
2. where&lt;br&gt;
3. group by&lt;br&gt;
4. having&lt;br&gt;
5. select&lt;br&gt;
6. order by&lt;/p&gt;
&lt;h3 id=&#34;重点结论&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#重点结论&#34;&gt;#&lt;/a&gt; 重点结论&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;在一条select语句当中，如果有group by语句的话，select后面只能跟分组函数，以及参加分组的字段。其他的一律不能跟。（Mysql可以执行，但没有意义，Oracle数据库当中会报错）
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.675Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/8.%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E8%A1%8C%E6%95%B0/</id>
        <title>Mysql多行处理行数</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/8.%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E8%A1%8C%E6%95%B0/"/>
        <content type="html">&lt;h2 id=&#34;多行处理行数分组函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多行处理行数分组函数&#34;&gt;#&lt;/a&gt; 多行处理行数（分组函数）&lt;/h2&gt;
&lt;p&gt;特点：输入多行、最终输出一行&lt;/p&gt;
&lt;h4 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;分组函数在使用时必须先进行分组，然后才能使用。
如果你没有对数据进行分组，整张表默认为一组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;count-计数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#count-计数&#34;&gt;#&lt;/a&gt; count 计数&lt;/h3&gt;
&lt;p&gt;计算员工数量总和&lt;br&gt;
 select count (name) from emp;&lt;/p&gt;
&lt;h3 id=&#34;sum-求和&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#sum-求和&#34;&gt;#&lt;/a&gt; sum 求和&lt;/h3&gt;
&lt;p&gt;计算工资合&lt;br&gt;
 select sum (sal) from emp;&lt;/p&gt;
&lt;h3 id=&#34;avg-平均值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#avg-平均值&#34;&gt;#&lt;/a&gt; avg 平均值&lt;/h3&gt;
&lt;p&gt;计算平均工资&lt;br&gt;
 select avg (sal) from emp;&lt;/p&gt;
&lt;h3 id=&#34;max-最大值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#max-最大值&#34;&gt;#&lt;/a&gt; max 最大值&lt;/h3&gt;
&lt;p&gt;找出最高工资&lt;br&gt;
 select max (sal) from emp;&lt;/p&gt;
&lt;h3 id=&#34;min-最小值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#min-最小值&#34;&gt;#&lt;/a&gt; min 最小值&lt;/h3&gt;
&lt;p&gt;找出最低工资&lt;br&gt;
 select min (sal) from emp;&lt;/p&gt;
&lt;h2 id=&#34;分组函数使用时需要注意的地方&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分组函数使用时需要注意的地方&#34;&gt;#&lt;/a&gt; 分组函数使用时，需要注意的地方&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1. 分组函数自动忽略 NULL, 不需要提前处理。
 例如：求所有员工津贴/补助的总和。
    select sum(comm) from emp;//不需要加where comm is not null条件。
2. 分组函数count(*) 和 count(具体字段)的区别。
   1. count(具体字段)：表示统计该字段下所有不为 NULL 的元素的总数。
   2. count(*)：统计表中所有行数。
3. 分组函数不能直接用在where子句中。
 例如：找出比最低工资高的员工信息。
 select ename, sal from emp where sal &amp;gt; min(sal);// 错误SQL语句
4. 所有分组函数可以组合起来一起使用。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.673Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/7.%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</id>
        <title>Mysql单行处理函数</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/7.%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
        <content type="html">&lt;p&gt;单行处理函数也叫做数据处理函数&lt;/p&gt;
&lt;p&gt;单行处理函数的特点：&lt;/p&gt;
&lt;p&gt;​	一个输入对应一个输出&lt;/p&gt;
&lt;p&gt;和单行处理函数相对的是：&lt;/p&gt;
&lt;p&gt;​	多行处理函数（特点：多个输入，对应一个输出）&lt;/p&gt;
&lt;p&gt;常见的单行处理函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;lower 转换小写&lt;/p&gt;
&lt;p&gt;select  lower(name)  from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;upper 转换大写&lt;/p&gt;
&lt;p&gt;select  upper(name)  from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;substr 取子串&lt;/p&gt;
&lt;p&gt;substr (被截取的字符串，起始下标，截取的长度)// 注意起始下标从 1 开始，没有 0&lt;/p&gt;
&lt;p&gt;select  substr(name, 1, length(name))  from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;concat 进行字符串拼接&lt;/p&gt;
&lt;p&gt;select concat(name, countrycode) from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;length 取长度&lt;/p&gt;
&lt;p&gt;select length(name) from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;trim 去除空格&lt;/p&gt;
&lt;p&gt;select * from city where name = trim (’   King   &#39;);// 将查询条件中的前后空格去除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;round 四舍五入&lt;/p&gt;
&lt;p&gt;select 字段 from 表名；&lt;/p&gt;
&lt;p&gt;select name from city;&lt;/p&gt;
&lt;p&gt;select ‘abc’ from city;//select 后面直接跟 “字面量”/“字面值”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：select 后面可以跟某个表的字段名（可以等同看作变量名），也可以跟字面量 / 字面值（数据）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;select round (1276.567, 2) from city;// 保留二位小数 1276.57&lt;/p&gt;
&lt;p&gt;select round (1276.567, 1) from city;// 保留一位小数 1276.6&lt;/p&gt;
&lt;p&gt;select round (1276.567, 0) from city;// 保留整数 1277&lt;/p&gt;
&lt;p&gt;select round (1276.567, -1) from city;// 保留到十位 1270&lt;/p&gt;
&lt;p&gt;select round (1276.567, -2) from city;// 保留到百位 1280&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rand 生成随机数&lt;/p&gt;
&lt;p&gt;select rand() from city;&lt;/p&gt;
&lt;p&gt;例如：生成 100 以内的随机数&lt;/p&gt;
&lt;p&gt;select round(rand() * 100, 0) from city;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ifnull 可以将 null 转换成一个具体值。&lt;/p&gt;
&lt;p&gt;ifnull 是空处理函数。专门处理空的。（因为在所有数据库中，只要有 null 参与的数学运算，最终结果都为 null）&lt;/p&gt;
&lt;p&gt;ifnull 函数语法：ifnull (数据，被当作那个值)&lt;/p&gt;
&lt;p&gt;如果 “数据” 为 null 的时候，把这个数据当作那个值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;case when … then … when … then … else … end&lt;/p&gt;
&lt;p&gt;例如：当员工的岗位为 MANAGER 的时候，工资上调 %10，当工作岗位是 SALESMAN 的时候，工资上调 %50，其他正常。&lt;/p&gt;
&lt;p&gt;（注意：不修改数据库，只是将查询结果显示为工资上调）&lt;/p&gt;
&lt;p&gt;select&lt;/p&gt;
&lt;p&gt;ename,&lt;/p&gt;
&lt;p&gt;job,&lt;/p&gt;
&lt;p&gt;sal as oldsal,&lt;/p&gt;
&lt;p&gt;(case when ‘MANAGER’ then sal*1.1 when ‘SALESMAN’ then sal**1.5 else sal end) as newsal&lt;/p&gt;
&lt;p&gt;from emp;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;format 数字格式化&lt;br&gt;
 format (数字，‘格式’)&lt;/p&gt;
&lt;p&gt;select ename, (sal, ‘$999,999’) from emp;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;str_to_date&lt;/p&gt;
&lt;p&gt;字符串转换为 date 类型&lt;/p&gt;
&lt;p&gt;str_to_date (‘日期字符串’, ‘日期格式’)&lt;/p&gt;
&lt;p&gt;Mysql 中日期格式：&lt;br&gt;
% Y 年&lt;br&gt;
 % m 月&lt;br&gt;
 % d 日&lt;br&gt;
 % h 时&lt;br&gt;
 % i 分&lt;br&gt;
 % s 秒&lt;/p&gt;
&lt;p&gt;Java 中日期格式：&lt;br&gt;
yyyy-MM-dd HH:mm:ss SSS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;date_format&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从 date 类型转换为具有一定格式的字符串类型&lt;/p&gt;
&lt;p&gt;date_format (日期值，‘日期格式’)&lt;/p&gt;
&lt;p&gt;insert into test values(1, ‘zhangsan’, str_to_date(‘10:13:20 11-11-1999’, ‘%h:%i:%s %d-%m-%Y’));&lt;/p&gt;
&lt;p&gt;insert into test values (1, ‘zhangsan’, str_to_date (‘11-1999’, ‘% m-% Y’));//date 类型为年月日，插入的值不完整，所以报错&lt;/p&gt;
&lt;p&gt;insert into test values(1, ‘zhangsan’, str_to_date(‘11-1999’, ‘11-%m-%Y’));&lt;/p&gt;
&lt;p&gt;insert into test values(1, ‘zhangsan’, str_to_date(‘10-11-1999’, ‘10-%m-%Y’));&lt;/p&gt;
&lt;p&gt;insert into test values (1, ‘zhangsan’, str_to_date (‘10-11-1999’, ‘% d-% m-% Y’));// 正确&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.670Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
        <title>存储过程</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/25.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
        <content type="html">&lt;h1 id=&#34;mysql存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql存储过程&#34;&gt;#&lt;/a&gt; Mysql 存储过程&lt;/h1&gt;
&lt;p&gt;存储过程是在数据库中定义一些 SQL 语句的集合，可以直接去调用这些存储过程来执行已经定义好的 SQL 语句。&lt;/p&gt;
&lt;p&gt;触发器和存储过程相似，都是嵌入到 MySql 中的一段儿程序。触发器是由事件来触发某个操作。当数据库执行这些事件时，就会激活触发器来执行相应的操作。&lt;/p&gt;
&lt;h2 id=&#34;存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#存储过程&#34;&gt;#&lt;/a&gt; 存储过程&lt;/h2&gt;
&lt;p&gt;数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。例如，为了确认学生能否毕业，需要同时查询学生档案、成绩表和从何表，此时就需要使用多条 SQL 语句来针对这几个数据表完成处理要求。存储过程就是这样一组为了完成特定功能的 SQL 语句的集合。&lt;/p&gt;
&lt;p&gt;使用存储过程的目的是将经常或复杂的工作预先使用 SQL 语句写好，并用一个指定的名称存储起来，这个过程经编译和优化由存储在数据库服务器中，因此成为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需要调用 “CALL 存储过程名字” 即可自动完成。&lt;/p&gt;
&lt;p&gt;常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。&lt;/p&gt;
&lt;p&gt;一个存储过程即一个可编程的函数，它可以在数据库中创建并保存，一般由 SQL 语句和一些特殊控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySql5.0版本以前并不支持存储过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存储过程时数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以被调用，完成指定的功能操作。&lt;/p&gt;
&lt;p&gt;使用存储过程不仅可以提高数据的访问效率，同时也可以提高数据库使用的安全性。&lt;/p&gt;
&lt;p&gt;对于调用者来说，存储过程封装了 SQL 语句，调用者无需考虑逻辑功能的具体实现过程。只是简单调用即可，它可以被 Java 和 C# 等编程语言调用。&lt;/p&gt;
&lt;h2 id=&#34;创建存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建存储过程&#34;&gt;#&lt;/a&gt; 创建存储过程&lt;/h2&gt;
&lt;p&gt;创建存储过程使用 create procedure 语句，语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create procedure &amp;lt;过程名&amp;gt; ([过程参数[,...]]) &amp;lt;过程体&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，过程参数是存储过程的参数列表。MySQL 存储过程支持三种类型的参数，即输入参数，输出参数和输入 / 输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输出 / 输出参数既可以充当输入参数也可以充当输出参数。格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ IN | OUT | INOUT ] &amp;lt;参出名&amp;gt; &amp;lt;类型&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过程体是存储过程的主体部分，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 &lt;strong&gt;BEGIN&lt;/strong&gt; 开始，以关键字 &lt;strong&gt;END&lt;/strong&gt; 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。&lt;/p&gt;
&lt;p&gt;在 Mysql 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符号，那么 MySQL 服务器在处理存储过程时，会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的额结束符，而不再去处理存储过程体后面的 SQL 语句，这样显然不行。为了解决以上问题，通常使用 &lt;strong&gt;DELIMITER&lt;/strong&gt; 命令将结束命令修改为其他字符。语法格式如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELIMITER $$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;语法说明如下：&lt;br&gt;
$$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个 “？” 或两个 “￥“ 等。&lt;br&gt;
当使用 DELIMITER 命令时，应该避免使用反斜杠 &amp;quot;&amp;quot; 字符，因为它是 MySQL 的转义字符。&lt;/p&gt;
&lt;p&gt;在 MySQL 命令行客户端使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; DELIMITER ??
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行该命令后，任何命令、语句或程序的结束标志就换为两个问号 &amp;quot;??&amp;quot; 了。&lt;/p&gt;
&lt;p&gt;注意：DELIMITER 和分号 “;” 之间一定要有一个空格（使用分号 &amp;quot;;&amp;quot; 作为 MySQL 语句结束符）。&lt;/p&gt;
&lt;p&gt;在创建存储过程时，必须具有 create routine 权限。&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;
mysql&amp;gt; DELIMITER //&lt;br&gt;
mysql&amp;gt; CREATE PROCEDURE GetScoreByStu&lt;br&gt;
-&amp;gt; (IN name VARCHAR(30))&lt;br&gt;
-&amp;gt; BEGIN&lt;br&gt;
-&amp;gt; SELECT student_score FROM tb_students_score&lt;br&gt;
-&amp;gt; WHERE student_name=name;&lt;br&gt;
-&amp;gt; END //&lt;br&gt;
Query OK, 0 rows affected (0.01 sec)&lt;/p&gt;
&lt;h2 id=&#34;12-查看存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#12-查看存储过程&#34;&gt;#&lt;/a&gt; 1.2 查看存储过程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;SHOW PROCEDURE STATUS LIKE 存储过程名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以查看存储过程的定义，语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW CREATE PROCEDURE 存储过程名
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13修改存储过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#13修改存储过程&#34;&gt;#&lt;/a&gt; 1.3 修改存储过程&lt;/h2&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.654Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/24.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</id>
        <title>主从同步机制</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/24.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
        <content type="html">&lt;h1 id=&#34;主从同步机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#主从同步机制&#34;&gt;#&lt;/a&gt; 主从同步机制&lt;/h1&gt;
&lt;p&gt;作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以用作一种备份机制，相当于热备份&lt;/li&gt;
&lt;li&gt;可以用做读写分离，均衡数据库负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;概述&lt;/p&gt;
&lt;p&gt;MySQL 主从复制也能够称为 MySQL 主从同步，它是构建数据库高可用集群架构的基础。它经过将一台主机的数据复制到其余一台或多台主机上，并从新应用 relay log 中的 SQL 语句来实现复制功能。MySQL 支持单向、双向、链式级联、异步复制，5.5 版本以后加入的半同步复制，5.6 版本以后的 GTID 复制，MySQL5.7 的多源复制、并行复制、loss-less 复制。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.651Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/23.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</id>
        <title>数据库范式</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/23.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
        <content type="html">&lt;h1 id=&#34;数据库设计三范式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数据库设计三范式&#34;&gt;#&lt;/a&gt; 数据库设计三范式&lt;/h1&gt;
&lt;p&gt;什么是数据库设计范式？&lt;br&gt;
数据库表的设计依据。&lt;/p&gt;
&lt;h2 id=&#34;第一范式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第一范式&#34;&gt;#&lt;/a&gt; 第一范式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;要求任何一张表必须有主键，每一个字段原子性不可再分

案例：
学生编号    学生姓名    联系方式
1001        张三        zs@gmail.com,135999999
1002        李四        li@gmail.com,136999999
1003        王五        ww@gmail.com,137999999

以上表设计不满足第一范式--没有主键，联系方式可拆分

修改：
学生编号(pk)    学生姓名        邮箱                联系电话
1001            张三        zs@gmail.com       135999999
1002            李四        li@gmail.com       136999999
1003            王五        ww@gmail.com       137999999
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第二范式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第二范式&#34;&gt;#&lt;/a&gt; 第二范式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;建立在第一范式基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖

案例：
学生编号        学生姓名        教师编号        教师姓名
1001            张三            001             王老师
1002            李四            002             赵老师
1002            李四            002             王老师
1001            张三            001             赵老师

以上表设计不满足第一范式--没有主键

修改：
学生编号    +    教师编号（pk）        学生姓名          教师姓名
1001            001             张三               王老师
1002            002             李四               赵老师
1002            002             李四               王老师
1001            001             张三               赵老师

学生编号和教师编号连个字段做复合主键
以上修改完之后表不满足第二范式--非主键字段，产生部分依赖(学生和教师关系产生多对多关系)
    导致：数据冗余，空间浪费

修改：
学生编号    学生姓名
1001        张三
1002        李四

教师编号    教师姓名
001         王老师
002         赵老师

学生教师联合表
id(pk)      学生编号(fk)   教师编号(fk)
1            1001          001
2            1002          001
3            1001          002
4            1002          002
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第三范式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第三范式&#34;&gt;#&lt;/a&gt; 第三范式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;建立在第二范式基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖

案例：
学生编号（PK）        学生姓名        班级编号         班级名称
1001                   张三            01             一班
1002                   李四            02             二班
1003                   王五            03             三班
1004                   赵六            03             四班

以上表的设计满足第一范式--有主键
以上表的设计满足第二范式--主键是单一主键，不是复合主键，没有产生部分依赖（表中学生和班级是一对多关系）

以上表不满足第三范式--传递性依赖（班级名称依赖班级编号，产生了传递依赖，不符合第三范式，产生了数据冗余）

修改：
班级表
班级编号（pk）      班级名称
01                  一班
02                  二班
...

学生表
学生编号（pk）      学生姓名        班级编号
1001                张三            01
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用：避免数据冗余，空间的浪费&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#总结&#34;&gt;#&lt;/a&gt; 总结&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;一对多：
    一对多，两张表，多的表加外键

多对多：
    多对多，三张表，关系表两个外键

一对一：
    在一对一中，可能存在表字段太多，太庞大，需要拆分表
    
    案例：
    id      login_name      login_pwd       real_name       email
    1           admin       admin           张三            zs@gmail.com


    修改：
    登录信息表：
    id      login_name      login_pwd
    1       admin           admin

    用户详细信息表：
    id      real_name       email           login_id(fk+unique)
    100        admin        zs@gmail.com        1

    在一对一拆分表时，可以使用 外键+唯一性约束 设计表
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;重点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#重点&#34;&gt;#&lt;/a&gt; 重点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;数据库设计三范式是理论上的。
实践和理论有时候有偏差。
最终的目的都是为了满足客户的需求，有的时候会拿数据冗余换速度。因为Sql中，表和表之间的连接次数过多，效率越低（笛卡尔积）
有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.648Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/22.DBA%E5%91%BD%E4%BB%A4/DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
        <title>DBA命令</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/22.DBA%E5%91%BD%E4%BB%A4/DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
        <content type="html">&lt;h1 id=&#34;dba命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dba命令&#34;&gt;#&lt;/a&gt; DBA 命令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;必须超级管理员操作&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;新建用户&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#新建用户&#34;&gt;#&lt;/a&gt; 新建用户&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create USER username IDENTIFIED by &#39;password&#39;;

create USER &#39;username&#39;@&#39;host&#39; IDENTIFIED by &#39;password&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;username：创建的用户名。&lt;/p&gt;
&lt;p&gt;host：指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符 %&lt;/p&gt;
&lt;p&gt;password：该用户的登陆密码。密码可以为空，如果为空则该用户可以不需要密码登陆服务器。&lt;/p&gt;
&lt;h2 id=&#34;授权&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#授权&#34;&gt;#&lt;/a&gt; 授权&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;GRANT SELECT,INSERT on *.* to &#39;guest&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;.&lt;/em&gt;：表示表示所有库的所有表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant all privileges on 数据库 to &#39;用户名&#39;@&#39;IP地址&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;回收权限&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#回收权限&#34;&gt;#&lt;/a&gt; 回收权限&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;revoke all privileges from 数据库 to &#39;用户名&#39;@&#39;IP地址&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;all privileges 指除了 grant 之外的所有权限，也可以自己设置权限&lt;/p&gt;
&lt;p&gt;例如：grant insert on world.* to ‘用户名’@‘IP 地址’;(只能对 world 数据库做插入操作，world.* 表示对 world 中所有表）&lt;/p&gt;
&lt;h2 id=&#34;导出导入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#导出导入&#34;&gt;#&lt;/a&gt; 导出导入&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;导出
    在windows的dos命令窗口中：
    mysqldump nk&amp;gt;D:\nk.sql -uroot -proot

    导出指定的表:导出nk数据库中 student表
    mysqldump nk student&amp;gt;D:\nk.sql -uroot -proot


导入
    登录到mysql中，创建数据库 create database nk;
    然后导入sql文件
    source D:\nk.sql
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.645Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/21.%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/</id>
        <title>视图</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/21.%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/"/>
        <content type="html">&lt;h1 id=&#34;视图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#视图&#34;&gt;#&lt;/a&gt; 视图&lt;/h1&gt;
&lt;p&gt;什么是视图？&lt;br&gt;
view：站在不同的角度，去看待同一份数据&lt;/p&gt;
&lt;h2 id=&#34;创建视图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建视图&#34;&gt;#&lt;/a&gt; 创建视图&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create view 视图名 as DQL语句;

create view emp_view as select * from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：只有 DQL 语句才能以 view 的形式创建&lt;/p&gt;
&lt;h2 id=&#34;删除视图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#删除视图&#34;&gt;#&lt;/a&gt; 删除视图&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;drop view emp_view;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;视图作用可以干什么方便-简化开发-利于维护&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#视图作用可以干什么方便-简化开发-利于维护&#34;&gt;#&lt;/a&gt; 视图作用（可以干什么）–方便、简化开发、利于维护&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作

特点：对视图的操作，会影响到原表数据

select * from dept2_view;

insert into dept2_view(deptno, dname, loc) vlaues(60, &#39;SALES&#39;, &#39;BJ&#39;);// （insert、delete、update）操作会影响到原表
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;视图对象在实际开发中，到底有什么作用？&lt;br&gt;
假设有一条 SQL 语句，需要在不同位置反复使用，每次使用需要重新编写，可以把这条复杂的 SQL 语句以视图对象的形式创建出来&lt;br&gt;
在需要编写这条 SQL 语句的位置直接使用视图对象。可以简化开发，并且利于后期维护。因为只需要修改一个位置就行了，只需要修改视图对象所映射的 SQL 语句&lt;/p&gt;
&lt;p&gt;使用视图开发的时候，可以像使用 table 一样，可以对视图进行增删改查等操作。&lt;br&gt;
视图对象是存储在硬盘上的，不会消失&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.642Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</id>
        <title>索引失效</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
        <content type="html">&lt;h1 id=&#34;索引失效&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#索引失效&#34;&gt;#&lt;/a&gt; 索引失效&lt;/h1&gt;
&lt;p&gt;什么时候索引会失效？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一种情况：
 select * from t_user where name like &#39;%z&#39;;

 因为模糊匹配中以 &#39;%&#39; 开头了，索引失效（存在索引，但不走索引）


第二种情况：
 使用or的时候会失效，如果使用or，那么要求or两边字段条件都要有索引，才会走索引。如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效


第三种情况：
 使用复合索引的时候，没有使用左侧的列查找，索引失效( 最左原则 )
 create index emp_job_sal_index on emp(job, sal);

 explain select * from emp where job = &#39;MANAGER&#39;;// 走索引
 explain select * from emp where sal = 1000;// 索引失效


第四种情况：
 在where当中，索引参与了数学运算，索引失效

 create index emp_sal_index on emp(sal);

 explain select * from emp where sal = 800;// 走索引
 explain select * from emp where sal = 800 + 100;// 走索引

 explain select * from emp where sal + 100 = 800;// 索引失效


第五种情况：
 在where当中，索引列使用了函数，索引失效

 create index emp_ename_index on emp(ename);

 explain select * from emp where ename = &#39;SIMTH&#39;;// 走索引

 explain select * from emp where lower(ename) = &#39;simth&#39;;// 索引失效


第六种情况：....
第七种情况：....
...



索引是数据库优化的重要手段，优化的时候，优先考虑的因素就是索引。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;索引分类：&lt;br&gt;
单一索引：&lt;br&gt;
复合索引：&lt;br&gt;
主键索引：&lt;br&gt;
唯一性索引：&lt;br&gt;
…&lt;/p&gt;
&lt;p&gt;注意：唯一性比较弱的字段上添加索引用处不大。（可能存在大量重复数据，这个时候索引起不到什么作用，越唯一，效率越高）&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.639Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95/</id>
        <title>索引</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/20.%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95/"/>
        <content type="html">&lt;h1 id=&#34;索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#索引&#34;&gt;#&lt;/a&gt; 索引&lt;/h1&gt;
&lt;p&gt;什么是索引？&lt;br&gt;
索引在数据库表的字段上添加的，是为了提高检索（查询）效率存在的一种机制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一张表的一个字段可以添加一个索引，多个字段可以联合起来添加索引

索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举例：&lt;br&gt;
查字典：&lt;br&gt;
1. 一页一页查找，直到找到为止。这种查找属于全表扫描，效率低&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3. 通过目录（索引），去定位一个大概的位置，然后直接定位到该位置，做局域性扫描，缩小扫描的范围，快速的查找。这种方式属于索引检索，效率高

Mysql中查询的两种方式：
    1. 全表扫描
    2. 根据索引检索
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;br&gt;
在 Mysql 数据库当中索引也是需要排序的，并且这个索引的排序和 TreeSet 数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！&lt;br&gt;
在 Mysq 中索引是一个 B-Tree 数据结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;遵循左小右大原则存放，采用中序遍历方式遍历取数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在任何数据库当中，主键都会自动添加索引对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Mysql 中，一个字段上如果右 unique 约束的话，也会自动创建索引对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Mysql 当中，索引是一个单独的对象，不同的存储引擎以不同形式存在。&lt;/strong&gt;&lt;br&gt;
1. 在 MyISAM 存储引擎中，索引存储在一个.MYI 文件中&lt;br&gt;
 2. 在 InnoDB 存储引擎当中，索引存储在一个叫 tablespace 当中。&lt;br&gt;
3. 在 Memory 存储引擎当中，被存储在内存当中&lt;br&gt;
不管索引存储在哪里，索引在 Mysql 中都是一个树的形式存在。（自平衡二叉树：B-Tree）&lt;/p&gt;
&lt;h2 id=&#34;在mysql中主键以及unique字段上都会自动添加索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#在mysql中主键以及unique字段上都会自动添加索引&#34;&gt;#&lt;/a&gt; 在 Mysql 中，主键以及 unique 字段上都会自动添加索引&lt;/h2&gt;
&lt;p&gt;什么条件下，需要考虑给字段添加索引？&lt;br&gt;
1. 数据量庞大（需要测试）&lt;br&gt;
2. 该字段经常出现在 where 查询条件中&lt;br&gt;
 3. 该字段很少的 DML 操作（因为 DML 之后，索引经常需要重新排序）&lt;br&gt;
注意：&lt;br&gt;
建议不要随意添加索引，因为索引也是需要维护的，太多反而会降低系统性能&lt;br&gt;
建议通过主键查询，建议通过 unique 约束字段进行查询，效率是比较高的&lt;/p&gt;
&lt;h2 id=&#34;创建和删除索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建和删除索引&#34;&gt;#&lt;/a&gt; 创建和删除索引&lt;/h2&gt;
&lt;h3 id=&#34;创建索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建索引&#34;&gt;#&lt;/a&gt; 创建索引&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;create index 索引名 on 表名(要添加索引的字段名);

create index emp_ename_index on emp(ename);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#删除索引&#34;&gt;#&lt;/a&gt; 删除索引&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;drop index 索引名 on 表名;

drop index emp_ename_index on emp;


在Mysql中查看一个SQL语句是否使用了索引进行检索
explain select * from t_user where name = &#39;zhangsan6&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举例：&lt;br&gt;
## 查看 sql 语句执行详情&lt;br&gt;
 mysql&amp;gt; explain select * from t_user where name = ‘zhangsan6’;&lt;br&gt;
±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+&lt;br&gt;
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |&lt;br&gt;
±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+&lt;br&gt;
|  1 | SIMPLE      | t_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   12 |    10.00 | Using where |&lt;br&gt;
±—±------------±-------±-----------±-----±--------------±-----±--------±-----±-----±---------±------------+&lt;br&gt;
1 row in set, 1 warning (0.00 sec)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## 为name字段创建索引
create index user_name_index on t_user(name);

## 在索引创建后，重新执行sql语句，查看sql执行情况
mysql&amp;gt; explain select * from t_user where name = &#39;zhangsan6&#39;;
+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | t_user | NULL       | ref  | user_name_index | user_name_index | 1023    | const |    1 |   100.00 | Using index |
+----+-------------+--------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.638Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
        <title>事务隔离</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
        <content type="html">&lt;h1 id=&#34;事务隔离级别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务隔离级别&#34;&gt;#&lt;/a&gt; 事务隔离级别&lt;/h1&gt;
&lt;h2 id=&#34;分类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分类&#34;&gt;#&lt;/a&gt; 分类&lt;/h2&gt;
&lt;h3 id=&#34;读未提交read-uncommitted&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#读未提交read-uncommitted&#34;&gt;#&lt;/a&gt; 读未提交：read uncommitted&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;概念：
    事务A可以读取到事务B未提交的数据

存在脏读现象（Dirty Rread）：称读到脏数据
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;读已提交readcommitted&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#读已提交readcommitted&#34;&gt;#&lt;/a&gt; 读已提交：readcommitted&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;概念：
    事务A只能读取到事务B提交之后的数据
这种隔离级别解决了脏读现象

存在‘不可重复读取数据’问题：在事务开启后，每次读取到的数据可能不一致。比如A开始事务循环读取数据的过程中，B事务不断修改数据并提交，导致A事务在后续的数据读取过程中，数据产生不一致的现象

这种隔离级别是比较真实的数据，每一次读到的数据绝对真实
注意：Oracle数据库默认的隔离级别是： read committed
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;可重复读repeatable-read&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#可重复读repeatable-read&#34;&gt;#&lt;/a&gt; 可重复读：repeatable read&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;概念：
    事务A开启后，不管多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据修改，并且提交了。事务A读取到的数据还是没有发生改变，这就是可重复读
解决了不可重复读的现象

存在幻读现象：每一次读取到的数据都是幻象，不够真实

Mysql默认隔离级别
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;序列化串行化serializable&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#序列化串行化serializable&#34;&gt;#&lt;/a&gt; 序列化 / 串行化：serializable&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;概念：

隔离级别最高，效率最低。解决了所有问题
不能并发
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试隔离级别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#测试隔离级别&#34;&gt;#&lt;/a&gt; 测试隔离级别&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;查看变量：
show variables;
通过like 通配符查询
show variables like &#39;%isolation%&#39;;

查看隔离级别：
select @@transaction_isolation; 

设置全局事务等级
set global transaction isolation level read committed;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.632Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/</id>
        <title>事务</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/19.%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1/"/>
        <content type="html">&lt;h1 id=&#34;事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务&#34;&gt;#&lt;/a&gt; 事务&lt;/h1&gt;
&lt;p&gt;什么是事务？&lt;br&gt;
一个事务就是一个完整的业务逻辑。&lt;br&gt;
是一个最小的工作单元。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如转账的业务逻辑，就是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本质：就是多条 DML 语句同时成功或者同时失败&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只有 DML 语句和事务有关系，其他语句无关。&lt;/strong&gt;&lt;br&gt;
insert&lt;br&gt;
update&lt;br&gt;
delete&lt;br&gt;
 因为以上三个语句是操作数据库中数据的&lt;/p&gt;
&lt;p&gt;事务是怎么做到同时成功或者同时失败的？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InnoDB：提供一组用于记录事务特性活动的日志文件

在事务执行的过程中，每一条DML的操作都会被记录到“事务特性活动的日志文件”中
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在事务执行的过程中，可以提交事务，也可以回滚事务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;提交事务： 清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中
    标志着事务的结束，并且是一种全部成功的结束

回滚事务： 将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件
    回滚事务标志着事务的结束，并且是一种全部失败的结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;提交事务-回滚事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#提交事务-回滚事务&#34;&gt;#&lt;/a&gt; 提交事务、回滚事务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;提交事务：commit
回滚事务：rollback (回滚只能回滚到上一次的提交点)

事务对应的单词：transaction

Mysql中默认情况下是自动提交事务的（自动提交）

开启事务
    start transaction;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事务特性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务特性&#34;&gt;#&lt;/a&gt; 事务特性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;A：原子性
    说明事务是最小工作单元，不可再分

C：一致性
    所有事务要求，在同一个事务中，所有操作必须同时成功，或者同时失败，以保证数据的一致性

I：隔离性
    A事务和B事务之间具有一定的隔离

D：持久性
    事务最终结束的一个保障，事务提交，将没有保存到硬盘上的数据保存到硬盘上
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.631Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/18.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
        <title>存储引擎</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/18.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
        <content type="html">&lt;h1 id=&#34;存储引擎&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#存储引擎&#34;&gt;#&lt;/a&gt; 存储引擎&lt;/h1&gt;
&lt;p&gt;什么是存储引擎？有什么用？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;存储引擎是Mysql中特有的一个术语。其他数据库中没有（Oracle中也有，不叫这个名字）

存储引擎实际上是一张表存储/组织数据的方式。

不同的存储引擎，表存储的方式不同。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何制定表的存储引擎？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可以在建表时，最后来指定表的存储引擎。
charset 来指定表的字符编码方式

show create table student;

CREATE TABLE `student` (
`id` int NOT NULL AUTO_INCREMENT,
`name` varchar(255) DEFAULT NULL,
`cno` int DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `cno` (`cno`),
CONSTRAINT `student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`t_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结论：&lt;br&gt;
mysql 默认的存储引擎是 InnoDB&lt;br&gt;
mysql 默认的字符编码方式： utf8mb4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table test(
    id int,
    name varchar(10)
) engine=InnoDB default CHARSET=utf8mb4;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看mysql支持哪些存储引擎&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看mysql支持哪些存储引擎&#34;&gt;#&lt;/a&gt; 查看 Mysql 支持哪些存储引擎&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;show engines \G;

mysql&amp;gt; show engines \G;
*************************** 1. row ***************************
    Engine: MEMORY
    Support: YES
    Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 2. row ***************************
    Engine: MRG_MYISAM
    Support: YES
    Comment: Collection of identical MyISAM tables
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 3. row ***************************
    Engine: CSV
    Support: YES
    Comment: CSV storage engine
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 4. row ***************************
    Engine: FEDERATED
    Support: NO
    Comment: Federated MySQL storage engine
Transactions: NULL
        XA: NULL
Savepoints: NULL
*************************** 5. row ***************************
    Engine: PERFORMANCE_SCHEMA
    Support: YES
    Comment: Performance Schema
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 6. row ***************************
    Engine: MyISAM
    Support: YES
    Comment: MyISAM storage engine
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 7. row ***************************
    Engine: InnoDB
    Support: DEFAULT
    Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
        XA: YES
Savepoints: YES
*************************** 8. row ***************************
    Engine: ndbinfo
    Support: NO
    Comment: MySQL Cluster system information storage engine
Transactions: NULL
        XA: NULL
Savepoints: NULL
*************************** 9. row ***************************
    Engine: BLACKHOLE
    Support: YES
    Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 10. row ***************************
    Engine: ARCHIVE
    Support: YES
    Comment: Archive storage engine
Transactions: NO
        XA: NO
Savepoints: NO
*************************** 11. row ***************************
    Engine: ndbcluster
    Support: NO
    Comment: Clustered, fault-tolerant tables
Transactions: NULL
        XA: NULL
Savepoints: NULL
11 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用存储引擎&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常用存储引擎&#34;&gt;#&lt;/a&gt; 常用存储引擎&lt;/h2&gt;
&lt;h3 id=&#34;myisam&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#myisam&#34;&gt;#&lt;/a&gt; MyISAM&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;特征：
    使用三个文件夹表示每个表
        格式文件-存储表结构的定义（mytable.frm)
        数据文件-存储表行的内容（mytable.MYD)
        索引文件-存储表上的索引（mytable.MYI) ：索引是一本数的目录，缩小扫描范围，提高效率
    可被转换为压缩、只读表来节省空间

优点：可被转换为压缩、只读表来节省空间
缺点：不支持事务机制，安全性低
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;innodb&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#innodb&#34;&gt;#&lt;/a&gt; InnoDB&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Mysql默认的存储引擎，同时也是一个重量级的存储引擎
主要特点：非常安全
    InnoDB支持事务
    支持数据库崩溃后自动回复机制

特征：
    1. 每个InnoDB表在数据库目录中以.frm格式文件表示
    2. InnoDB表空间tablespace被用于存储表的内容
    3. 提供一组用于记录事务特性活动的日志文件
    4. 用commit（提交）、savepoint 及 rollback（回滚）支持事务处理
    5. 提供全ACID兼容
    6. 在Mysql服务器崩溃后提供自动恢复
    7. 多版本（MVCC）和行级锁定
    8. 支持外键及引用的完整性，包括级联删除和更新
    
优点：支持事务
    以保证数据的安全。
缺点：
    1. 效率不是很高
    2. 不能压缩
    3. 不能转换为只读
    4. 不能很好的节省存储空间
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;memory&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#memory&#34;&gt;#&lt;/a&gt; MEMORY&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;内存存储引擎（别名堆引擎）

使用MEMORY存储引擎的表，其数据存储在内存中，且长度固定
这俩个特点使得MEMORY存储引擎非常快

特征：
    1. 在数据库目录中，每个表都以.frm 格式的文件表示
    2. 表数据和索引被存储在内存中（目的：查询快）
    3. 表级锁机制
    4. 不能包含 TEXT 或 BLOB 字段

MEMORY 存储引擎以前被称为HEAP引擎。

优点：查询效率最高
缺点：不安全，关机后数据消失，因为数据和索引都是存储在内存当中
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意对于一张表来说只要是主键或者加有unique约束的字段上会自动创建索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意对于一张表来说只要是主键或者加有unique约束的字段上会自动创建索引&#34;&gt;#&lt;/a&gt; 注意：对于一张表来说，只要是主键，或者加有 unique 约束的字段上会自动创建索引。&lt;/h2&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.628Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/17.%E7%BA%A6%E6%9D%9F/%E7%BA%A6%E6%9D%9F/</id>
        <title>约束</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/17.%E7%BA%A6%E6%9D%9F/%E7%BA%A6%E6%9D%9F/"/>
        <content type="html">&lt;h1 id=&#34;约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#约束&#34;&gt;#&lt;/a&gt; 约束&lt;/h1&gt;
&lt;h2 id=&#34;概念&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概念&#34;&gt;#&lt;/a&gt; 概念&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;constraint，在创建表的时候，创建一些约束，保证表中数据的完整性、有效性
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#作用&#34;&gt;#&lt;/a&gt; 作用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;保证表中的数据有效。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;非空约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#非空约束&#34;&gt;#&lt;/a&gt; 非空约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;not null：字段值不能为NULL

create table student(
    id int,
    name varchar(50) not null   // 只有列级 &#39;非空约束&#39;，没有表级 &#39;非空约束&#39;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;唯一性约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#唯一性约束&#34;&gt;#&lt;/a&gt; 唯一性约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;unique:字段值不能重复，但可以为NULL（可以有多条NULL值）

create table student(
    id int,
    name varchar(50) unique
);

案例：
mysql&amp;gt; select * from student;
+------+------+
| id   | name |
+------+------+
|    1 | z    |
|    1 | NULL |
|    1 | NULL |
|    1 | NULL |
|    1 | NULL |
|    1 | NULL |
+------+------+
6 rows in set (0.00 sec)

mysql&amp;gt; desc student;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | YES  |     | NULL    |       |
| name  | varchar(50) | YES  | UNI | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;建立多个字段唯一性约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#建立多个字段唯一性约束&#34;&gt;#&lt;/a&gt; 建立多个字段唯一性约束&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1. 多字段各自唯一性约束
create table student(
    id int unique,
    name varchar(50) unique // 列级约束
);
上边的表，id 和 name 字段各自有唯一性约束，互不影响。

2. 多字段组合后唯一性约束
create table student(
    id int,
    name varchar(50),
    unique(id, name)    // 表级约束
);
上边的表，id 和 name 字段联合起来唯一。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;在Mysql中，如果一个字段同时被 not null 和 unique 约束的话，该字段自动成为主键。（Oracle中不一样）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;主键约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#主键约束&#34;&gt;#&lt;/a&gt; 主键约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;primary key

主键值是每一行的唯一标识
主键特征：unique + not null

写法一：列级约束
create table student(
    id int primary key,
    name varchar(255)
);

写法二：表级约束
create table student(
    id int,
    name varchar(255),
    primary key(id)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;多个字段建立主键约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多个字段建立主键约束&#34;&gt;#&lt;/a&gt; 多个字段建立主键约束&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 复合主键
create table student(
    id int,
    name varchar(255),
    primary key(id, name)
);

//错误 一张表不能建立多个主键
    create table student(
    id int primary key,
    name varchar(255) primary key
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;mysql中自然主键&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql中自然主键&#34;&gt;#&lt;/a&gt; Mysql 中自然主键&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;create table student(
    id int primary key auto_increment,  // 从 1 开始递增
    name varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;外键约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#外键约束&#34;&gt;#&lt;/a&gt; 外键约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; foreign key

create table t_class(
    t_id int primary key auto_increment,
    t_name varchar(50)
);

create table student(
    id int primary key auto_increment,
    name varchar(255),
    cno int,
    foreign key (cno) references t_class(t_id)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：子表中的外键引用父表中的某个字段，被引用的这个字段不一定是主键，但是至少有 unique 约束。（否则，子表不能确定引用的是父表中的那条数据）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：外键可以为 NULL&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;检查性约束&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#检查性约束&#34;&gt;#&lt;/a&gt; 检查性约束&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;check(Mysql 不支持， Oracle支持)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.625Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/16.DML/DML/</id>
        <title>DML</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/16.DML/DML/"/>
        <content type="html">&lt;h1 id=&#34;insert&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#insert&#34;&gt;#&lt;/a&gt; insert&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;// 根据字段名，插入数据
// 注意： 字段名和值要一一对应
insert into 表名(字段名1,字段名2...) values(值1,值2...);


//表示插入所有字段
insert into 表名 values(值1,值2...);

// 一次插入多条数据，用逗号隔开
insert into test values(1, &#39;张三&#39;, &#39;1999-12-13&#39;), (2, &#39;李四&#39;, &#39;2000-01-02&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;将查询结果插入到一张表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#将查询结果插入到一张表&#34;&gt;#&lt;/a&gt; 将查询结果插入到一张表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;快速创建dept_bak表，同时数据也存入了dept_bak表中。
create table dept_bak as select * from dept;

将查询到的结果insert into到dept_bak表中
insert into dept_bak select * from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;update&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#update&#34;&gt;#&lt;/a&gt; update&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;update 表名 set 字段名1 = 值1, 字段名2 = 值2 where 条件;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;delete&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#delete&#34;&gt;#&lt;/a&gt; delete&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;delete from 表名 where 条件;

原理：
表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放

优点：支持回滚，可以恢复
缺点：删除效率低
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;快速删除表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#快速删除表&#34;&gt;#&lt;/a&gt; 快速删除表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;truncate 语句删除数据（属于DDL）
    删除效率高，表被一次截断，物理删除

    优点：效率高，快
    缺点：不支持回滚
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.622Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/15.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
        <title>数据类型</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/15.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
        <content type="html">&lt;h1 id=&#34;mysql-数据类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql-数据类型&#34;&gt;#&lt;/a&gt; Mysql 数据类型&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;varchar
    可变长度的字符串
    比较智能，节省空间
    会根据实际长度，动态的分配空间

    缺点：需要动态分配空间，速度慢
    优点：节省空间

char
    定长字符串
    不管实际长度是多少
    分配固定长度的空间去存储数据
    使用不恰当的时候，可能导致空间浪费

    缺点：使用不当，可能导致空间浪费
    优点：不需要动态分配空间，速度快

int

bigint

float

double

date
    短日期类型

datetime
    长日期类型

clob
    字符大对象
    最多存储4g的字符串
    比如：存储一篇文章
    超过255个字符的，尽量都使用clob
    Character Large Object: clob

blob
    存储二进制对象
    图片，声音，视频，等流媒体数据
    往blob字段中插入数据时，需要使用IO流。

date
    短日期：只包括 年月日

    Mysql默认格式：可以将该格式的时间字符串直接插入到date类型的字段中
    %Y-%m-%d


datetime
    长日期：包括 年月日时分秒

    Mysql默认格式：可以将该格式的时间字符串直接插入到date类型的字段中
    %Y-%m-%d %h:%i:%s
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.620Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/14.DDL/DDL/</id>
        <title>DDL</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/14.DDL/DDL/"/>
        <content type="html">&lt;h1 id=&#34;ddl-语句&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ddl-语句&#34;&gt;#&lt;/a&gt; DDL 语句&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;create、drop、alter
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;create-建表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#create-建表&#34;&gt;#&lt;/a&gt; create 建表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;语法格式：
create table 表名 (
    字段名 数据类型,
    字段名 数据类型,
    ...
    字段名 数据类型 //切记！！！   最后一句没有标点符号
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;快速创建表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#快速创建表&#34;&gt;#&lt;/a&gt; 快速创建表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;create table emp2 as select * from emp;
原理：
    将一个查询结果当作一张表新建
    可以快速创建一张表，同时数据也存在。

create table emp2 as select * from emp where ename = &#39;SMITH&#39;;
注意：查询语句可以添加条件等。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;drop-删表&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#drop-删表&#34;&gt;#&lt;/a&gt; drop 删表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;语法格式：
drop table 表名;    //当表不存在时，会报错
drop table if exists 表名;  // 当表存在的话，删除
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;alter-对表结构修改&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#alter-对表结构修改&#34;&gt;#&lt;/a&gt; alter 对表结构修改&lt;/h2&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.616Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/13.%E5%88%86%E9%A1%B5/limit/</id>
        <title>Mysql中limit</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/13.%E5%88%86%E9%A1%B5/limit/"/>
        <content type="html">&lt;h1 id=&#34;limit&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#limit&#34;&gt;#&lt;/a&gt; limit&lt;/h1&gt;
&lt;h2 id=&#34;作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#作用&#34;&gt;#&lt;/a&gt; 作用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;将查询结果集的一部分取出来，通常用在分页中。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;语法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#语法&#34;&gt;#&lt;/a&gt; 语法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;limit startIndex, length
startIndex: 起始下标，从0开始
length: 长度

缺省用法：limit length
length: 长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例：按照薪资降序，取出前五名员工。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
缺省用法：

select
    ename, sal
from
    emp
order by
    sal desc
limit 5;

完整用法：

select
    ename, sal
from
    emp
order by
    sal desc
limit 5;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;在mysql中，limit是在order by之后执行的。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;分页&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分页&#34;&gt;#&lt;/a&gt; 分页&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;limit (pageNum - 1) * pageSize, pageSize;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;offset&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#offset&#34;&gt;#&lt;/a&gt; offset&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;作用同limit，配合limit使用，注意：limit此时只能有一个参数

limit pageSize, offset (pageNum - 1) * pageSize;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.613Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/6.union/</id>
        <title>Mysql中union</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/6.union/"/>
        <content type="html">&lt;h1 id=&#34;union&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#union&#34;&gt;#&lt;/a&gt; union&lt;/h1&gt;
&lt;h2 id=&#34;作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#作用&#34;&gt;#&lt;/a&gt; 作用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;合并查询结果集
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;union的效率更高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。
但是union可以减少匹配次数。
在减少匹配次数的情况下，还可以完成两个结果的拼接。

例如：a 连接 b 连接 c
a: 10条记录
b: 10条记录
c: 10条记录
匹配次数为 : 10*10*10 = 1000

如果改为union
a 连接 b ： 10*10 = 100
a 连接 c ： 10*10 = 100
100 + 100 = 200次（union把乘法变成了加法运算）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例：查询工作岗位是 ‘MANAGER’ 和 ‘SALESMAN’ 的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
第一种方法：or
第二种方法：in
第三种方法：union
select ename from emp where job = &#39;MANAGER&#39;
union
select ename from emp where job = &#39;SALESMAN&#39;;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意：&lt;/h2&gt;
&lt;p&gt;在使用 union 需要注意：&lt;br&gt;
1.  union 在结果集合并的时候，要求两个结果列数相同。&lt;br&gt;
2.  MYSQL 中，对应列的数据类型可以不相同，Oracle 里会报错（会要求对应列的数据类型相同）。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.610Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql子查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h1 id=&#34;子查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#子查询&#34;&gt;#&lt;/a&gt; 子查询&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select语句中嵌套select语句，被嵌套的select语句被称为子查询。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;子查询可以出现的位置&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#子查询可以出现的位置&#34;&gt;#&lt;/a&gt; 子查询可以出现的位置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select
    ..(select子).
from
    ..(select子).
where
    ..(select子).
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;where子句中的子查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#where子句中的子查询&#34;&gt;#&lt;/a&gt; where 子句中的子查询&lt;/h2&gt;
&lt;p&gt;案例：找出比最低工资高的员工的姓名和薪资。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select 
    ename, sal
from
    emp
where
    sal &amp;gt; (select min(sal) from emp);

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;from-子查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#from-子查询&#34;&gt;#&lt;/a&gt; from 子查询&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;from后边的子查询，可以当作一张临时的表。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例：找出每个岗位的平均工资的薪资等级&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select
    t.*, sg.grade
from
    (select job, avg(sal) as avgsal from emp group job) t
join
    salgrade
on
    t.avgsal between sg.losal and hisal;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;select-子查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#select-子查询&#34;&gt;#&lt;/a&gt; select 子查询&lt;/h2&gt;
&lt;p&gt;案例：找出每个员工的部门名称，要求显示员工姓名，部门名称。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select
    e.ename, (select d.ename from dept e where e.deptno = d.deptno) as dname
from
    emp e;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;在select语句中的子查询，这个子查询语句只能一次返回一条结果，多于一条，就报错了。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.609Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/4.%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql多表连接查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/4.%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h1 id=&#34;多表连接查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多表连接查询&#34;&gt;#&lt;/a&gt; 多表连接查询&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;语法：
select
    ...
from
    a
join                    // 内连接
    b
on
    a表和b表的连接条件
join                    // 内连接
    c
on
    a表和c表的连接条件
right join              // 外连接
    d
on
    a和d的连接条件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一条 SQL 中内连接和外连接可以混合，都可以出现！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;案例：找出每个员工的部门名称，以及工资等级，要求显示员工名，部门名，薪资，薪资等级。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select 
    e.ename, d.ename, e.sal, sg.grade 
from 
    emp e 
join 
    dept d 
on 
    e.deptno = d.deptno 
join 
    salgrade sg 
on 
    e.sal between sg.losal and hisal;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例：找出每个员工的部门名称，以及工资等级，要求显示员工名，领导名，部门名，薪资，薪资等级。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
select 
    e.ename, d.ename, e.sal, sg.grade 
from 
    emp e 
join 
    dept d 
on 
    e.deptno = d.deptno 
join 
    salgrade sg 
on 
    e.sal between sg.losal and hisal
left outer join
    emp l
on
    e.mgr = l.empno;

&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.608Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/3.%E5%A4%96%E8%BF%9E%E6%8E%A5/</id>
        <title>Mysql外连接</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/3.%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
        <content type="html">&lt;h1 id=&#34;外连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#外连接&#34;&gt;#&lt;/a&gt; 外连接&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;外连接当中，两张表关联查询产生主次关系。
左连接和右连接可以相互切换。（
    1. 任何一个左连接都有一个右连接的写法。
    2. 任何一个右连接都有一个左连接的写法。
    ）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;右外连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#右外连接&#34;&gt;#&lt;/a&gt; 右外连接&lt;/h2&gt;
&lt;p&gt;right 代表，将右边的表看作主表，主要是将这张主表的内容全部查出来，捎带着关联查询左边的表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
                                          outer可以省略
select e.ename, d.ename from emp e right [outer] join dept d on e.deptno = e.deptno;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;左外连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#左外连接&#34;&gt;#&lt;/a&gt; 左外连接&lt;/h2&gt;
&lt;p&gt;left 代表，将左边的表看作主表，和右外连接相反。&lt;/p&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;外连接的查询结果条数一定是 &amp;gt;= 内连接的查询结果条数
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.607Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/2.%E5%86%85%E8%BF%9E%E6%8E%A5/</id>
        <title>Mysql内连接</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/2.%E5%86%85%E8%BF%9E%E6%8E%A5/"/>
        <content type="html">&lt;h1 id=&#34;内连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#内连接&#34;&gt;#&lt;/a&gt; 内连接&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;完全能够匹配上这个条件的数据查询出来。
A，B两张表连接查询，AB两张表没有主次关系，是平等的。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;等值连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#等值连接&#34;&gt;#&lt;/a&gt; 等值连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
SQL92语法：

select up.id uId, qpd.id qId from user_profile up, question_practice_detail qpd where up.device_id = qpd.device_id;

SQL99语法：
                                                  [inner] 单词可以省略
select up.id uId, qpd.id qId from user_profile up [inner] join question_practice_detail qpd on up.device_id = qpd.device_id;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SQL92 语法缺点：结构不清晰，表的连接条件和后期进一步的筛选条件，都放到了 where 后边。&lt;/p&gt;
&lt;p&gt;SQL99 语法有点：表连接的条件是独立的，连接之后如果还需要进一步筛选，可以继续添加 where 条件。&lt;/p&gt;
&lt;h2 id=&#34;非等值连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#非等值连接&#34;&gt;#&lt;/a&gt; 非等值连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;条件不是一个等量关系，称为非等值连接
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
案例：找出每个员工的薪资等级，要求显示员工名，薪资，薪资等级

    select 
        e.ename, e.sal, s.grade 
    from
        emp e
    inner join 
        salgrade s
    on 
        e.sal between s.losal and s.hisal;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自连接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#自连接&#34;&gt;#&lt;/a&gt; 自连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;一张表看作两张表
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
案例：查询员工的上级领导，要求显示员工名和对应的领导名
    select 
        a.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;
    from
        emp a 
    inner join
        emp b
    on
        a.mgr = b.empno;


&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.605Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</id>
        <title>Mysql连接查询</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
        <content type="html">&lt;h1 id=&#34;什么是连接查询&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是连接查询&#34;&gt;#&lt;/a&gt; 什么是连接查询&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;从一张表中单独查询，称为单表查询。
emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，称为连接查询。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;连接查询分类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#连接查询分类&#34;&gt;#&lt;/a&gt; 连接查询分类&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;根据语法的年代分类：
    1.  SQL92：1992年出现的语法。
    2.  SQL99：1999年出现的语法。

根据表连接的方式分类：
    1. 内连接
       1. 等值连接
       2. 非等值连接
       3. 自连接
    2. 外连接
       1. 左外连接（左连接）
       2. 右外连接（右连接）
    3. 全连接
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;笛卡尔积现象&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#笛卡尔积现象&#34;&gt;#&lt;/a&gt; 笛卡尔积现象&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;当两张表进行连接查询，没有任何条件限制的时候，最终的查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。（一个数学现象）
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
     select up.id uId, qd.id qId from user_profile up, question_detail qd;

    +-----+-----+
    | uId | qId |
    +-----+-----+
    |   7 |   1 |
    |   6 |   1 |
    |   5 |   1 |
    |   4 |   1 |
    |   3 |   1 |
    |   2 |   1 |
    |   1 |   1 |
    |   7 |   2 |
    ...
     112 rows in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;避免笛卡尔积现象&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#避免笛卡尔积现象&#34;&gt;#&lt;/a&gt; 避免笛卡尔积现象&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;增加表连接时的条件。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
    select up.id uId, qpd.id qId from user_profile up,  question_practice_detail qpd where up.device_id = qpd.device_id;

    +-----+-----+
    | uId | qId |
    +-----+-----+
    |   1 |   1 |
    |   2 |   2 |
    |   2 |   3 |
    |   3 |   4 |
    |   4 |   5 |
    |   4 |   6 |
    |   4 |   7 |
    |   2 |   8 |
    |   2 |   9 |
    |   3 |  10 |
    |   4 |  11 |
    |   4 |  12 |
    |   4 |  13 |
    |   2 |  14 |
    |   2 |  15 |
    |   3 |  16 |
    +-----+-----+
    16 rows in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;重点：最终查询结果是16条，但是在匹配中，匹配的次数没有减少，仍然是112次。只不过进行了筛除，匹配的次数并没有减少！！！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：通过观察笛卡尔积现场得出，表的连接次数越多（连接的表越多）程序执行效率越低，应避免表的连接次数过多。&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.603Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/</id>
        <title>Mysql中Distinct去重</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/"/>
        <content type="html">&lt;h1 id=&#34;distinct-去重&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#distinct-去重&#34;&gt;#&lt;/a&gt; Distinct 去重&lt;/h1&gt;
&lt;p&gt;把查询结果去除重复记录&lt;/p&gt;
&lt;h2 id=&#34;注意&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;distinct 只能出现在所有字段的最前方。&lt;br&gt;
select name, distinct job from emp;// 错误&lt;br&gt;
 select distinct name, job from emp;// 正确&lt;br&gt;
这样表示对 name 和 job 组合起来进行去重。&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.601Z</updated>
    </entry>
    <entry>
        <id>http://1405904364.github.io/2023/08/31/Mysql/10.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/</id>
        <title>Mysql执行顺序</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/31/Mysql/10.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;h1 id=&#34;执行顺序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#执行顺序&#34;&gt;#&lt;/a&gt; 执行顺序&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;select
    ...
from 
    ...
where
    ...
group by
    ...
having
    ...
order by
    ...

执行顺序：
1.  from
2.  where
3.  group by
4.  having
5.  select
6.  order by
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从某张表查询数据，&lt;br&gt;
先经过 where 条件筛选出有价值的数据，&lt;br&gt;
对这些数据进行分组，&lt;br&gt;
分组后可以使用 having 继续筛选数据&lt;br&gt;
 select 查询出来&lt;br&gt;
最后排序输出&lt;/p&gt;
</content>
        <category term="Mysql" />
        <updated>2023-08-31T01:26:47.598Z</updated>
    </entry>
</feed>
