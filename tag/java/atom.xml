<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://1405904364.github.io</id>
    <title>Live My Life • Posts by &#34;java&#34; tag</title>
    <link href="http://1405904364.github.io" />
    <updated>2023-08-10T08:29:50.061Z</updated>
    <category term="Java8" />
    <category term="Html" />
    <category term="Java" />
    <entry>
        <id>http://1405904364.github.io/2023/08/10/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
        <title>函数式编程</title>
        <link rel="alternate" href="http://1405904364.github.io/2023/08/10/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
        <content type="html">&lt;h1 id=&#34;函数式编程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#函数式编程&#34;&gt;#&lt;/a&gt; 函数式编程&lt;/h1&gt;
&lt;p&gt;一种 语法优雅、简洁健壮、高并发、易于测试和调试 的编程方式，这就是函数式编程 (FP) 的意义所在。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OO (Object oriented, 面向对象) 是抽象数据&lt;br&gt;
 FP (Function programming, 函数式编程) 是抽象行为&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个关键概念:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;函数是第一等公民&lt;/li&gt;
&lt;li&gt;函数要满足以下约束
&lt;ul&gt;
&lt;li&gt;函数的返回值仅取决于传递给函数的输入参数&lt;/li&gt;
&lt;li&gt;函数的执行没有副作用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;函数是一等公民&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#函数是一等公民&#34;&gt;#&lt;/a&gt; 函数是一等公民&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在函数式编程范式中，函数是语言的第一等公民。这意味着可以创建函数的 “实例”，对函数实例的变量引用，就像对字符串、Map 或者任何其他对象的引用一样。函数也可以作为参数传递给其他函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Java 中，函数显然不是第一等公民，类 (Class) 才是。所以 Java 才引用 Lambda 表达式，这个语法糖从表现层让 Java 拥有了函数，让函数可以作为变量的引用、方法的参数等等。（为什么说是从表现层呢？因为实际上，在编译的时候，Java 编译器还是会把 Lambda 表达式编译成类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;纯函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#纯函数&#34;&gt;#&lt;/a&gt; 纯函数&lt;/h3&gt;
&lt;p&gt;函数式编程中，有个纯函数 (Pure Function) 的概念，如果一个函数满足以下条件，才是纯函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数的执行没有副作用&lt;/li&gt;
&lt;li&gt;函数的返回值仅取决于传递给函数的输入参数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class ObjectWithPureFunction&amp;#123;
    public int sum(int a, int b)&amp;#123;
        return a+b;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;非纯函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#非纯函数&#34;&gt;#&lt;/a&gt; 非纯函数&lt;/h3&gt;
&lt;p&gt;上面的 sum 方法的返回值仅取决于其输入参数，而且 sum 是没有副作用的，它不会在任何地方修改函数之外的任何状态 (变量)&lt;/p&gt;
&lt;p&gt;相反，这个一个非纯函数的例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class ObjectWithNonPureFunction&amp;#123;
    private int value = 0;

    public int add(int nextValue) &amp;#123;
        this.value += nextValue;
        return this.value;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add 方法使用成员变量 value 来计算返回值，并且它还修改了 value 成员变量，这代表它有副作用，这两个条件都导致 add 方法不是一个纯函数&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;函数式接口&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#函数式接口&#34;&gt;#&lt;/a&gt; 函数式接口&lt;/h2&gt;
&lt;p&gt;所谓函数式接口，实际上就是接口里面有且只能有一个抽象方法的接口。&lt;/p&gt;
&lt;p&gt;函数式接口也称为 单一抽象方法 (SAM) 接口&lt;/p&gt;
&lt;h3 id=&#34;函数式接口的特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#函数式接口的特点&#34;&gt;#&lt;/a&gt; 函数式接口的特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;接口有且仅有一个抽象方法，如接口 Comparator&lt;/li&gt;
&lt;li&gt;允许出现 java.lang.Object 中的 public 方法，如 equals&lt;/li&gt;
&lt;li&gt;允许定义静态非抽象方法&lt;/li&gt;
&lt;li&gt;允许定义默认 default 非抽象方法 (default 方法式 java8 开始出现的)&lt;/li&gt;
&lt;li&gt;FunctionInterface 注解不是必须的，如果一个接口符合 “函数式接口” 的定义，那么不加该注解也没有影响&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;甚至可以说：函数式接口是专门为 lambda 表达式准备的，lambda 表达式是只实现接口中唯一抽象方法的匿名实现类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;default关键字&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#default关键字&#34;&gt;#&lt;/a&gt; default 关键字&lt;/h3&gt;
&lt;p&gt;在 java8 之前&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口是不能有方法的实现，所有的方法必须是抽象方法&lt;/li&gt;
&lt;li&gt;实现接口就必须实现接口里面的所有方法&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这样导致：当一个接口有很多实现类的时候，修改这个接口，就必须修改所有的实现类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过在 java8 中这个问题得到解决，这就是 default 方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;default 方法可以有自己的默认实现，即有方法体&lt;/li&gt;
&lt;li&gt;接口实现类可以不去实现 default 方法，并且可以使用 default 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jdk中函数式接口的举例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#jdk中函数式接口的举例&#34;&gt;#&lt;/a&gt; JDK 中函数式接口的举例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;java.lang.Runnable,&lt;/li&gt;
&lt;li&gt;java.util.Comparator,&lt;/li&gt;
&lt;li&gt;java.util.concurrent.Callable&lt;/li&gt;
&lt;li&gt;java.util.function 包下的接口，如 Consumer、Predicate、Supplier 等&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器会根据 Lambda 表达式的参数和返回值类型推断出其实现的抽象方法，进而推断出其实现的接口，如果一个接口有多个抽象方法，显然是没有办法用 Lambda 表达式实现该接口的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;functioninterface-注解&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#functioninterface-注解&#34;&gt;#&lt;/a&gt; @FunctionInterface 注解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;标注接口是一个函数式接口的注解&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;@FunctionalInterface // 标明接口为函数式接口
public interface MyInterface &amp;#123;
    public void run(); //抽象方法
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦使用了该注解标注接口，Java 的编译器会强制检查该接口是否满足函数式接口的要求：“确实仅有一个抽象方法”，否则将会报错&lt;/p&gt;
&lt;p&gt;需要注意的是，及时不适用该注解，只要有一个接口满足函数式接口的要求，那它仍然是一个函数式接口，使用起来都一样。该注解只起到标记接口指示编译器对其进行检查的作用&lt;/p&gt;
&lt;h3 id=&#34;java内置的函数式接口&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#java内置的函数式接口&#34;&gt;#&lt;/a&gt; Java 内置的函数式接口&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Function 接口（全限定名：java.util.function.Function）是 Java 中最核心的函数式接口。 Function 接口表示一个接受单个参数并返回单个值的函数（方法）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Predicate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Predicate 接口 （全限定名：java.util.function.Predicate）表示一个接收单个参数，并返回布尔值 true 或 false 的函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Supplier&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Supplier 接口（java.util.function.Supplier），表示提供某种值的函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consume&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consumer 接口（java.util.function.Consume）表示一个函数，该函数接收一个参数，但是不返回任何值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Optional&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Optional 接口并不是一个函数式接口，它常在 Stream 操作中出现，作为操作的返回值类型。&lt;/p&gt;
&lt;p&gt;Optional 接口是预防 NullPointerException 的好工具，它是一个简单的容器，其值可以是 null 或非 null。比如一个可能返回一个非空结果的方法，方法在有些情况下返回值，有些情况不满足返回条件返回空值，这种情况下使用 Optional 接口作为返回类型，比直接无值时返回 Null 要更安全&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;lambda表达式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#lambda表达式&#34;&gt;#&lt;/a&gt; Lambda 表达式&lt;/h2&gt;
&lt;h3 id=&#34;双冒号语法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#双冒号语法&#34;&gt;#&lt;/a&gt; 双冒号语法&lt;/h3&gt;
&lt;p&gt;其实双冒号就是 lambda 表达式的简写。被用作方法的引用。使用 lambda 表达式会创建匿名方法，但是有时候会需要一个 lambda 表达式只调用一个已经存在的方法，在此才有了方法的引用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态方法的引用 (static method)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
public class Demo &amp;#123;
	@Test
	public void test() &amp;#123;
		List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;aaaa&amp;quot;, &amp;quot;bbbb&amp;quot;, &amp;quot;cccc&amp;quot;);
		
		//静态方法语法	ClassName::methodName
		list.forEach(Demo::print);
	&amp;#125;
	
	public static void print(String content)&amp;#123;
		System.out.println(content);
	&amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;对象实例方法的引用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
public class Demo &amp;#123;
	@Test
	public void test() &amp;#123;
		List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;aaaa&amp;quot;, &amp;quot;bbbb&amp;quot;, &amp;quot;cccc&amp;quot;);
		
		//静态方法语法	ClassName::methodName
		list.forEach(new Demo()::print);
	&amp;#125;
	
	public void print(String content)&amp;#123;
		System.out.println(content);
	&amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;对象的超类方法引用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Example extends BaseExample&amp;#123;
 
	@Test
	public void test() &amp;#123;
		List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;aaaa&amp;quot;, &amp;quot;bbbb&amp;quot;, &amp;quot;cccc&amp;quot;);
		
		//对象的超类方法语法： super::methodName 
		list.forEach(super::print);
	&amp;#125;
&amp;#125;
 
class BaseExample &amp;#123;
	public void print(String content)&amp;#123;
		System.out.println(content);
	&amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;类构造器引用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
public class Example &amp;#123;
 
	@Test
	public void test() &amp;#123;
		InterfaceExample com =  Example::new;
		Example bean = com.create();
        Example bean = com.create(&amp;quot;STRING&amp;quot;);
		System.out.println(bean);
	&amp;#125;
&amp;#125;
 
interface InterfaceExample&amp;#123;
    //不带参数
	Example create();
    //带参数
    Example create(String str);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Java" />
        <updated>2023-08-10T08:29:50.061Z</updated>
    </entry>
</feed>
