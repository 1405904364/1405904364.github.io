{
    "version": "https://jsonfeed.org/version/1",
    "title": "Live My Life • All posts by \"java\" tag",
    "description": "个人学习使用",
    "home_page_url": "http://1405904364.github.io",
    "items": [
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%B0%B1/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%B0%B1/",
            "title": "图谱",
            "date_published": "2024-02-18T08:13:44.946Z",
            "content_html": "<h1 id=\"知识体系\"><a class=\"markdownIt-Anchor\" href=\"#知识体系\">#</a> 知识体系</h1>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/java_basic.png\" alt=\"Java基础知识体系\"></p>\n<h1 id=\"qa\"><a class=\"markdownIt-Anchor\" href=\"#qa\">#</a> Q&amp;A</h1>\n<h3 id=\"java中应该使用什么数据类型来代表价格\"><a class=\"markdownIt-Anchor\" href=\"#java中应该使用什么数据类型来代表价格\">#</a> Java 中应该使用什么数据类型来代表价格</h3>\n<p>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的 double 类型。</p>\n<h3 id=\"怎么将byte转换为string\"><a class=\"markdownIt-Anchor\" href=\"#怎么将byte转换为string\">#</a> 怎么将 byte 转换为 String</h3>\n<p>可以使用 String 接收 byte [] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同</p>\n<h3 id=\"java中怎样将bytes转换为long类型\"><a class=\"markdownIt-Anchor\" href=\"#java中怎样将bytes转换为long类型\">#</a> Java 中怎样将 Bytes 转换为 long 类型</h3>\n<p>String 接收 bytes 的构造器转成 String，再 Long.parseLong</p>\n<h3 id=\"可以将int强制转换为byte类型的变量吗如果该值大于byte类型的范围将会出现什么现象\"><a class=\"markdownIt-Anchor\" href=\"#可以将int强制转换为byte类型的变量吗如果该值大于byte类型的范围将会出现什么现象\">#</a> 可以将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象</h3>\n<p>可以做强制转换，但是 java 中 int 是 32 位的，而 byte 是 8 位的，所以如果强制转换是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 - 128 到 127</p>\n<h3 id=\"存在两个类b继承ac继承b我们能将b转换位c么\"><a class=\"markdownIt-Anchor\" href=\"#存在两个类b继承ac继承b我们能将b转换位c么\">#</a> 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换位 C 么</h3>\n<p>可以，向下转型，但是不建议使用，容易出现类型转换异常</p>\n<h3 id=\"那个类包含clone方法是cloneable还是object\"><a class=\"markdownIt-Anchor\" href=\"#那个类包含clone方法是cloneable还是object\">#</a> 那个类包含 Clone 方法？是 Cloneable 还是 Object</h3>\n<p>java.lang.Cloneable 是一个标识性接口，不包含任何方法，clone 方法在 Object 类中定义，并且需要知道 clone () 方法是一个本地方法，这意味着它是由 C 或 c++ 或其他本地语言实现的</p>\n<h3 id=\"java中-操作符是线程安全的吗\"><a class=\"markdownIt-Anchor\" href=\"#java中-操作符是线程安全的吗\">#</a> Java 中 ++ 操作符是线程安全的吗？</h3>\n<p>不是线程安全的操作，它设计到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交叉，还会存在竞态条件 (读取 - 修改 - 写入)</p>\n<h3 id=\"a-a-b-和-a-b的区别\"><a class=\"markdownIt-Anchor\" href=\"#a-a-b-和-a-b的区别\">#</a> a = a + b 和 a += b 的区别</h3>\n<p>+= 隐士的将加的操作结果类型强制转换位持有结果的类型，如果两个整形相加，如 byte、short、或者 int，首先会将它们提升到 int 类型，然后再执行加法的操作</p>\n<pre><code class=\"language-Java\">byte a = 127;\nbyte b = 127;\nb = a+b; // error: cannot conver from int to byte\nb += a; // ok\n</code></pre>\n<p>因为 a+b 的操作会将 a、b 提升位 int 类型，所有将 int 类型的值赋给 byte 就会编译报错</p>\n<h3 id=\"我能在不进行强制转换的情况下将一个double值赋给long类型的变量吗\"><a class=\"markdownIt-Anchor\" href=\"#我能在不进行强制转换的情况下将一个double值赋给long类型的变量吗\">#</a> 我能在不进行强制转换的情况下，将一个 double 值赋给 long 类型的变量吗？</h3>\n<p>不行，double 类型的精度比 long 更广，所以必须进行强制转换</p>\n<h3 id=\"301-03-将会返回true还是false\"><a class=\"markdownIt-Anchor\" href=\"#301-03-将会返回true还是false\">#</a> 3*0.1 == 0.3 将会返回 true 还是 false？</h3>\n<p>false，因为有些浮点数不能完全精确的表示出来</p>\n<pre><code class=\"language-Java\">        System.out.println( 3*0.1);\n        System.out.println( 3*0.1 == 0.3);\n\n        结果：\n        0.30000000000000004\n        false\n</code></pre>\n<h3 id=\"int和integer那个会更占内存\"><a class=\"markdownIt-Anchor\" href=\"#int和integer那个会更占内存\">#</a> int 和 Integer 那个会更占内存？</h3>\n<p>Integer 对象会占用内存多一些，Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始数据类型，所以占用的空间更少</p>\n<h3 id=\"为什么java中string是不可变的immutable\"><a class=\"markdownIt-Anchor\" href=\"#为什么java中string是不可变的immutable\">#</a> 为什么 Java 中 String 是不可变的 (immutable)?</h3>\n<p>Java 中的 String 不可变是因为 Java 的设计者认为字符串的使用非常频繁，将字符设置位不可变可以允许多个客户端之间共享相同的字符串</p>\n<h3 id=\"能在switch中只用string吗\"><a class=\"markdownIt-Anchor\" href=\"#能在switch中只用string吗\">#</a> 能在 switch 中只用 String 吗</h3>\n<p>从 Java7 开始，可以在 switch case 中使用字符串，但是这仅仅是一个语法糖，内部实现是在 switch 中使用字符串的 hash code</p>\n<h3 id=\"java中的构造器链是什么\"><a class=\"markdownIt-Anchor\" href=\"#java中的构造器链是什么\">#</a> Java 中的构造器链是什么？</h3>\n<p>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现</p>\n<h3 id=\"枚举类\"><a class=\"markdownIt-Anchor\" href=\"#枚举类\">#</a> 枚举类</h3>\n<p>Java1.5 出现，每个枚举类值都需要调用一次构造函数</p>\n<h3 id=\"什么是不可变对象immutable-objectjava中怎么创建一个不可变对象\"><a class=\"markdownIt-Anchor\" href=\"#什么是不可变对象immutable-objectjava中怎么创建一个不可变对象\">#</a> 什么是不可变对象 (immutable object)？Java 中怎么创建一个不可变对象？</h3>\n<p>不可变对象指对象一旦被创建，状态不能再改变，任何修改都会创建一个新对象，如 String、Integer 及其他包装类。</p>\n<p>如何再 Java 中写出 immutable 的类？</p>\n<ol>\n<li>immutable 对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象</li>\n<li>immutable 类的所有属性都应该是 final 的</li>\n<li>对象必须被正确的创建，比如：对象引用在对象创建的过程中不能泄露 (leak)</li>\n<li>对象应该是 final 的，一次来限制子类继承父类，以免子类改变了父类的 immutable 特性</li>\n<li>如果类中包含 mutable 类对象，那么返回给客户端的时候，返回该对象的一个拷贝对象，而不是该对象本身 (该条可以归纳位第一条的一个特例)</li>\n</ol>\n<h3 id=\"我们能创建一个包含可变对象的不可变对象吗\"><a class=\"markdownIt-Anchor\" href=\"#我们能创建一个包含可变对象的不可变对象吗\">#</a> 我们能创建一个包含可变对象的不可变对象吗？</h3>\n<p>可以，但是需要注意，不能共享可变对象的引用，如果需要变化时，就返回原对象的一个拷贝，最常见的例子就是对象中包含一个日期对象的引用</p>\n<h3 id=\"有没有可能两个不相等的对象有相同的hashcode\"><a class=\"markdownIt-Anchor\" href=\"#有没有可能两个不相等的对象有相同的hashcode\">#</a> 有没有可能两个不相等的对象有相同的 hashcode？</h3>\n<p>有可能，两个不相等的对象可能有相同的 hashcode，这就是为什么在 hashMap 中会有冲突，相等 hashcode 值的规定只是说两个对象相等，必须有相同的 hashcode 值，但是没有关于不相等对象的任何规定</p>\n<h3 id=\"两个相同对象会有不同的hashcode吗\"><a class=\"markdownIt-Anchor\" href=\"#两个相同对象会有不同的hashcode吗\">#</a> 两个相同对象会有不同的 hashcode 吗？</h3>\n<p>不能，根据 hashcode 规定，这是不可能的</p>\n<h3 id=\"可以在hashcode方法中使用随机数字吗\"><a class=\"markdownIt-Anchor\" href=\"#可以在hashcode方法中使用随机数字吗\">#</a> 可以在 hashcode 方法中使用随机数字吗？</h3>\n<p>不能，根据 hashcode 规定，对象的 hashcode 值必须时相同的</p>\n<h3 id=\"java中comparator-与-comparable有什么不同\"><a class=\"markdownIt-Anchor\" href=\"#java中comparator-与-comparable有什么不同\">#</a> Java 中，Comparator 与 Comparable 有什么不同？</h3>\n<p>Comparable 接口用于定义对象的自然顺序，而 Comparator 通常用于用户自定义顺序，Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序</p>\n<h3 id=\"为什么在重写equals方法的时候需要重写hashcode方法\"><a class=\"markdownIt-Anchor\" href=\"#为什么在重写equals方法的时候需要重写hashcode方法\">#</a> 为什么在重写 equals 方法的时候需要重写 hashcode 方法？</h3>\n<p>因为有强制的规范指定需要同时重写 hashcode 与 equals 方法，许多容器类，如 HashMap、HashSet 都依赖与 hashcode 与 equals 的规定</p>\n<h3 id=\"ab-和-aequtalsb-有什么区别\"><a class=\"markdownIt-Anchor\" href=\"#ab-和-aequtalsb-有什么区别\">#</a> a==b 和 a.equtals (b) 有什么区别？</h3>\n<p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向堆中同一个对象才会返回 true，而 a.equals (b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性比较。例如 String 类重写 equals 方法，所以可以用于不同对象，但是包含的字母相同的比较</p>\n<h3 id=\"ahashcode有什么用aequalsb-有什么关系\"><a class=\"markdownIt-Anchor\" href=\"#ahashcode有什么用aequalsb-有什么关系\">#</a> a.hashcode () 有什么用，a.equals (b) 有什么关系？</h3>\n<p>hashCode () 方法是相应对象整形的 hash 值，它常用于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap 等等。它与 equals () 方法关系特别亲密。根据 Java 规范，两个使用 equals () 方法来判断相等的对象，必须具有相同的 hashCode。</p>\n<ol>\n<li>\n<p>hashCode 的作用<br>\n List 和 Set 如何保证 Set 不重复呢？通过迭代使用 equals () 方法来判断，数量小还可以接收，数据量太大怎么解决？引入 HashCode，实际上 hashCode 扮演的角色就是寻址，大大减少查询匹配次数。</p>\n<p>先判断对象的 hashCode 值是否相等，如果不相等，则说明两个对象不相等，如果相等再使用 equals () 方法进一步判断对象是否相等，只有当 hashCode 值相等，equals () 方法返回 true 时，确认两个对象是相等的。</p>\n</li>\n<li>\n<p>hashCode 重要吗<br>\n对于数组、List 集合就是一个累赘，而对于 HahsMap、HashSet、HashTable 就很重要了</p>\n</li>\n<li>\n<p>equals 方法遵循的原则</p>\n<ul>\n<li>对称性：若 x.equals (y) 为 true，则 y.equals (x)</li>\n<li>自反性：x.equals (x) 必须 true</li>\n<li>传递性：若 x.equals (y) 为 true，y.equals (z) 为 true，则 x.equals (z) 必为 true</li>\n<li>一致性：只要 x，y 内容不变，无论调用多少次结果都不变</li>\n<li>其他：x.equals (null) 永远为 false，x.equals (和 x 数据类型不同) 始终为 false</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"final-finalize-finally的不同之处\"><a class=\"markdownIt-Anchor\" href=\"#final-finalize-finally的不同之处\">#</a> final、finalize、finally 的不同之处</h3>\n<ul>\n<li>final 是一个修饰符，可以修饰变量，方法，和类。如果 final 修饰变量，意味着变量的值在初始化后不能被改变。</li>\n<li>Java 技术允许使用 finaliza () 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是有垃圾收集器在确定这个对象没有引用时对这个对象调用的，但是什么时候执行 finaliza 没有保证</li>\n<li>finally 是一个关键字，与 try 和 catch 一起用于异常的处理，finally 块一定会被执行，无论在 try 中是否发生异常</li>\n</ul>\n<h3 id=\"java中的编译期常量是什么使用它又有什么风险\"><a class=\"markdownIt-Anchor\" href=\"#java中的编译期常量是什么使用它又有什么风险\">#</a> Java 中的编译期常量是什么？使用它又有什么风险？</h3>\n<p>变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>\n<h3 id=\"静态内部类与顶级类有什么区别\"><a class=\"markdownIt-Anchor\" href=\"#静态内部类与顶级类有什么区别\">#</a> 静态内部类与顶级类有什么区别？</h3>\n<p>一个公共的顶级类的源文件与类名相同，而嵌套静态类没有这个要求，一个嵌套类位于顶级类的内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是顶级类，Entry 是一个嵌套静态类</p>\n<h3 id=\"java中serializable与externalizable的区别\"><a class=\"markdownIt-Anchor\" href=\"#java中serializable与externalizable的区别\">#</a> Java 中，Serializable 与 Externalizable 的区别？</h3>\n<p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高，脆弱且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制</p>\n<p><strong>声明为 static 和 transient 类型的数据不能被序列化，反序列化需要一个无参构造函数</strong></p>\n<h3 id=\"接口是什么为什么要使用接口而不是直接只用具体类\"><a class=\"markdownIt-Anchor\" href=\"#接口是什么为什么要使用接口而不是直接只用具体类\">#</a> 接口是什么？为什么要使用接口而不是直接只用具体类？</h3>\n<p>接口用于定义 API，它定义了类必须遵守的规则，同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口不允许普通方法，以此来保证抽象，但是 Java8 中你可以在接口中声明静态方法和默认普通方法。</p>\n<h3 id=\"java中抽象类与接口之间有什么不同\"><a class=\"markdownIt-Anchor\" href=\"#java中抽象类与接口之间有什么不同\">#</a> Java 中，抽象类与接口之间有什么不同？</h3>\n<p>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口，抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制</p>\n<h3 id=\"接口与抽象类\"><a class=\"markdownIt-Anchor\" href=\"#接口与抽象类\">#</a> 接口与抽象类</h3>\n<ul>\n<li>一个子类只能继承一个抽象类，但能实现多个接口</li>\n<li>抽象类可以有构造方法，接口没有构造方法</li>\n<li>抽象类可以有普通成员变量，接口没有普通成员变量</li>\n<li>抽象类和接口都可有静态成员变量，抽象类中静态成员变量访问类型任意，接口只能 public static final (默认)</li>\n<li>抽象类可以没有抽象方法，抽象类可以有普通方法；接口在 JDK8 之前都是抽象方法，在 JDK8 可以有 default 方法，在 JDK9 中允许有私有普通方法</li>\n<li>抽象类可以有静态方法；接口在 JDK8 之前不能有静态方法，在 JDK8 中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li>\n<li>抽象类中的方法可以是 public、protected; 接口方法在 JDK8 之前只有 public abstract，在 JDK8 可以有 default 方法，在 JDK9 中允许有 private 方法</li>\n</ul>\n<h3 id=\"抽象类和最终类\"><a class=\"markdownIt-Anchor\" href=\"#抽象类和最终类\">#</a> 抽象类和最终类</h3>\n<p>抽象类可以没有抽象方法，最终类可以没有最终方法<br>\n最终类不能被继承，最终方法不能被重写</p>\n<h3 id=\"异常\"><a class=\"markdownIt-Anchor\" href=\"#异常\">#</a> 异常</h3>\n<p>相关的关键字：throw、throws、try…catch、finally</p>\n<ul>\n<li>throws 用在方法标签上，以抛出的异常可以被调用者处理</li>\n<li>throw 方法内部通过 throw 抛出异常</li>\n<li>try 用于检测包住的语句块，若有异常，catch 子句捕获并执行 catch 块</li>\n</ul>\n<h3 id=\"关于finally\"><a class=\"markdownIt-Anchor\" href=\"#关于finally\">#</a> 关于 finally</h3>\n<ul>\n<li>finally 不管有没有异常都要处理</li>\n<li>当 try 和 catch 中有 return 时，finally 仍会执行，finally 比 return 先执行</li>\n<li>不管有没有异常抛出，finally 在 return 返回前执行</li>\n<li>finally 是在 return 后面的表达式运算后执行的 (此时并没有返回运算后的值，二十先把要返回的值保存起来，不管 finally 中的代码怎么样，返回值都不会改变，仍然是之前保存的值)，所以函返回值是在 finally 执行前确定的</li>\n</ul>\n<p>注意：finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值<br>\n finally 不执行的几种情况：程序提前终止了，如调用了 System.exit，病毒，断电</p>\n<h3 id=\"super出现在父类的子类中有三种存在方式\"><a class=\"markdownIt-Anchor\" href=\"#super出现在父类的子类中有三种存在方式\">#</a> super 出现在父类的子类中，有三种存在方式</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N1cGVyLnh4eA==\">super.xxx</span> 调用父类的中的 xxx 变量或引用</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N1cGVyLnh4eA==\">super.xxx</span> () 调用父类中的方法</li>\n<li>super () 调用父类构造函数</li>\n</ul>\n<p>注意：super 只能代其直接父类</p>\n<h3 id=\"this-super-在构造方法中的区别\"><a class=\"markdownIt-Anchor\" href=\"#this-super-在构造方法中的区别\">#</a> this () &amp; super () 在构造方法中的区别</h3>\n<ul>\n<li>调用 super () 必须卸载子类构造方法的第一行，否则编译不通过</li>\n<li>super 从子类调用父类构造，this 在同一类中调用其他构造器均需要放在第一行</li>\n<li>尽管可以用 this 调用一个构造器，去不能调用 2 个</li>\n<li>this 和 super 不能出现在同一个构造器中，否则编译不通过</li>\n<li>this ()、super () 都指的对象，不可以在 static 环境中使用</li>\n<li>本质 this 指向本对象的指针，super 是一个关键字</li>\n</ul>\n<h3 id=\"构造内部类和静态内部类对象\"><a class=\"markdownIt-Anchor\" href=\"#构造内部类和静态内部类对象\">#</a> 构造内部类和静态内部类对象</h3>\n<pre><code class=\"language-Java\">public class Enclosingone &#123;\n\tpublic class Insideone &#123;&#125;\n\tpublic static class Insideone&#123;&#125;\n&#125;\n\npublic class Test &#123;\n\tpublic static void main(String[] args) &#123;\n\t// 构造内部类对象需要外部类的引用\n\tEnclosingone.Insideone obj1 = new Enclosingone().new Insideone();\n\t// 构造静态内部类的对象\n\tEnclosingone.Insideone obj2 = new Enclosingone.Insideone();\n\t&#125;\n&#125;\n</code></pre>\n<p>静态内部类不需要有外部类的引用，但非静态内部类需要持有对外部类的引用。非静态类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员</p>\n<h3 id=\"java位移运算符\"><a class=\"markdownIt-Anchor\" href=\"#java位移运算符\">#</a> Java 位移运算符</h3>\n<p>Java 中有三种位移运算符</p>\n<ul>\n<li>&lt;&lt;左移运算符，x&lt;&lt;1 相当于 x 乘以 2 (不溢出的情况下)，地位补 0</li>\n<li>\n<blockquote>\n<blockquote>\n<p>右移运算符，x&gt;&gt;1 相当于 x 除以 2，正数高位补 0，负数高位补 1</p>\n</blockquote>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>无符号右移，忽略符号位，空位都以 0 补齐</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"形参实参\"><a class=\"markdownIt-Anchor\" href=\"#形参实参\">#</a> 形参 &amp; 实参</h3>\n<p>形式参数可被视为 local variable, 形参和局部变量一样不能离开方法，只有在方法中使用，不会在方法外可见。形式参数只能用 final 修饰符，其他任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用 final 修饰，只有特殊情况下，那就是：方法内部类。一个方法内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是 final。形参的值在调用时根据调用者更改。实参则用自身的值更改形参的值 (指针、引用皆在此列)，也就是说真正被传递的是实参。</p>\n<h3 id=\"局部变量为什么要初始化\"><a class=\"markdownIt-Anchor\" href=\"#局部变量为什么要初始化\">#</a> 局部变量为什么要初始化</h3>\n<p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者在使用前给变量赋值。</p>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E7%9F%A5%E8%AF%86%E7%82%B9/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E7%9F%A5%E8%AF%86%E7%82%B9/",
            "title": "知识点",
            "date_published": "2024-02-18T08:13:44.946Z",
            "content_html": "<h1 id=\"java基础-知识点\"><a class=\"markdownIt-Anchor\" href=\"#java基础-知识点\">#</a> Java 基础 - 知识点</h1>\n<h2 id=\"数据类型\"><a class=\"markdownIt-Anchor\" href=\"#数据类型\">#</a> 数据类型</h2>\n<p>八个基本类型：</p>\n<ul>\n<li>boolean/1</li>\n<li>byte/8</li>\n<li>char/16</li>\n<li>short/16</li>\n<li>int/32</li>\n<li>float/32</li>\n<li>double/64</li>\n<li>long/64</li>\n</ul>\n<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>\n<pre><code class=\"language-Java\">\nInteger x = 2; // 装箱\nint y = x; // 拆箱\n\n</code></pre>\n<h2 id=\"缓存池\"><a class=\"markdownIt-Anchor\" href=\"#缓存池\">#</a> 缓存池</h2>\n<p>new Integer (123) 与 Integer.valueOf (123) 的区别在于：</p>\n<ul>\n<li>new Integer (123) 每次都会创建一个新对象</li>\n<li>Integer.valueOf (123) 会使用缓存池中的对象，多次调用会获得同一个对象的引用</li>\n</ul>\n<pre><code class=\"language-Java\">\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y); // false\nInteger j = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(j == k); // true\n\n</code></pre>\n<p>valueOf 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就返回缓存池中的内容</p>\n<pre><code class=\"language-Java\">\npublic static Integer valueOf(int i) &#123;\n    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n         return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n&#125;\n\n</code></pre>\n<p>在 Java8 中，Integer 的缓存池大小默认为 -128 ~ 127</p>\n<p>编译器会在缓存池范围内的基本类型自动装箱过程中调用 valueOf () 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象</p>\n<pre><code class=\"language-Java\">\nInteger m = 123;\nInteger n = 123;\nSystem.out.println(m == n); // true\n\n</code></pre>\n<p>基本类型对应缓存池如下：</p>\n<ul>\n<li>boolean values true and false</li>\n<li>all byte values</li>\n<li>short values between -128 and 127</li>\n<li>int values between -128 and 127</li>\n<li>char in the range \\u0000 to \\u007F</li>\n</ul>\n<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p>\n<p>如果在缓存池之外：</p>\n<pre><code class=\"language-Java\">\nInteger m = 323;\nInteger n = 323;\nSystem.out.println(m == n); // false\n\n</code></pre>\n<h2 id=\"string\"><a class=\"markdownIt-Anchor\" href=\"#string\">#</a> String</h2>\n<h3 id=\"概览\"><a class=\"markdownIt-Anchor\" href=\"#概览\">#</a> 概览</h3>\n<p>String 被声明为 final，因此它是不可继承的</p>\n<p>内部使用 char 存储数据，该数组被声明为 final，这意味着 value 数组初始化之后，就不能再引用其他数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变</p>\n<pre><code class=\"language-Java\">\npublic final class String\n    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;\n    /** The value is used for character storage. */\n    private final char value[];\n\n</code></pre>\n<h3 id=\"不可变的好处\"><a class=\"markdownIt-Anchor\" href=\"#不可变的好处\">#</a> 不可变的好处</h3>\n<ol>\n<li>可以使用 hash 值<br>\n因为 String hash 值经常被使用，例如 String 用作 HashMap 的 Key，不可变的特性使得 HashMap 的值也不可变，因此只需要做一次计算就够了</li>\n<li>String pool 的需要<br>\n如果一个 String 对象以及被创建过了，那么就会从 String pool 中取得引用。只有 String 是不可变的，才能使用 String pool</li>\n</ol>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/f76067a5-7d5f-4135-9549-8199c77d8f1c.jpg\" alt=\"String 缓存池\"></p>\n<ol start=\"3\">\n<li>安全性<br>\n String 经常被作为参数，String 的不可变性保证参数不可变</li>\n<li>线性安全<br>\n String 不可变天生具备线性安全特性，可以在多个线程中安全使用</li>\n</ol>\n<h3 id=\"string-stringbuffer-stringbuilder\"><a class=\"markdownIt-Anchor\" href=\"#string-stringbuffer-stringbuilder\">#</a> String、StringBuffer、StringBuilder</h3>\n<ol>\n<li>\n<p>可变性</p>\n<ul>\n<li>String 不可变</li>\n<li>StringBuffer 和 StringBuilder 可变</li>\n</ul>\n</li>\n<li>\n<p>线程安全</p>\n<ul>\n<li>String 不可变，因此是线程安全的</li>\n<li>StringBuffer 是线程安全的，因为内部是使用 synchronized 进行同步</li>\n<li>StringBuilder 不是线程安全的</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"stringintern\"><a class=\"markdownIt-Anchor\" href=\"#stringintern\">#</a> String.intern()</h3>\n<p>使用 String.intern () 可以保证相同内容的字符串变量引用同一个内存对象</p>\n<p>s1 和 s2 采用 new String () 的方式创建了两个不同的对象，而 s3 是通过 s1.intern () 方式获取一个对象的引用。intern 首先把 s1 的引用对象方式 String pool (字符串常量池) 中，然后返回这个对象的引用，因此 s3 和 s4 引用的是同一个字符串常量池中的对象，所以 s3 == s4</p>\n<pre><code class=\"language-Java\">\n    String s1 = new String(&quot;aaa&quot;);\n    String s2 = new String(&quot;aaa&quot;);\n    System.out.println(s1 == s2);\n    String s3 = s1.intern();\n    System.out.println(s3 == s1);\n    String s4 = s1.intern();\n    System.out.println(s3 == s4);\n\n</code></pre>\n<p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p>\n<pre><code class=\"language-Java\">\nString s4 = &quot;bbb&quot;;\nString s5 = &quot;bbb&quot;;\nSystem.out.println(s4 == s5);  // true\n\n</code></pre>\n<p><strong>HotSpot 中的字符串常量池保存在哪里？永久代？方法区还是堆区？</strong></p>\n<ol>\n<li>运行时常量池 (Runntime Constant Pool) 是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机以后，就会创建对应的运行时常量是；而字符串常量池是这个过程中常量字符串存放的位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及原空间是实际的存放位置</li>\n<li>不同虚拟机对虚拟机的规范 (比如方法区) 是不一样的，只有 HotSpot 才有永久代的概念</li>\n<li>HotSpot 也是发展的，由于一些问题的存在 HotSpot 考虑主键去永久代，对于不同版本的 JDK，实际的存储位置是有差异的，具体如下</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">JDK 版本</th>\n<th>是否有永久代，字符串常量池放在哪里？</th>\n<th>方法区逻辑上规范，由哪些实际的部分实现的？</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">jdk1.6 及之前</td>\n<td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td>\n<td>这个时期方法区在 HotSpot 中是由永久代来实现的，以至于这个时期说方法区就是指永久代</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">jdk1.7</td>\n<td>有永久代，但已经逐步 “去永久代”，字符串常量池、静态变量移除，保存在堆中；</td>\n<td>这个时期方法区在 HotSpot 中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">jdk1.8 及之后</td>\n<td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td>\n<td>这个时期方法区在 HotSpot 中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"运算\"><a class=\"markdownIt-Anchor\" href=\"#运算\">#</a> 运算</h2>\n<h3 id=\"参数传递\"><a class=\"markdownIt-Anchor\" href=\"#参数传递\">#</a> 参数传递</h3>\n<p>Java 的参数是以值得形式传入方法中，而不是引用传递</p>\n<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法是，本质上是将对象的地址以值得形式传递到形参中，因此在方法中改变指针引用对象，那么这两个指针此时指向得是完全不同得对象，一方对象得改变，对另一方没什么影响</p>\n<pre><code class=\"language-Java\">\npublic class Dog &#123;\n    String name;\n\n    Dog(String name) &#123;\n        this.name = name;\n    &#125;\n\n    String getName() &#123;\n        return this.name;\n    &#125;\n\n    void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    String getObjectAddress() &#123;\n        return super.toString();\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\npublic class PassByValueExample &#123;\n    public static void main(String[] args) &#123;\n        Dog dog = new Dog(&quot;A&quot;);\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        func(dog);\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        System.out.println(dog.getName());          // A\n    &#125;\n\n    private static void func(Dog dog) &#123;\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        dog = new Dog(&quot;B&quot;);\n        System.out.println(dog.getObjectAddress()); // Dog@74a14482\n        System.out.println(dog.getName());          // B\n    &#125;\n&#125;\n\n</code></pre>\n<p>但是如果在方法中改变对象得字段值，会改变原对象的该字段值，因为改变的是同一个地址指向的内容</p>\n<pre><code class=\"language-Java\">\nclass PassByValueExample &#123;\n    public static void main(String[] args) &#123;\n        Dog dog = new Dog(&quot;A&quot;);\n        func(dog);\n        System.out.println(dog.getName());          // B\n    &#125;\n\n    private static void func(Dog dog) &#123;\n        dog.setName(&quot;B&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"float-与-double\"><a class=\"markdownIt-Anchor\" href=\"#float-与-double\">#</a> float 与 double</h2>\n<p>1.1 字面属于 double 类型，不能直接将 1.1 赋值给 float 变量，因为这是向下转型。Java 不能隐士执行向下转型，因为这样会使精度变低</p>\n<pre><code class=\"language-Java\">\n// float f = 1.1; // 会报错\n\n</code></pre>\n<p>1.1f 字面量才是 float 类型</p>\n<pre><code class=\"language-Java\">\nfloat f = 1.1f;\n\n</code></pre>\n<h2 id=\"隐式类型转换\"><a class=\"markdownIt-Anchor\" href=\"#隐式类型转换\">#</a> 隐式类型转换</h2>\n<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式的将 int 类型转为 short 类型</p>\n<pre><code class=\"language-Java\">\nshort s1 = 1;\n// s1 = s1 + 1; // s1 + 1 被隐式的转换为int类型，因为int类型不能隐式转换为short，因此报错\n\n</code></pre>\n<p>但是使用 += 运算符可以执行隐式类型转换</p>\n<pre><code class=\"language-Java\">\nshort s1 = 1;\ns1 += 1;\n\n</code></pre>\n<p>上面的语句相当于 s1 + 1 的计算结果进行了向下转型</p>\n<pre><code class=\"language-Java\">\ns1 = (short) (s1 + 1);\n\n</code></pre>\n<h2 id=\"switch\"><a class=\"markdownIt-Anchor\" href=\"#switch\">#</a> switch</h2>\n<p>从 java7 开始，可以在 switch 条件判断语句中使用 String 对象</p>\n<pre><code class=\"language-Java\">\n   String str = &quot;ccc&quot;;\n   switch (str) &#123;\n       case &quot;aaa&quot;: &#123;\n           System.out.println(&quot;aaa&quot;);\n           break;\n       &#125;\n       case &quot;bbb&quot;: &#123;\n           System.out.println(&quot;bbb&quot;);\n           break;\n       &#125;\n       default:\n           System.out.println(&quot;没有啊&quot;);\n   &#125;\n\n</code></pre>\n<p><strong>注意：switch-case 语句中，break 尤为重要，如果不加 break 作为结束标志，switch 会从匹配到的第一个值之后，无视后来的所有 case 和 default 关键字，执行到结束</strong></p>\n<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值进行等值判断，如果值过于复杂，那么还是用 if 合适</p>\n<p>jdk8 中，switch 支持 char, byte, short, int, Character, Byte, Short, Integer, String, or an enum</p>\n<h2 id=\"继承\"><a class=\"markdownIt-Anchor\" href=\"#继承\">#</a> 继承</h2>\n<h3 id=\"访问权限\"><a class=\"markdownIt-Anchor\" href=\"#访问权限\">#</a> 访问权限</h3>\n<p>java 中有三个访问权限修饰符:private、protected 以及 public，如果不加访问修饰符，表示包级可见</p>\n<p>可以对类或类中的成员 (字段以及方法) 添加修饰符</p>\n<ul>\n<li>类可见表示其他类可以用这个类创建实例对象</li>\n<li>成员可见表示其他类可以用这个类的实例对象访问到该成员</li>\n</ul>\n<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>\n<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的内部实现清晰的隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息的隐藏或者封装。因此访问权限应当尽可能的使每个类或者成员不被外界访问。</p>\n<blockquote>\n<p>如果字类重写了父类的方法，那么子类中该方法的访问权限不允许低于父类的访问级别，这是为了确保使用父类的地方都可以使用字类实例，也就确保满足里氏替换原则</p>\n</blockquote>\n<h3 id=\"抽象类与接口\"><a class=\"markdownIt-Anchor\" href=\"#抽象类与接口\">#</a> 抽象类与接口</h3>\n<ol>\n<li>\n<p>抽象类</p>\n<p>抽象类和抽象方法都是用 abstract 关键字进行声明，抽象类一般会包含抽象方法，抽象方法一定在抽象类中 (换句话说，有抽象方法的类，一定是抽象类)</p>\n<p>抽象类和普通类最大的区别就是，抽象类不能实例化，需要继承抽象类才能实例化子类</p>\n</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic abstract class AbstractClassExample &#123;\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() &#123;\n        System.out.println(&quot;func2&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\npublic class AbstractExtendClassExample extends AbstractClassExample &#123;\n    @Override\n    public void func1() &#123;\n        System.out.println(&quot;func1&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\n// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated\nAbstractClassExample ac2 = new AbstractExtendClassExample();\nac2.func1();\n\n</code></pre>\n<ol>\n<li>\n<p>接口</p>\n<p>接口是抽象类的延申，在 Java8 之前，它可以看成一个完全抽象的类，也就是说他不能有任何的方法实现</p>\n<p>在 java8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口维护成本太高了，在 Java8 之前，如果一个接口想要添加新方法，那么就要修改所有实现了该接口的类</p>\n<p>接口的成员 (字段 + 方法) 默认都是 public，并且不允许自定义为 private 或者 protected</p>\n<p>接口的字段默认都是 static 和 final 的</p>\n</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic interface InterfaceExample &#123;\n    void func1();\n\n    default void func2()&#123;\n        System.out.println(&quot;func2&quot;);\n    &#125;\n\n    int x = 123;\n    // int y;               // Variable 'y' might not have been initialized\n    public int z = 0;       // Modifier 'public' is redundant for interface fields\n    // private int k = 0;   // Modifier 'private' not allowed here\n    // protected int l = 0; // Modifier 'protected' not allowed here\n    // private void fun3(); // Modifier 'private' not allowed here\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\npublic class InterfaceImplementExample implements InterfaceExample &#123;\n    @Override\n    public void func1() &#123;\n        System.out.println(&quot;func1&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\n// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated\nInterfaceExample ie2 = new InterfaceImplementExample();\nie2.func1();\nSystem.out.println(InterfaceExample.x);\n\n</code></pre>\n<ol>\n<li>比较</li>\n</ol>\n<ul>\n<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里氏替换原则，即字类对象必须能够替换掉所有父类对象。而接口更像一个 Like-A 关系，他只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系</li>\n<li>从使用上来看，一个类可以实现多个接口，但不能继承多个类</li>\n<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制</li>\n<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限</li>\n</ul>\n<ol start=\"4\">\n<li>使用选择</li>\n</ol>\n<p>使用接口：</p>\n<ul>\n<li>需要让不相关的类都实现一个方法例如不相关的类都可以实现 Compareable 接口中的 compareTo () 方法</li>\n<li>需要使用多重继承</li>\n</ul>\n<p>使用抽象类</p>\n<ul>\n<li>需要在几个相关的类中共享代码</li>\n<li>需要能控制继承的成员访问权限，而不是都为 public</li>\n<li>需要继承非静态字段和非常量字段</li>\n</ul>\n<p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活的为一个类添加行为，并且从 Java8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变得很低</p>\n<h3 id=\"super\"><a class=\"markdownIt-Anchor\" href=\"#super\">#</a> super</h3>\n<ul>\n<li>访问父类的构造函数，可以使用 super () 函数访问父类的构造函数，从而委托父类完成一些初始化工作</li>\n<li>访问父类的成员，如果子类重写了父类中的某个方法的实现，可以通过 super 关键字来引用父类的方法实现</li>\n</ul>\n<pre><code class=\"language-Java\">\npublic class SuperExample &#123;\n    protected int x;\n    protected int y;\n\n    public SuperExample(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n\n    public void func() &#123;\n        System.out.println(&quot;SuperExample.func()&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\npublic class SuperExtendExample extends SuperExample &#123;\n    private int z;\n\n    public SuperExtendExample(int x, int y, int z) &#123;\n        super(x, y);\n        this.z = z;\n    &#125;\n\n    @Override\n    public void func() &#123;\n        super.func();\n        System.out.println(&quot;SuperExtendExample.func()&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\nSuperExample e = new SuperExtendExample(1, 2, 3);\ne.func();\n\n// SuperExample.func()\n// SuperExtendExample.func()\n\n</code></pre>\n<h3 id=\"重写与重载\"><a class=\"markdownIt-Anchor\" href=\"#重写与重载\">#</a> 重写与重载</h3>\n<ol>\n<li>\n<p>重写 (Override)<br>\n 存在于继承体系中，指字类实现了一个与父类在方法声明上完全相同的方法<br>\n为了满足里氏替换原则，重写有以下两个限制</p>\n<ul>\n<li>字类方法的访问权限必须大于等于父类方法</li>\n<li>字类方法的返回类型必须是父类方法的放回类型或为其子类型</li>\n</ul>\n</li>\n<li>\n<p>重载 (Overload)<br>\n 存在于同一个类中，指一个方法已经存在的方法名称上相同，但是<strong>参数类型</strong>、<strong>个数</strong>、<strong>顺序</strong>至少有一个不同<br>\n注意： 返回值不同，其他都相同不算是重载 (所以这种非重载方法会报错)</p>\n</li>\n</ol>\n<h2 id=\"object通用方法\"><a class=\"markdownIt-Anchor\" href=\"#object通用方法\">#</a> Object 通用方法</h2>\n<h3 id=\"概览-2\"><a class=\"markdownIt-Anchor\" href=\"#概览-2\">#</a> 概览</h3>\n<pre><code class=\"language-Java\">\npublic final native Class&lt;?&gt; getClass()\n\npublic native int hashCode()\n\npublic boolean equals(Object obj)\n\nprotected native Object clone() throws CloneNotSupportedException\n\npublic String toString()\n\npublic final native void notify()\n\npublic final native void notifyAll()\n\npublic final native void wait(long timeout) throws InterruptedException\n\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\npublic final void wait() throws InterruptedException\n\nprotected void finalize() throws Throwable &#123;&#125;\n\n</code></pre>\n<h3 id=\"equals\"><a class=\"markdownIt-Anchor\" href=\"#equals\">#</a> equals()</h3>\n<h4 id=\"等价关系\"><a class=\"markdownIt-Anchor\" href=\"#等价关系\">#</a> 等价关系</h4>\n<ol>\n<li>自反性</li>\n</ol>\n<pre><code class=\"language-Java\">\nx.equals(x); // true\n\n</code></pre>\n<ol start=\"2\">\n<li>对称性</li>\n</ol>\n<pre><code class=\"language-Java\">\nx.equals(y) == y.equals(x); // true\n\n</code></pre>\n<ol start=\"3\">\n<li>传递性</li>\n</ol>\n<pre><code class=\"language-Java\">\nif(x.equals(y) &amp;&amp; y.equals(z))\n     x.equals(z); // true\n\n</code></pre>\n<ol start=\"4\">\n<li>一致性<br>\n多次调用 equals 方法的结果不变</li>\n</ol>\n<pre><code class=\"language-Java\">\nx.equals(y) == x.equals(y); // true\n\n</code></pre>\n<ol start=\"5\">\n<li>与 NULL 的比较<br>\n对于任何不是 NULL 的对象 x 调用 x.equals (null) 结果都为 false</li>\n</ol>\n<pre><code class=\"language-Java\">\nx.equals(null); // false\n\n</code></pre>\n<h4 id=\"equals与\"><a class=\"markdownIt-Anchor\" href=\"#equals与\">#</a> equals 与 ==</h4>\n<ul>\n<li>对于基本类型，== 判断连个值是否相等，基本类型没有 equals</li>\n<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals 判断引用对象的对象是否等价</li>\n</ul>\n<pre><code class=\"language-Java\">\nInteger x = new Integer(1);\nInteger y = new Integer(1);\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x == y);      // false\n\n</code></pre>\n<h4 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h4>\n<ul>\n<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>\n<li>检查是否是同一个类型，如果不是，直接返回 false；</li>\n<li>将 Object 对象进行转型；</li>\n<li>判断每个关键域是否相等。</li>\n</ul>\n<pre><code class=\"language-Java\">\npublic class EqualExample &#123;\n    private int x;\n    private int y;\n    private int z;\n\n    public EqualExample(int x, int y, int z) &#123;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    &#125;\n\n    @Override\n    public boolean equals(Object o) &#123;\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        EqualExample that = (EqualExample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    &#125;\n&#125;\n\n</code></pre>\n<h3 id=\"hashcode\"><a class=\"markdownIt-Anchor\" href=\"#hashcode\">#</a> hashCode()</h3>\n<p>hashCode 返回散列值，而 Equals 是用来判断两个对象是否等价。等价的两个对象的散列值一定相同，但散列值相同的两个对象不一定等价</p>\n<p>在重写 equals 方法的同时应当也重写 hashCode 方法，保证等价的两个对象散列值也相等</p>\n<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode () 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>\n<pre><code class=\"language-Java\">\nEqualExample e1 = new EqualExample(1, 1, 1);\nEqualExample e2 = new EqualExample(1, 1, 1);\nSystem.out.println(e1.equals(e2)); // true\nHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();\nset.add(e1);\nset.add(e2);\nSystem.out.println(set.size());   // 2\n\n</code></pre>\n<h3 id=\"tostring\"><a class=\"markdownIt-Anchor\" href=\"#tostring\">#</a> toString()</h3>\n<p>默认返回 ToStringExample@455617c 这种形式，其中 @后面的数值为散列码的无符号十六进制表示</p>\n<h3 id=\"clone\"><a class=\"markdownIt-Anchor\" href=\"#clone\">#</a> clone()</h3>\n<ol>\n<li>cloneable</li>\n</ol>\n<p>clone () 是 Object 的 protected 方法，他不是 public，一个类不去显示的重写 clone，其他类就不能直接去调用该类实例的 clone 方法</p>\n<p>重写 clone</p>\n<pre><code class=\"language-Java\">\npublic class CloneExample &#123;\n    private int a;\n    private int b;\n\n    @Override\n    protected CloneExample clone() throws CloneNotSupportedException &#123;\n        return (CloneExample)super.clone();\n    &#125;\n&#125;\n\n</code></pre>\n<p>但是此时调用该 clone 方法，还是会报错</p>\n<blockquote>\n<p>java.lang.CloneNotSupportedException: CloneExample</p>\n</blockquote>\n<p>尽管 clone 并不是 Cloneable 接口的方法，但 Cloneable 规定，如果一个类没有实现 Cloneable 接口又调用了 clone 方法，就会报 CloneNotSupportedException</p>\n<h4 id=\"浅拷贝\"><a class=\"markdownIt-Anchor\" href=\"#浅拷贝\">#</a> 浅拷贝</h4>\n<p>拷贝对象和原始对象的引用类型引用同一个对象</p>\n<pre><code class=\"language-Java\">\npublic class ShallowCloneExample implements Cloneable &#123;\n    private int[] arr;\n\n    public ShallowCloneExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n\n    @Override\n    protected ShallowCloneExample clone() throws CloneNotSupportedException &#123;\n        return (ShallowCloneExample) super.clone();\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\nShallowCloneExample e1 = new ShallowCloneExample();\nShallowCloneExample e2 = null;\ntry &#123;\n    e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 222\n\n</code></pre>\n<h4 id=\"深拷贝\"><a class=\"markdownIt-Anchor\" href=\"#深拷贝\">#</a> 深拷贝</h4>\n<p>拷贝对象和原始对象的引用类型引用不同对象</p>\n<pre><code class=\"language-Java\">\npublic class DeepCloneExample implements Cloneable &#123;\n    private int[] arr;\n\n    public DeepCloneExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n\n    @Override\n    protected DeepCloneExample clone() throws CloneNotSupportedException &#123;\n        DeepCloneExample result = (DeepCloneExample) super.clone();\n        result.arr = new int[arr.length];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            result.arr[i] = arr[i];\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Java\">\nDeepCloneExample e1 = new DeepCloneExample();\nDeepCloneExample e2 = null;\ntry &#123;\n    e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n</code></pre>\n<h2 id=\"关键字\"><a class=\"markdownIt-Anchor\" href=\"#关键字\">#</a> 关键字</h2>\n<h3 id=\"final\"><a class=\"markdownIt-Anchor\" href=\"#final\">#</a> final</h3>\n<ol>\n<li>\n<p>数据<br>\n声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能改变的常量</p>\n<ul>\n<li>对于基本类型，final 使数据值不变</li>\n<li>对于引用类型，final 使引用不变，也就不能引用其他对象，但是引用的对象本身使可以修改的</li>\n</ul>\n</li>\n<li>\n<p>方法<br>\n声明方法不能被字类重写<br>\n Private 方法隐式的被指定为 final，如果子类中定义的方法基类中的一个 private 方法名相同，此时子类的方法不是重写方法，而是在子类中定义了一个新方法</p>\n</li>\n<li>\n<p>类<br>\n声明该类不允许被继承</p>\n</li>\n</ol>\n<h3 id=\"static\"><a class=\"markdownIt-Anchor\" href=\"#static\">#</a> static</h3>\n<ol>\n<li>静态变量\n<ul>\n<li>静态变量：又称为类变量，也就是说这个变量是属于类的，类所有的额实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份</li>\n<li>实例变量：没创建一个实例，就会产生一个实例变量，它与该实例同生共死</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class A &#123;\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(String[] args) &#123;\n        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context\n        int yy = A.y;\n        A a = new A();\n        int x = a.x;\n        int y = A.y;\n    &#125;\n&#125;\n\n</code></pre>\n<ol start=\"2\">\n<li>静态方法<br>\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法 (abstract)。</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic abstract class A &#123;\n    public static void func1()&#123;\n    &#125;\n    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'\n&#125;\n\n</code></pre>\n<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 supper 关键字</p>\n<pre><code class=\"language-Java\">\npublic class Demo11 &#123;\n\n    private int a = 10;\n    private static int b = 20;\n\n    public static void main(String[] args) &#123;\n        // int aa = a; // Non-static field 'a' cannot be referenced from a static context\n        // this.fun(); // this' cannot be referenced from a static context\n        int bb = b;\n    &#125;\n\n    public void fun()&#123;\n        System.out.println(&quot;Demo11.fun&quot;);\n    &#125;\n&#125;\n\n</code></pre>\n<ol start=\"3\">\n<li>静态语句块</li>\n</ol>\n<p>静态语句块在类初始化时运行一次</p>\n<pre><code class=\"language-Java\">\npublic class A &#123;\n    static &#123;\n        System.out.println(&quot;123&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        A a1 = new A();\n        A a2 = new A();\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Html\">\n123\n\n</code></pre>\n<ol start=\"4\">\n<li>非静态内部类</li>\n</ol>\n<p>非静态内部类依赖于外部类的实例，而静态内部类不需要</p>\n<pre><code class=\"language-Java\">\npublic class OuterClass &#123;\n\n    class InnerClass &#123;\n\n    &#125;\n\n    static class StaticInnerClass&#123;\n\n    &#125;\n\n    public static void main(String[] args) &#123;\n        OuterClass outerClass = new OuterClass();\n        // InnerClass innerClass = new InnerClass(); // OuterClass.this' cannot be referenced from a static context\n        InnerClass innerClass = outerClass.new InnerClass();\n        StaticInnerClass staticInnerClass = new StaticInnerClass();\n    &#125;\n&#125;\n\n</code></pre>\n<p><strong>注意：静态内部类不能访问外部类的非静态变量和方法</strong></p>\n<ol start=\"5\">\n<li>静态导包</li>\n</ol>\n<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低</p>\n<pre><code class=\"language-Java\">\nimport static com.xxx.ClassName.*\n\n</code></pre>\n<ol start=\"6\">\n<li>初始化顺序</li>\n</ol>\n<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序，取决于它们在代码中的顺序</p>\n<pre><code class=\"language-Java\">\npublic class StaticDemo12 &#123;\n\n    private static String str = &quot;static str变量&quot;;\n\n    static &#123;\n        System.out.println(&quot;static 块&quot;);\n    &#125;\n\n    public String field = &quot;实例变量&quot;;\n\n\n    public StaticDemo12() &#123;\n        System.out.println(&quot;StaticDemo12.StaticDemo12&quot;);\n    &#125;\n\n    &#123;\n        System.out.println(&quot;普通语句块&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        StaticDemo12 staticDemo12 = new StaticDemo12();\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"language-Html\">\nstatic 块\n普通语句块\nStaticDemo12.StaticDemo12\n\n</code></pre>\n<p>存在继承的情况下，初始化的顺序如下：</p>\n<ul>\n<li>父类 (静态变量、静态语句块)</li>\n<li>子类 (静态变量、静态语句块)</li>\n<li>父类 (实例变量、普通语句块)</li>\n<li>父类 (构造函数)</li>\n<li>子类 (实例变量、普通语句块)</li>\n<li>子类 (构造函数)</li>\n</ul>\n<h2 id=\"反射\"><a class=\"markdownIt-Anchor\" href=\"#反射\">#</a> 反射</h2>\n<p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的.class 文件，该文件内容保存着 Class 对象</p>\n<p>类加载相当于 Class 对象的加载，类在第一次使用时在动态加载到 JVM 中，可以使用 Class.forName (“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>\n<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的.class 不存在也可以加载进来</p>\n<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含以下三个类</p>\n<ul>\n<li>Field：可以使用 get () 和 set () 方法读取和修改 Field 对象关联的字段</li>\n<li>Method：可以使用 invoke () 方法调用与 Method 对象关联的方法</li>\n<li>Constructor：可以用 Constructor 创建新的对象</li>\n</ul>\n<h2 id=\"异常\"><a class=\"markdownIt-Anchor\" href=\"#异常\">#</a> 异常</h2>\n<p>Thorwable 可以用来表示任何可以作为异常抛出的类，分为两种：Error 和 Exception。其中 Error 表示 JVM 无法处理的错误，Exception 分为两种：</p>\n<ul>\n<li>受检异常：需要用 try…catch 语句捕获并进行处理，并且可以从一场中恢复</li>\n<li>非受检异常：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复</li>\n</ul>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/PPjwP.png\" alt=\"异常\"></p>\n<h2 id=\"泛型\"><a class=\"markdownIt-Anchor\" href=\"#泛型\">#</a> 泛型</h2>\n<pre><code class=\"language-Java\">\npublic class Box&lt;T&gt; &#123;\n    // T stands for &quot;Type&quot;\n    private T t;\n    public void set(T t) &#123; this.t = t; &#125;\n    public T get() &#123; return t; &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"注解\"><a class=\"markdownIt-Anchor\" href=\"#注解\">#</a> 注解</h2>\n<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "title": "面向对象",
            "date_published": "2024-02-18T08:13:44.946Z",
            "content_html": "<h1 id=\"java基础-面向对象\"><a class=\"markdownIt-Anchor\" href=\"#java基础-面向对象\">#</a> Java 基础 - 面向对象</h1>\n<h2 id=\"三大特性\"><a class=\"markdownIt-Anchor\" href=\"#三大特性\">#</a> 三大特性</h2>\n<p><strong>封装</strong></p>\n<p>利用抽象数据类型将<em>数据</em>和<em>基于数据的操作</em>封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生关系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>\n<p>优点：</p>\n<ul>\n<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>\n<li>减轻维护的负担：可以更容易地被程序员所理解，并且在调试的时候可以不影响其他模块</li>\n<li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能</li>\n<li>提供软件的可重用性</li>\n<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>\n</ul>\n<p><strong>继承</strong></p>\n<p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>\n<p>继承应该遵守里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>\n<p>Cat 可以当作 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象 (<em>父类引用指向子类的实现</em>) 称为 <strong>向上转型</strong>。</p>\n<blockquote>\n<p>Animal animal = new Cat();</p>\n</blockquote>\n<p><strong>多态</strong></p>\n<p>多态分为编译时多态和运行时多态：</p>\n<ul>\n<li>编译时多态主要指方法的重载</li>\n<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定<br>\n运行时多态有三个条件\n<ul>\n<li>继承</li>\n<li>覆盖 (重写)</li>\n<li>向上转型</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类\"><a class=\"markdownIt-Anchor\" href=\"#类\">#</a> 类</h2>\n<h3 id=\"泛化关系generalization\"><a class=\"markdownIt-Anchor\" href=\"#泛化关系generalization\">#</a> 泛化关系 (Generalization)</h3>\n<p>用于描述继承关系，在 Java 中使用 extends 关键字</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png\" alt=\"泛型关系\"></p>\n<pre><code>\nclass Vehical\nclass Car\nclass Truck\n\nVehical &lt;| -- Car\nVehical &lt;| -- Truck\n\n</code></pre>\n<h3 id=\"实现关系realization\"><a class=\"markdownIt-Anchor\" href=\"#实现关系realization\">#</a> 实现关系 (Realization)</h3>\n<p>用来实现一个接口，在 Java 中使用 implements 关键字</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILK8IatCoQn.png\" alt=\"实现关系\"></p>\n<pre><code>\ninterface MoveBehavior\nclass Fly\nclass Run\n\nMoveBehavior &lt;| -- Fly\nMoveBehivior &lt;| -- Run\n\n</code></pre>\n<h3 id=\"聚合关系aggregation\"><a class=\"markdownIt-Anchor\" href=\"#聚合关系aggregation\">#</a> 聚合关系 (Aggregation)</h3>\n<p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了但部分还是会存在</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png\" alt=\"实现关系\"></p>\n<pre><code>\nclass Computer\nclass Keyboard\nclass Mouse\nclass Screen\n\nComputer o -- Keyboard\nComputer o -- Mouse\nComputer o -- Screen\n\n</code></pre>\n<h3 id=\"组合关系composition\"><a class=\"markdownIt-Anchor\" href=\"#组合关系composition\">#</a> 组合关系 (Composition)</h3>\n<p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了，部分也就不存在了</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png\" alt=\"实现关系\"></p>\n<pre><code>\nclass Company\nclass DepartmentA\nclass DepartmentB\n\nCompany * -- DepartmentA\nCompany * -- DepartmentB\n\n</code></pre>\n<h3 id=\"关联关系association\"><a class=\"markdownIt-Anchor\" href=\"#关联关系association\">#</a> 关联关系 (Association)</h3>\n<p>表示不同对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此可以用 1 对 1、多对 1、多对多这种关联关系来表示</p>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/SoWkIImgAStDuU8goIp9ILLmB2xEJyv.png\" alt=\"实现关系\"></p>\n<pre><code>\nclass School\nclass Student\n\nSchool &quot;1&quot; - &quot;n&quot; Student\n\n</code></pre>\n<h3 id=\"依赖关系dependency\"><a class=\"markdownIt-Anchor\" href=\"#依赖关系dependency\">#</a> 依赖关系 (Dependency)</h3>\n<p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>\n<ul>\n<li>A 类是 B 类中的 (某种方法的) 局部变量</li>\n<li>A 类是 B 类方法当中的一个参数</li>\n<li>A 类向 B 类发送消息，从而影响 B 类发生变化</li>\n</ul>\n<p><img data-src=\"/image/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/LOun2W9134NxVugmbJPp15d4LalxC4O.png\" alt=\"实现关系\"></p>\n<pre><code>\nclass Vehicle &#123;\n    move(MoveBehavior)\n&#125;\n\ninterface MoveBehavior &#123;\n    move()\n&#125;\n\nnote &quot;MoveBehavior.move()&quot; as N\n\nVehicle ..&gt; MoveBehavior\n\nVehicle .. N\n\n</code></pre>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/",
            "title": "泛型机制详解",
            "date_published": "2024-02-18T08:13:44.946Z",
            "content_html": "<p>Java 泛型是从 jdk1.5 开始加入的，Java 泛型的实现采取了 “伪泛型” 的策略，即 Java 在语法上支持泛型，但是在编译阶段会进行所谓的 “类型擦除”，将所有的泛型表示 (尖括号中的内容) 都替换为具体的类型 (其对应的原生态类型)，就像完全没有泛型一样。</p>\n<p>引入泛型的意义在于：</p>\n<ul>\n<li>适用于多种数据类型执行相同的代码 (代码复用)</li>\n</ul>\n<pre><code class=\"language-Java\">private static int add(int a, int b) &#123;\n    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));\n    return a + b;\n&#125;\n\nprivate static float add(float a, float b) &#123;\n    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));\n    return a + b;\n&#125;\n\nprivate static double add(double a, double b) &#123;\n    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));\n    return a + b;\n&#125;\n</code></pre>\n<p>如果没有泛型，要实现不同类型的方法，每种类型都需要重载一个 add 方法，通过泛型，我们可以复用为一个方法：</p>\n<pre><code class=\"language-Java\">private static &lt;T extends Number&gt; double add(T a, T b) &#123;\n    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue()));\n    return a.doubleValue() + b.doubleValue();\n&#125;\n</code></pre>\n<ul>\n<li>泛型中的类型在使用时指定，不需要强制类型转换 (类型安全，编译器会检查类型)</li>\n</ul>\n<h2 id=\"泛型的基本使用\"><a class=\"markdownIt-Anchor\" href=\"#泛型的基本使用\">#</a> 泛型的基本使用</h2>\n<h3 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h3>\n<ul>\n<li>从一个简单的泛型类看起：</li>\n</ul>\n<pre><code class=\"language-Java\">class Point&lt;T&gt;&#123;         // 此处可以随便写标识符号，T是type的简称  \n    private T var ;     // var的类型由T指定，即：由外部指定  \n    public T getVar()&#123;  // 返回值的类型由外部决定  \n        return var ;  \n    &#125;  \n    public void setVar(T var)&#123;  // 设置的类型也由外部决定  \n        this.var = var ;  \n    &#125;  \n&#125;  \npublic class GenericsDemo06&#123;  \n    public static void main(String args[])&#123;  \n        Point&lt;String&gt; p = new Point&lt;String&gt;() ;     // 里面的var类型为String类型  \n        p.setVar(&quot;it&quot;) ;                            // 设置字符串  \n        System.out.println(p.getVar().length()) ;   // 取得字符串的长度  \n    &#125;  \n&#125;\n</code></pre>\n<ul>\n<li>多元泛型</li>\n</ul>\n<pre><code class=\"language-Java\">class Notepad&lt;K,V&gt;&#123;       // 此处指定了两个泛型类型  \n    private K key ;     // 此变量的类型由外部决定  \n    private V value ;   // 此变量的类型由外部决定  \n    public K getKey()&#123;  \n        return this.key ;  \n    &#125;  \n    public V getValue()&#123;  \n        return this.value ;  \n    &#125;  \n    public void setKey(K key)&#123;  \n        this.key = key ;  \n    &#125;  \n    public void setValue(V value)&#123;  \n        this.value = value ;  \n    &#125;  \n&#125; \npublic class GenericsDemo09&#123;  \n    public static void main(String args[])&#123;  \n        Notepad&lt;String,Integer&gt; t = null ;        // 定义两个泛型类型的对象  \n        t = new Notepad&lt;String,Integer&gt;() ;       // 里面的key为String，value为Integer  \n        t.setKey(&quot;汤姆&quot;) ;        // 设置第一个内容  \n        t.setValue(20) ;            // 设置第二个内容  \n        System.out.print(&quot;姓名；&quot; + t.getKey()) ;      // 取得信息  \n        System.out.print(&quot;，年龄；&quot; + t.getValue()) ;       // 取得信息  \n    &#125;  \n&#125;\n</code></pre>\n<h3 id=\"泛型接口\"><a class=\"markdownIt-Anchor\" href=\"#泛型接口\">#</a> 泛型接口</h3>\n<ul>\n<li>简单的泛型接口</li>\n</ul>\n<pre><code class=\"language-Java\">interface Info&lt;T&gt;&#123;        // 在接口上定义泛型  \n    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  \n&#125;  \nclass InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123;   // 定义泛型接口的子类  \n    private T var ;             // 定义属性  \n    public InfoImpl(T var)&#123;     // 通过构造方法设置属性内容  \n        this.setVar(var) ;    \n    &#125;  \n    public void setVar(T var)&#123;  \n        this.var = var ;  \n    &#125;  \n    public T getVar()&#123;  \n        return this.var ;  \n    &#125;  \n&#125; \npublic class GenericsDemo24&#123;  \n    public static void main(String arsg[])&#123;  \n        Info&lt;String&gt; i = null;        // 声明接口对象  \n        i = new InfoImpl&lt;String&gt;(&quot;汤姆&quot;) ;  // 通过子类实例化对象  \n        System.out.println(&quot;内容：&quot; + i.getVar()) ;  \n    &#125;  \n&#125;\n</code></pre>\n<h3 id=\"泛型方法\"><a class=\"markdownIt-Anchor\" href=\"#泛型方法\">#</a> 泛型方法</h3>\n<p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p>\n<ul>\n<li>定义泛型方法的语法格式</li>\n</ul>\n<pre><code class=\"language-Java\">public class Sace &#123;\n\n    // &lt;T&gt; 声明此方法持有一个类型T，也可以理解为声明此方法为泛型方法\n    // T 指明该方法返回对象为T类型\n    // Class&lt;T&gt; 指明泛型的具体类型\n    public &lt;T&gt; T getObject(Class&lt;T&gt; c) throws InstantiationException, IllegalAccessException &#123;\n        T t = c.newInstance();\n        return t;\n    &#125;\n\n    public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123;\n        Sace sace = new Sace();\n        Class&lt;Date&gt; aClass = Date.class;\n        Date object = sace.getObject(aClass);\n        System.out.println(object);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"泛型的上下限\"><a class=\"markdownIt-Anchor\" href=\"#泛型的上下限\">#</a> 泛型的上下限</h3>\n<p>以下代码会报错</p>\n<pre><code class=\"language-Java\">class A&#123;&#125;\nclass B extends A &#123;&#125;\n\n// 如下两个方法不会报错\npublic static void funA(A a) &#123;\n    // ...          \n&#125;\npublic static void funB(B b) &#123;\n    funA(b);\n    // ...             \n&#125;\n\n// 如下funD方法会报错\npublic static void funC(List&lt;A&gt; listA) &#123;\n    // ...          \n&#125;\npublic static void funD(List&lt;B&gt; listB) &#123;\n    funC(listB); // Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;)\n    // ...             \n&#125;\n</code></pre>\n<p>为了解决泛型中隐含的转换问题，Java 泛型加入了类型参数的上下边界机制。&lt;? extends A&gt; 表示该类型参数可以是 A (上边界) 或者 A 的子类类型。编译时擦除到类型 A，即用 A 类型代替类型参数。这种方法可以解决开始遇到的问题。</p>\n<pre><code class=\"language-Java\">public static void funC(List&lt;? extends A&gt; listA) &#123;\n    // ...          \n&#125;\npublic static void funD(List&lt;B&gt; listB) &#123;\n    funC(listB); // OK\n    // ...             \n&#125;\n</code></pre>\n<ul>\n<li>泛型上下限的引入<br>\n在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，比如：类型实参只准传入某种类型的夫类型或某种类型的子类</li>\n</ul>\n<p>上限</p>\n<pre><code class=\"language-Java\">public class Info&lt;T extends Number&gt; &#123;\n    T val;\n\n    public T getVal() &#123;\n        return val;\n    &#125;\n\n    public void setVal(T val) &#123;\n        this.val = val;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Info info = new Info&lt;Double&gt;();\n        Info info2 = new Info&lt;Integer&gt;();\n        info.val = 10;\n        info2.val = 10f;\n        System.out.println(info.val);\n        System.out.println(info2.val);\n    &#125;\n&#125;\n</code></pre>\n<p>下限</p>\n<pre><code class=\"language-Java\">public class Info&lt;T&gt; &#123;\n    T val;\n\n    public T getVal() &#123;\n        return val;\n    &#125;\n\n    public void setVal(T val) &#123;\n        this.val = val;\n    &#125;\n\n    public static void fun(Info&lt;? super String&gt; temp) &#123;    // 只能接收String或Object类型的泛型，String类的父类只有Object类\n        System.out.print(temp + &quot;, &quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Info&lt;String&gt; info = new Info&lt;String&gt;();\n        Info&lt;Object&gt; info2 = new Info&lt;Object&gt;();\n        Info&lt;Integer&gt; info3 = new Info&lt;Integer&gt;();\n        fun(info);\n        fun(info2);\n        fun(info3); // info3不允许作为fun的形参，info3是Integer泛型对象，需要一个String的父类，包括String类\n    &#125;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>\n<?> 无限制通配符\n</li>\n<li>\n<? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类\n</li>\n<li>\n<? super E> super 关键字声明了类型的下界，表示了参数化的类型可能是指定类型，或者是次类型的父类</li>\n</ol>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
            "url": "http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
            "title": "函数式编程",
            "date_published": "2024-02-18T08:13:44.938Z",
            "content_html": "<h1 id=\"函数式编程\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程\">#</a> 函数式编程</h1>\n<p>一种 语法优雅、简洁健壮、高并发、易于测试和调试 的编程方式，这就是函数式编程 (FP) 的意义所在。</p>\n<blockquote>\n<p>OO (Object oriented, 面向对象) 是抽象数据<br>\n FP (Function programming, 函数式编程) 是抽象行为</p>\n</blockquote>\n<p>两个关键概念:</p>\n<blockquote>\n<ul>\n<li>函数是第一等公民</li>\n<li>函数要满足以下约束\n<ul>\n<li>函数的返回值仅取决于传递给函数的输入参数</li>\n<li>函数的执行没有副作用</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"函数是一等公民\"><a class=\"markdownIt-Anchor\" href=\"#函数是一等公民\">#</a> 函数是一等公民</h3>\n<blockquote>\n<p>在函数式编程范式中，函数是语言的第一等公民。这意味着可以创建函数的 “实例”，对函数实例的变量引用，就像对字符串、Map 或者任何其他对象的引用一样。函数也可以作为参数传递给其他函数。</p>\n</blockquote>\n<blockquote>\n<p>在 Java 中，函数显然不是第一等公民，类 (Class) 才是。所以 Java 才引用 Lambda 表达式，这个语法糖从表现层让 Java 拥有了函数，让函数可以作为变量的引用、方法的参数等等。（为什么说是从表现层呢？因为实际上，在编译的时候，Java 编译器还是会把 Lambda 表达式编译成类。</p>\n</blockquote>\n<hr>\n<h3 id=\"纯函数\"><a class=\"markdownIt-Anchor\" href=\"#纯函数\">#</a> 纯函数</h3>\n<p>函数式编程中，有个纯函数 (Pure Function) 的概念，如果一个函数满足以下条件，才是纯函数：</p>\n<ul>\n<li>该函数的执行没有副作用</li>\n<li>函数的返回值仅取决于传递给函数的输入参数</li>\n</ul>\n<pre><code class=\"language-Java\">public class ObjectWithPureFunction&#123;\n    public int sum(int a, int b)&#123;\n        return a+b;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"非纯函数\"><a class=\"markdownIt-Anchor\" href=\"#非纯函数\">#</a> 非纯函数</h3>\n<p>上面的 sum 方法的返回值仅取决于其输入参数，而且 sum 是没有副作用的，它不会在任何地方修改函数之外的任何状态 (变量)</p>\n<p>相反，这个一个非纯函数的例子:</p>\n<pre><code class=\"language-Java\">public class ObjectWithNonPureFunction&#123;\n    private int value = 0;\n\n    public int add(int nextValue) &#123;\n        this.value += nextValue;\n        return this.value;\n    &#125;\n&#125;\n</code></pre>\n<p>add 方法使用成员变量 value 来计算返回值，并且它还修改了 value 成员变量，这代表它有副作用，这两个条件都导致 add 方法不是一个纯函数</p>\n<hr>\n<h2 id=\"函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口\">#</a> 函数式接口</h2>\n<p>所谓函数式接口，实际上就是接口里面有且只能有一个抽象方法的接口。</p>\n<p>函数式接口也称为 单一抽象方法 (SAM) 接口</p>\n<h3 id=\"函数式接口的特点\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口的特点\">#</a> 函数式接口的特点</h3>\n<ul>\n<li>接口有且仅有一个抽象方法，如接口 Comparator</li>\n<li>允许出现 java.lang.Object 中的 public 方法，如 equals</li>\n<li>允许定义静态非抽象方法</li>\n<li>允许定义默认 default 非抽象方法 (default 方法式 java8 开始出现的)</li>\n<li>FunctionInterface 注解不是必须的，如果一个接口符合 “函数式接口” 的定义，那么不加该注解也没有影响</li>\n</ul>\n<blockquote>\n<p>甚至可以说：函数式接口是专门为 lambda 表达式准备的，lambda 表达式是只实现接口中唯一抽象方法的匿名实现类</p>\n</blockquote>\n<h3 id=\"default关键字\"><a class=\"markdownIt-Anchor\" href=\"#default关键字\">#</a> default 关键字</h3>\n<p>在 java8 之前</p>\n<ul>\n<li>接口是不能有方法的实现，所有的方法必须是抽象方法</li>\n<li>实现接口就必须实现接口里面的所有方法</li>\n</ul>\n<blockquote>\n<p>这样导致：当一个接口有很多实现类的时候，修改这个接口，就必须修改所有的实现类。</p>\n</blockquote>\n<p>不过在 java8 中这个问题得到解决，这就是 default 方法</p>\n<ul>\n<li>default 方法可以有自己的默认实现，即有方法体</li>\n<li>接口实现类可以不去实现 default 方法，并且可以使用 default 方法</li>\n</ul>\n<h3 id=\"jdk中函数式接口的举例\"><a class=\"markdownIt-Anchor\" href=\"#jdk中函数式接口的举例\">#</a> JDK 中函数式接口的举例</h3>\n<ul>\n<li>java.lang.Runnable,</li>\n<li>java.util.Comparator,</li>\n<li>java.util.concurrent.Callable</li>\n<li>java.util.function 包下的接口，如 Consumer、Predicate、Supplier 等</li>\n</ul>\n<blockquote>\n<p>编译器会根据 Lambda 表达式的参数和返回值类型推断出其实现的抽象方法，进而推断出其实现的接口，如果一个接口有多个抽象方法，显然是没有办法用 Lambda 表达式实现该接口的</p>\n</blockquote>\n<h3 id=\"functioninterface-注解\"><a class=\"markdownIt-Anchor\" href=\"#functioninterface-注解\">#</a> @FunctionInterface 注解</h3>\n<p><strong>标注接口是一个函数式接口的注解</strong></p>\n<pre><code class=\"language-Java\">@FunctionalInterface // 标明接口为函数式接口\npublic interface MyInterface &#123;\n    public void run(); //抽象方法\n&#125;\n</code></pre>\n<p>一旦使用了该注解标注接口，Java 的编译器会强制检查该接口是否满足函数式接口的要求：“确实仅有一个抽象方法”，否则将会报错</p>\n<p>需要注意的是，及时不适用该注解，只要有一个接口满足函数式接口的要求，那它仍然是一个函数式接口，使用起来都一样。该注解只起到标记接口指示编译器对其进行检查的作用</p>\n<h3 id=\"java内置的函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#java内置的函数式接口\">#</a> Java 内置的函数式接口</h3>\n<p><strong>Function</strong></p>\n<p>Function 接口（全限定名：java.util.function.Function）是 Java 中最核心的函数式接口。 Function 接口表示一个接受单个参数并返回单个值的函数（方法）</p>\n<p><strong>Predicate</strong></p>\n<p>Predicate 接口 （全限定名：java.util.function.Predicate）表示一个接收单个参数，并返回布尔值 true 或 false 的函数</p>\n<p><strong>Supplier</strong></p>\n<p>Supplier 接口（java.util.function.Supplier），表示提供某种值的函数</p>\n<p><strong>Consume</strong></p>\n<p>Consumer 接口（java.util.function.Consume）表示一个函数，该函数接收一个参数，但是不返回任何值</p>\n<p><strong>Optional</strong></p>\n<p>Optional 接口并不是一个函数式接口，它常在 Stream 操作中出现，作为操作的返回值类型。</p>\n<p>Optional 接口是预防 NullPointerException 的好工具，它是一个简单的容器，其值可以是 null 或非 null。比如一个可能返回一个非空结果的方法，方法在有些情况下返回值，有些情况不满足返回条件返回空值，这种情况下使用 Optional 接口作为返回类型，比直接无值时返回 Null 要更安全</p>\n<hr>\n<h2 id=\"lambda表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda表达式\">#</a> Lambda 表达式</h2>\n<h3 id=\"双冒号语法\"><a class=\"markdownIt-Anchor\" href=\"#双冒号语法\">#</a> 双冒号语法</h3>\n<p>其实双冒号就是 lambda 表达式的简写。被用作方法的引用。使用 lambda 表达式会创建匿名方法，但是有时候会需要一个 lambda 表达式只调用一个已经存在的方法，在此才有了方法的引用</p>\n<ol>\n<li>静态方法的引用 (static method)</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Demo &#123;\n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//静态方法语法\tClassName::methodName\n\t\tlist.forEach(Demo::print);\n\t&#125;\n\t\n\tpublic static void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>对象实例方法的引用</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Demo &#123;\n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//静态方法语法\tClassName::methodName\n\t\tlist.forEach(new Demo()::print);\n\t&#125;\n\t\n\tpublic void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>对象的超类方法引用</li>\n</ol>\n<pre><code class=\"language-Java\">public class Example extends BaseExample&#123;\n \n\t@Test\n\tpublic void test() &#123;\n\t\tList&lt;String&gt; list = Arrays.asList(&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;);\n\t\t\n\t\t//对象的超类方法语法： super::methodName \n\t\tlist.forEach(super::print);\n\t&#125;\n&#125;\n \nclass BaseExample &#123;\n\tpublic void print(String content)&#123;\n\t\tSystem.out.println(content);\n\t&#125;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>类构造器引用</li>\n</ol>\n<pre><code class=\"language-Java\">\npublic class Example &#123;\n \n\t@Test\n\tpublic void test() &#123;\n\t\tInterfaceExample com =  Example::new;\n\t\tExample bean = com.create();\n        Example bean = com.create(&quot;STRING&quot;);\n\t\tSystem.out.println(bean);\n\t&#125;\n&#125;\n \ninterface InterfaceExample&#123;\n    //不带参数\n\tExample create();\n    //带参数\n    Example create(String str);\n&#125;\n</code></pre>\n",
            "tags": [
                "Java"
            ]
        }
    ]
}