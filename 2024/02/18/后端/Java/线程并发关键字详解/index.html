<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Live My Life" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Live My Life" type="application/atom+xml"><link rel="alternate" type="application/json" title="Live My Life" href="http://1405904364.github.io/feed.json"/><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"/><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"/><link rel="dns-prefetch" href="https://unpkg.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.3.3"><script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.js"></script><link rel="canonical" href="http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/"><title></title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"></h1><div class="meta"><span class="item" title="创建时间：2024-02-18 16:13:44"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2024-02-18T16:13:44+08:00">2024-02-18</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>11k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">testName</a></li></ul><ul class="right" id="rightNav"><li class="item theme" @click="changeThemeByBtn"><i class="ic" :class="{'i-sun': !themeStatus,'i-moon': themeStatus}"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" data-background-image="https://i.imgtg.com/2023/03/09/Y0kTl.jpg"></li><li class="item" data-background-image="https://i.imgtg.com/2023/03/09/Y0iNK.jpg"></li><li class="item" data-background-image="https://i.imgtg.com/2023/03/09/YQSYM.jpg"></li><li class="item" data-background-image="https://i.imgtg.com/2023/03/09/YSj7p.jpg"></li><li class="item" data-background-image="https://i.imgtg.com/2023/03/09/Y0hOs.jpg"></li><li class="item" data-background-image="https://images.pexels.com/photos/12635428/pexels-photo-12635428.jpeg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="一念成余"/><meta itemprop="description" content="一念成余, 个人学习使用"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Live My Life"/></span><div class="body md" itemprop="articleBody"><h1 id="线程并发关键字详解"><a class="markdownIt-Anchor" href="#线程并发关键字详解">#</a> 线程并发关键字详解</h1>
<h2 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized">#</a> synchronized</h2>
<h4 id="使用"><a class="markdownIt-Anchor" href="#使用">#</a> 使用</h4>
<ul>
<li>​	一把锁只能同时被一个线程获取，没有获取锁的线程只能等待。</li>
<li>每个实例都对应有自己的一把锁 (this)，不同实例之间互不影响。例外：锁对象时 class 以及 synchronized 修饰的是 static 方法的时候，所有对象巩永固同一把锁。</li>
<li>synchronized 修饰的方法，无论方法正常执行还是抛出异常，都会释放锁。</li>
</ul>
<h4 id="对象锁"><a class="markdownIt-Anchor" href="#对象锁">#</a> 对象锁</h4>
<p>包括方法锁 (默认锁对象为 this, 当前实例对象) 和同步代码块锁 (自己指定锁对象)</p>
<ul>
<li>代码块形式：手动指定锁定对象，也可是是 this, 也可以是自定义的锁</li>
<li>方法锁形式：synchronized 修饰普通方法，锁对象默认为 this</li>
</ul>
<h4 id="类锁"><a class="markdownIt-Anchor" href="#类锁">#</a> 类锁</h4>
<p>​	指定 synchronized 修饰静态方法，或者指定锁对象为 Class 对象。</p>
<ul>
<li>synchronize 修饰静态方法</li>
<li>synchronized 指定锁对象为 Class 对象</li>
</ul>
<h3 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析">#</a> 原理分析</h3>
<h4 id="加锁和释放锁的原理"><a class="markdownIt-Anchor" href="#加锁和释放锁的原理">#</a> 加锁和释放锁的原理</h4>
<p><code>Monitorenter</code>  和 <code>Monitorexit</code>  指令，会让对象在执行，使其锁计数器加 1 或者减 1。每一个对象在同一时间只与一个 monitor (锁) 相关联，而一个 monitor 在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的 Monitor 锁的所有权的时候，monitorenter 指令会发生如下 3 中情况之一：</p>
<ul>
<li>monitor 计数器为 0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器 + 1，一旦 + 1，别的线程再想获取，就需要等待</li>
<li>如果这个 monitor 已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成 2，并且随着重入的次数，会一直累加</li>
<li>这把锁已经被别的线程获取了，等待锁释放</li>
</ul>
<p><code>monitorexit指令</code> ：释放对于 monitor 的所有权，释放过程很简单，就是讲 monitor 的计数器减 1，如果减完以后，计数器不是 0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成 0，则代表当前线程不再拥有该 monitor 的所有权，即释放锁。</p>
<p>下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：</p>
<p><img data-src="https://pdai.tech/images/thread/java-thread-x-key-schronized-2.png" alt="img"></p>
<p>该图可以看出，任意线程对 Object 的访问，首先要获得 Object 的监视器，如果获取失败，该线程就进入同步状态，线程状态变为 BLOCKED，当 Object 的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p>
<h4 id="可重入原理加锁次数计数器"><a class="markdownIt-Anchor" href="#可重入原理加锁次数计数器">#</a> 可重入原理：加锁次数计数器</h4>
<ul>
<li>可重入：当一个子程序正在运行是，执行线程可以再次进入并执行它，仍然获得符合设计预期的结果，则称其为可重入（reentrant 或 re-entrant）。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时，重新进入同一个子程序仍然时安全的。</li>
<li>可重入锁：又名递归锁，是指同一个线程在外层方法获取锁的时候，再进入线程的内层方法会自动获取锁（前提是锁对象时同一个对象或者同一个 class），不会因为之前已经获取过还没有释放锁而阻塞。</li>
</ul>
<p>这就是 Synchronized 的重入性，即在<strong>同一锁程</strong>中，每个对象拥有一个 monitor 计数器，当线程获取该对象锁后，monitor 计数器就会加一，释放锁后就会将 monitor 计数器减一，线程不需要再次获取同一把锁。</p>
<h4 id="保证可见性原理内存模型和happens-before规则"><a class="markdownIt-Anchor" href="#保证可见性原理内存模型和happens-before规则">#</a> 保证可见性原理：内存模型和 happens-before 规则</h4>
<p>synchronized 的 happens-before 规则，即监视器锁规则：对同一个监视器的解锁，happens-before 对于该监视器的加锁。</p>
<p><strong>即，A 线程拿到锁修改了共享变量后，在释放锁之前，会将缓存中修改后的值刷入主存当中，通知其他线程共享变量已被修改。然后 B 线程获取了锁以后，会自动去主存中获取更新后的共享变量值。</strong></p>
<p><img data-src="https://pdai.tech/images/thread/java-thread-x-key-schronized-3.png" alt="img"></p>
<p>在图中每一个箭头连接的两个节点就代表之间的 happens-before 关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程 A 释放锁 happens-before 线程 B 加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来 happens-before 关系，通过传递性规则进一步推导的 happens-before 关系。现在我们来重点关注 2 happens-before 5，通过这个关系我们可以得出什么？</p>
<p>根据 happens-before 的定义中的一条：如果 A happens-before B，则 A 的执行结果对 B 可见，并且 A 的执行顺序先于 B。线程 A 先对共享变量 A 进行加一，由 2 happens-before 5 关系可知线程 A 的执行结果对线程 B 可见即线程 B 所读取到的 a 的值为 1。</p>
<h3 id="jvm中锁的优化"><a class="markdownIt-Anchor" href="#jvm中锁的优化">#</a> JVM 中锁的优化</h3>
<p>​	在 JVM 中 monitorenter 和 monitorexit 字节码依赖于底层的操作系统的 Mutex Lock 来实现的，但是由于使用 Mutex Lock 需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。不过在 jdk1.6 中对锁的实现引用了大量优化。</p>
<ul>
<li>锁粗化：也就是减少不必要的紧连在一起的 unlock，lock 操作，将多个连续的锁扩展成一个范围更大的锁。</li>
<li>锁消除：通过运行 JIT 编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁的保护，通过逃逸分析也可以在线程的 stack 上进行对象空间的分配（同时还可以减少 Heap 上的垃圾收集开销）。</li>
<li>轻量级锁：</li>
<li>这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态 (即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在 monitorenter 和 monitorexit 中只需要依靠一条 CAS 原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行 CAS 指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒</li>
<li>偏向锁：是为了在无锁竞争的情况下避免在锁获取的过程中执行不必要的 CAS 原子指令，因为 CAS 原子指令虽然相对重量级锁开销较小，但还是存在非常可观的本地延迟。</li>
<li>适应性自旋锁：</li>
<li>当线程在获取轻量级锁的过程中执行 CAS 操作失败时，在进入与 monitor 相关联的操作系统重量级锁 (mutex semaphore) 前会进入忙等待 (Spinning) 然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该 monitor 关联的 semaphore (即互斥锁) 进入到阻塞状态。</li>
</ul>
<h4 id="锁的类型"><a class="markdownIt-Anchor" href="#锁的类型">#</a> 锁的类型</h4>
<p>jdk1.6 中 synchronized 同步锁，一共存在四种状态：无锁、偏向锁、轻量级锁、重量级锁。它会随着竞争情况逐渐升级，但是不可以降级，目的是为了提供获取锁和释放锁的效率。</p>
<h4 id="自旋锁-自适应自旋锁"><a class="markdownIt-Anchor" href="#自旋锁-自适应自旋锁">#</a> 自旋锁、自适应自旋锁</h4>
<h4 id="锁消除"><a class="markdownIt-Anchor" href="#锁消除">#</a> 锁消除</h4>
<p>​	锁消除是指虚拟机运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除主要判定依据来源于逃逸分析的数据支持。意思就是：JVM 会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那 JVM 就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p>
<p>​	当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在 Java API 中有很多方法都是加了同步的，那么此时 JVM 会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。</p>
<p>​	<strong>比如如下操作：在操作 String 类型数据时，由于 String 是一个不可变类，对字符串的连接操作总是通过生成的新的 String 对象来进行的。因此 Javac 编译器会对 String 连接做自动优化。在 JDK 1.5 之前会使用 StringBuffer 对象的连续 append () 操作，在 JDK 1.5 及以后的版本中，会转化为 StringBuidler 对象的连续 append () 操作 (因为 String 是不可变类，是线程安全类，所以编译器会转为 StringBuilder 进行操作，在不会产出线程安全问题的同时，相对于使用 String 类型操作更高效，)。</strong></p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">test03</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">,</span> <span class="token class-name">String</span> s3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">String</span> s <span class="token operator">=</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="锁粗化"><a class="markdownIt-Anchor" href="#锁粗化">#</a> 锁粗化</h4>
<p>​	原则上，在加同步锁时，尽可能将同步块的作用范围限制到尽量小的范围（在存在锁的同步竞争中，也可以使得等待锁的线程尽早拿到锁）。</p>
<p>​	但是如果存在一系列操作都对同一个对象反复加锁和解锁，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p>
<p>​	例如：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">test04</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">,</span> <span class="token class-name">String</span> s3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>​	这里的连续 append () 操作就属于这种情况，JVM 会检测到这样一连串的操作都是对同一个对象加锁，那么 JVM 会将加锁同步的范围扩展（粗化）到整个一系列操作的外部，使整个一连串的 append () 操作只需要加一次所就可以了。</p>
<h4 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁">#</a> 偏向锁</h4>
<p>​	当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录中存储偏向的线程 ID，以后该线程在进入和退出同步块时，不需要进行 CAS 操作来加锁和解锁。只需要简单的测试一下对象头的 <code>Mark Word</code>  里是否存储着当前线程的偏向锁，如果成功，标识已经获取到了锁。</p>
<h5 id="偏向锁的撤销"><a class="markdownIt-Anchor" href="#偏向锁的撤销">#</a> 偏向锁的撤销</h5>
<p>​	偏向锁使用一种等待竞争放锁机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点（就是当前线程没有正在执行的代码）。它会首先暂停拥有偏向锁的线程，让你检查持有偏向锁的线程是否还或者。如果线程不处于活动状态，直接将对象设置为无锁状态。如果线程还或者，JVM 会便利战阵中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p>
<p><img data-src="https://pdai.tech/images/thread/java-thread-x-key-schronized-9.png" alt="img"></p>
<h4 id="轻量级锁"><a class="markdownIt-Anchor" href="#轻量级锁">#</a> 轻量级锁</h4>
<h4 id="重量级锁"><a class="markdownIt-Anchor" href="#重量级锁">#</a> 重量级锁</h4>
<h4 id="锁的优缺点对比"><a class="markdownIt-Anchor" href="#锁的优缺点对比">#</a> 锁的优缺点对比</h4>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要 CAS 操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了响应速度</td>
<td>如线程成始终得不到锁竞争的线程，使用自旋会消耗 CPU 性能</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不适用自旋，不会消耗 CPU</td>
<td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody>
</table>
<h3 id="synchronized与lock"><a class="markdownIt-Anchor" href="#synchronized与lock">#</a> synchronized 与 Lock</h3>
<h4 id="synchronized的缺陷"><a class="markdownIt-Anchor" href="#synchronized的缺陷">#</a> synchronized 的缺陷</h4>
<ul>
<li><strong>效率低</strong>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁。试图获取锁的时候不能设定超时，不能中断一个正在使用的线程，相对而言，Lock 可以中断和设置超时。</li>
<li><strong>不够灵活</strong>：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），相对而言，读写锁更加灵活。</li>
<li><strong>无法知道是否成功获取锁</strong>：相对而言，Lock 可以拿到状态，如果成功获取锁，如果获取锁失败。</li>
</ul>
<h4 id="lock解决相应问题"><a class="markdownIt-Anchor" href="#lock解决相应问题">#</a> Lock 解决相应问题</h4>
<p>Lock 类这里不做过多解释，主要看里面的 4 个方法:</p>
<ul>
<li><code>lock()</code> : 加锁</li>
<li><code>unlock()</code> : 解锁</li>
<li><code>tryLock()</code> : 尝试获取锁，返回一个 boolean 值</li>
<li><code>tryLock(long,TimeUtil)</code> : 尝试获取锁，可以设置超时</li>
</ul>
<p>Synchronized 只有锁只与一个条件 (是否获取锁) 相关联，不灵活，后来 <code>Condition与Lock的结合</code> 解决了这个问题。</p>
<p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock 的 lockInterruptibly () 方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后 ReentrantLock 响应这个中断，不再让这个线程继续等待。有了这个机制，使用 ReentrantLock 时就不会像 synchronized 那样产生死锁了。</p>
<h4 id="使用synchronized有哪些需要注意的"><a class="markdownIt-Anchor" href="#使用synchronized有哪些需要注意的">#</a> 使用 Synchronized 有哪些需要注意的</h4>
<ul>
<li>锁对象不能为空，因为锁的信息都保存在对象头里</li>
<li>作用域不宜过大，影响程序执行速度，控制范围过大，编写代码容易出错。</li>
<li>避免死锁。</li>
<li>在能选择的情况下，既不要用 Lock 也不要用 synchronized 关键字，用 java.util.concurrent 包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用 synchronized 关键，因为代码量少，避免出错。</li>
</ul>
<h4 id="synchronized是公平锁么"><a class="markdownIt-Anchor" href="#synchronized是公平锁么">#</a> synchronized 是公平锁么</h4>
<p>​	synchronized 实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象</p>
<h2 id="volatile详解"><a class="markdownIt-Anchor" href="#volatile详解">#</a> volatile 详解</h2>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用">#</a> 作用</h3>
<ul>
<li>防重排序：变量设置为 volatile 的类型，可以防止操作系统或者 JVM 进行重排序。</li>
<li>实现可见性：当一个线程更改了 volatile 类型变量，会立即刷新该变量值到主存中，其他线程需要使用该变量时，会去主存中重新读取该变量值，以此来避免可见性。</li>
<li>保证原子性：不能完全保证原子性，只能保证单次的读 / 写具有原子性。</li>
</ul>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理">#</a> 实现原理</h3>
<h4 id="volatile可见性实现"><a class="markdownIt-Anchor" href="#volatile可见性实现">#</a> volatile 可见性实现</h4>
<p>​	volatile 变量的内存可见性是基于内存屏障 (Memory Barrier) 实现的。</p>
<p>​	内存屏障，又称内存栅栏，是一个 CPU 指令。在程序运行时，为了提高程序运行的性能，编译器和处理器会对指令进行重排序，JVM 为了保证在不用的编译器和 CPU 上有相同的运行结果，通过插入特定类型的内存屏障来禁止 + 特定的编译器和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p>
<p>例如：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        test<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><pre><code>......
  0x0000000002951563: and    $0xffffffffffffff87,%rdi
  0x0000000002951567: je     0x00000000029515f8
  0x000000000295156d: test   $0x7,%rdi
  0x0000000002951574: jne    0x00000000029515bd
  0x0000000002951576: test   $0x300,%rdi
  0x000000000295157d: jne    0x000000000295159c
  0x000000000295157f: and    $0x37f,%rax
  0x0000000002951586: mov    %rax,%rdi
  0x0000000002951589: or     %r15,%rdi
  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令
  0x0000000002951591: jne    0x0000000002951a15
  0x0000000002951597: jmpq   0x00000000029515f8
  0x000000000295159c: mov    0x8(%rdx),%edi
  0x000000000295159f: shl    $0x3,%rdi
  0x00000000029515a3: mov    0xa8(%rdi),%rdi
  0x00000000029515aa: or     %r15,%rdi
......
</code></pre>
<p>​	lock 前缀的指令在多核处理器下会引发两件事：</p>
<ul>
<li>将当处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>
</ul>
<h2 id="final详解"><a class="markdownIt-Anchor" href="#final详解">#</a> final 详解</h2>
<h3 id="final的基础使用"><a class="markdownIt-Anchor" href="#final的基础使用">#</a> final 的基础使用</h3>
<h4 id="修饰类"><a class="markdownIt-Anchor" href="#修饰类">#</a> 修饰类</h4>
<p>当某个类被修饰为 final 时，就表明你不能继承该类。即这个类是不能有字类的。</p>
<p><strong>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中，给任何方法添加 final 关键字式没有任何意义的。</strong></p>
<h5 id="如何扩展final类"><a class="markdownIt-Anchor" href="#如何扩展final类">#</a> 如何扩展 final 类？</h5>
<p>​	在设计模式中，最重要的两种关系，一种是继承 / 实现，另一种是组合关系。</p>
<h4 id="修饰方法"><a class="markdownIt-Anchor" href="#修饰方法">#</a> 修饰方法</h4>
<ul>
<li>final 修饰的方法是不可继承的。</li>
<li>private 方法是隐式的 final。</li>
<li>final 方法是可以重载的。</li>
</ul>
<h4 id="修饰参数"><a class="markdownIt-Anchor" href="#修饰参数">#</a> 修饰参数</h4>
<p>​	 Java 允许在参数列表中以声明的方式将参数指明为 final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>
<h4 id="修饰变量"><a class="markdownIt-Anchor" href="#修饰变量">#</a> 修饰变量</h4>
<ul>
<li>
<p>编译期常量、非编译期常量。</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 编译期常量</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">J</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 非编译期常量</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">int</span> k <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p>static final 必须在定义的时候进行赋值。</p>
</li>
<li>
<p>空白 final：声明为 final 类型，但是不给定值，在使用前被赋值。</p>
</li>
</ul>
<p>###　final 域重排序规则</p>
<pre><code>#### 	final为基本类型
</code></pre>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token comment">// 普通域</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span> <span class="token comment">//final 域</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">FinalDemo</span> finalDemo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">FinalDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1. 写普通域</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 2. 写 final 域</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        finalDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token class-name">FinalDemo</span> demo <span class="token operator">=</span> finalDemo<span class="token punctuation">;</span> <span class="token comment">// 3. 读对象引用</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">int</span> a <span class="token operator">=</span> demo<span class="token punctuation">.</span>a<span class="token punctuation">;</span>    <span class="token comment">//4. 读普通域</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">int</span> b <span class="token operator">=</span> demo<span class="token punctuation">.</span>b<span class="token punctuation">;</span>    <span class="token comment">//5. 读 final 域</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="写final域的重排序规则"><a class="markdownIt-Anchor" href="#写final域的重排序规则">#</a> 写 final 域的重排序规则</h5>
<p>​	禁止对 final 域的写重排序到构造函数之外，这个规则主要包含了两个方面：</p>
<ul>
<li>
<p>JVM 会禁止编译器把 final 域的写重排序到构造函数之外；</p>
</li>
<li>
<p>编译器会在 final 域写之后，构造函数 return 之前，插入一个 storestore 屏障。这个屏障可以禁止处理器把 final 域的写重排序到构造函数之外。</p>
<p><img data-src="https://pdai.tech/images/thread/java-thread-x-key-final-1.png" alt="img"></p>
</li>
</ul>
<p>由于 a，b 之间没有数据依赖性，普通域 a 可能会被重排序到构造函数之外，线程 B 就有可能读到的是普通变量 a 初始化之前的值（零值），这样就可能出现错误。而 final 域 b，根据重排序规则，会禁止 final 修饰的变量 b 重排序到构造函数之外，从而 b 就能够正确赋值，线程 B 就能读到 final 变量初始化之后的值。</p>
<p>因此，写 final 域的重排序规则可以确保，在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而不同于就不具有这个保障。</p>
<h5 id="读final域重排序规则"><a class="markdownIt-Anchor" href="#读final域重排序规则">#</a> 读 final 域重排序规则</h5>
<p>规则为：在一个线程种，初次读对象引用和初次读对象包含的 final 域，JMM 会禁止这两个操作的重排序（注意，这个规则仅仅是针对处理器），处理器会在读 final 域的前面插入一个 LoadLoad 屏障。 实际上，读对象的引用和读该对象的 final 域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p>
<p><img data-src="https://pdai.tech/images/thread/java-thread-x-key-final-2.png" alt="img"></p>
<p>读对象的普通域被重排序到了读对象引用的前面就会出现线程 B 还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而 final 域的读操作就 “限定” 了在读 final 域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p>
<p>读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读这个包含这个 final 域的对象的引用。</p>
<h4 id="final为引用类型"><a class="markdownIt-Anchor" href="#final为引用类型">#</a> final 为引用类型</h4>
<h5 id="写重排序规则"><a class="markdownIt-Anchor" href="#写重排序规则">#</a> 写重排序规则</h5>
<p>​	针对引用数据类型，final 域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个 final 修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是 “增加” 也就说前面对 final 基本数据类型的重排序规则在这里还是使用。</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalReferenceDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrays<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">FinalReferenceDemo</span> finalReferenceDemo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">FinalReferenceDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        arrays <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//1</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        arrays<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//2</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writerOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        finalReferenceDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalReferenceDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//3</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writerTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        arrays<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//4</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>finalReferenceDemo <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//5</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">int</span> temp <span class="token operator">=</span> finalReferenceDemo<span class="token punctuation">.</span>arrays<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//6</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://pdai.tech/images/thread/java-thread-x-key-final-3.png" alt="img"></p>
<p>由于对 final 域的写禁止重排序到构造方法外，因此 1 和 3 不能被重排序。由于一个 final 域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此 2 和 3 不能重排序。</p>
<h5 id="读重排序规则"><a class="markdownIt-Anchor" href="#读重排序规则">#</a> 读重排序规则</h5>
<p>JMM 可以确保线程 C 至少能看到写线程 A 对 final 引用的对象的成员域的写入，即能看下 arrays [0] = 1，而写线程 B 对数组元素的写入可能看到可能看不到。JMM 不保证线程 B 的写入对线程 C 可见，线程 B 和线程 C 之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者 volatile</p>
</div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2023-02-14 11:58:55" itemprop="dateModified" datetime="2023-02-14T11:58:55+08:00">2023-02-14</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/assets/wechatpay.png" alt="一念成余 微信支付"/><p>微信支付</p></div><div><img data-src="/assets/alipay.png" alt="一念成余 支付宝"/><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>一念成余<i class="ic i-at"><em>@</em></i>Live My Life</li><li class="link"><strong>本文链接：</strong><a href="http://1405904364.github.io/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/" title="">http://1405904364.github.io/2024/02/18/后端/Java/线程并发关键字详解/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;images.pexels.com&#x2F;photos&#x2F;12635428&#x2F;pexels-photo-12635428.jpeg" title="未命名"><span class="type">上一篇</span><h3>未命名</h3></a></div><div class="item right"><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;i.imgtg.com&#x2F;2023&#x2F;03&#x2F;09&#x2F;YS6XY.jpg" title="函数式编程"><span class="type">下一篇</span><h3>函数式编程</h3></a></div></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text"> 线程并发关键字详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized"><span class="toc-number">1.1.</span> <span class="toc-text"> synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.0.1.</span> <span class="toc-text"> 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="toc-number">1.1.0.2.</span> <span class="toc-text"> 对象锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E9%94%81"><span class="toc-number">1.1.0.3.</span> <span class="toc-text"> 类锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 加锁和释放锁的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86%E5%8A%A0%E9%94%81%E6%AC%A1%E6%95%B0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.1.2.</span> <span class="toc-text"> 可重入原理：加锁次数计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E7%90%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Chappens-before%E8%A7%84%E5%88%99"><span class="toc-number">1.1.1.3.</span> <span class="toc-text"> 保证可见性原理：内存模型和 happens-before 规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm%E4%B8%AD%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text"> JVM 中锁的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 锁的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 自旋锁、自适应自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">1.1.2.3.</span> <span class="toc-text"> 锁消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">1.1.2.4.</span> <span class="toc-text"> 锁粗化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.1.2.5.</span> <span class="toc-text"> 偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">1.1.2.5.1.</span> <span class="toc-text"> 偏向锁的撤销</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.1.2.6.</span> <span class="toc-text"> 轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.1.2.7.</span> <span class="toc-text"> 重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.2.8.</span> <span class="toc-text"> 锁的优缺点对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E4%B8%8Elock"><span class="toc-number">1.1.3.</span> <span class="toc-text"> synchronized 与 Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> synchronized 的缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock%E8%A7%A3%E5%86%B3%E7%9B%B8%E5%BA%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> Lock 解决相应问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8synchronized%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84"><span class="toc-number">1.1.3.3.</span> <span class="toc-text"> 使用 Synchronized 有哪些需要注意的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E4%B9%88"><span class="toc-number">1.1.3.4.</span> <span class="toc-text"> synchronized 是公平锁么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text"> volatile 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text"> volatile 可见性实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text"> final 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text"> final 的基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">1.3.1.1.</span> <span class="toc-text"> 修饰类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95final%E7%B1%BB"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text"> 如何扩展 final 类？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.2.</span> <span class="toc-text"> 修饰方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.3.</span> <span class="toc-text"> 修饰参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.1.4.</span> <span class="toc-text"> 修饰变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99final%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-number">1.3.1.4.1.</span> <span class="toc-text"> 写 final 域的重排序规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BBfinal%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-number">1.3.1.4.2.</span> <span class="toc-text"> 读 final 域重排序规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E4%B8%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.5.</span> <span class="toc-text"> final 为引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-number">1.3.1.5.1.</span> <span class="toc-text"> 写重排序规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-number">1.3.1.5.2.</span> <span class="toc-text"> 读重排序规则</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="一念成余" data-src="/assets/avatar.jpg"/><p class="name" itemprop="name">一念成余</p><div class="description" itemprop="description">个人学习使用</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">97</span><span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span><span class="name">标签</span></a></div></nav><div class="social"><a href="https://github.com/name" class="item github" rel="noopener" title="https:&#x2F;&#x2F;github.com&#x2F;name" target="_blank"><i class="ic i-github"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E4%B8%AA%E4%BA%BA/PhotoShop/1.%E4%BA%86%E8%A7%A3%E5%9B%BE%E5%B1%82/">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/12.%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/5.%E5%AD%90%E6%9F%A5%E8%AF%A2/">Mysql子查询</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/10/hello-world/">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/11.distinct%E5%8E%BB%E9%87%8D/distinct/">Mysql中Distinct去重</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E5%89%8D%E7%AB%AF/VUE/2.Vue%E5%9F%BA%E7%A1%80/3.%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/webService/%E7%AE%80%E4%BB%8B/">webService的使用</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E5%90%8E%E7%AB%AF/Mysql/1.Mysql%E6%A6%82%E8%BF%B0/%E6%A6%82%E8%BF%B0/">Mysql概述</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/18/%E5%89%8D%E7%AB%AF/%E4%B8%89%E4%BB%B6%E5%A5%97/HTML/1.%E7%AE%80%E4%BB%8B/">未命名</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">一念成余 @ testName</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">184k 字</span><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">2:47</span></div><div class="powered-by">基于 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & Theme.<a href="https://github.com/theme-shoka-x/hexo-theme-shokaX/" rel="noopener" target="_blank">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
        path: `2024/02/18/后端/Java/线程并发关键字详解/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,
    chart: false,
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: ``,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;&lt;span class=&quot;label warning&quot;&gt;文章时效性提示&lt;/span&gt;&lt;br&gt;这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。&lt;/p&gt;&lt;/div&gt;`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default,fetch"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.0.2/pace.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/algoliasearch/4.12.1/algoliasearch-lite.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/instantsearch.js/4.39.0/instantsearch.production.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/quicklink/2.2.0/quicklink.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/??jquery/3.5.1/jquery.min.js,fancybox/3.5.7/jquery.fancybox.min.js,justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" async></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/KaTeX/0.15.2/contrib/copy-tex.min.js" async></script><script src="/js/app.js?v=0.3.3"></script></body></html>